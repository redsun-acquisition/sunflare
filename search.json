{"config":{"separator":"[\\s\\-_,:!=\\[\\]()\\\\\"`/]+|\\.(?!\\d)"},"items":[{"location":"","level":1,"title":"<code>sunflare</code>","text":"<p>Warning</p> <p>This project is currently under active development and it may (and most likely will) receive breaking changes. Use at your own risk.</p> <p><code>sunflare</code> is a software development kit (SDK) which provides common, reusable components for building plugins which can interact with <code>redsun</code>.</p> <p>The aim is to provide reusable patterns in developing software applications for scientific device orchestration leveraging the Bluesky hardware interface and data model.</p> <ul> <li> <p>Tutorials</p> <p>Learn Sunflare from the ground up with step-by-step lessons.</p> <p>Start learning </p> </li> <li> <p>How-to guides</p> <p>Practical guides for common tasks and problems.</p> <p>Browse guides </p> </li> <li> <p>Reference</p> <p>Technical documentation and API reference.</p> <p>View reference </p> </li> <li> <p>Explanations</p> <p>Understand the concepts and design behind Sunflare</p> <p>Read explanations </p> </li> </ul>","path":["sunflare"],"tags":[]},{"location":"#about-the-documentation","level":2,"title":"About the documentation","text":"<p>This documentation follows the Di√°taxis framework, organizing content into four distinct categories based on your needs:</p> <ul> <li>Tutorials are learning-oriented lessons.</li> <li>How-to guides are task-oriented recipes.</li> <li>Reference is information-oriented technical descriptions.</li> <li>Explanations is understanding-oriented discussions.</li> </ul>","path":["sunflare"],"tags":[]},{"location":"#project-links","level":2,"title":"Project links","text":"<ul> <li>GitHub repository</li> <li>PyPI package</li> <li>Redsun framework</li> </ul>","path":["sunflare"],"tags":[]},{"location":"explanations/","level":1,"title":"Explanations","text":"<ul> <li>Statement of Need</li> </ul>","path":["Explanations"],"tags":[]},{"location":"explanations/#architectural-design","level":2,"title":"Architectural design","text":"<ul> <li>Devices</li> <li>Presenters</li> <li>Virtual bus</li> </ul>","path":["Explanations"],"tags":[]},{"location":"explanations/statement/","level":1,"title":"Statement of need","text":"<p>The goal of Sunflare is to provide shared and recognizable programming patterns accross the entire Redsun ecosystem. As Redsun heavily leverages the concept of plugins, there is a need to provide a clear representation and a shared communication channel between the plugins that in the end build the desired application.</p> Framework structure <pre><code>graph LR\n    sunflare --&gt;|builds| plugins\n    sunflare --&gt;|builds| redsun\n    plugins --&gt;|used in| redsun</code></pre> <p>The diagram shows the relationship between Redsun, Sunflare and the custom plugins. Effectively, Redsun is nothing more than \"glue\" code that constructs your custom application. What it does is:</p> <ul> <li>retrieve the user plugins via Python entry points;</li> <li>build said plugins and catch any possible exception throw by them;</li> <li>build the final application and connecting all the plugins together.</li> </ul> <p>This approach ensures that Sunflare can be reused as a standalone package to provide reusable code to create custom control interfaces for your device, which fit the Bluesky message protocol and data model.</p> <p>Furthermore, if you have an existing package for hardware control, <code>sunflare</code> can be used to create a wrapper for your classes which can then \"talk\" the Bluesky language.</p>","path":["Explanations","Statement of need"],"tags":[]},{"location":"explanations/architecture/devices/","level":1,"title":"Devices","text":"<p>A <code>Device</code> class represents an interface with a hardware device.</p> <p>The definition of a device is quite fluid, as there are many ways that it can interact with the hardware depending on your needs.</p> <p>All devices must inherit from the <code>Device</code> base class, either:</p> <ul> <li>directly, via inheritance;</li> <li>indirectly, following structural subtyping (PEP 544) via the <code>PDevice</code> protocol.</li> </ul> <p>Each device requires a positional-only argument <code>name</code> that serves as a unique identifier for a <code>redsun</code> session; additional initialization parameters can be provided as keyword-only arguments.</p> <pre><code>from sunflare.device import Device\n\nclass MyDevice(Device)\n\n    def __init__(self, name: str, /, int_param: int, str_param: str) -&gt; None:\n        ... # your implementation\n</code></pre>","path":["Explanations","Architecture","Devices"],"tags":[]},{"location":"explanations/architecture/devices/#see-also","level":2,"title":"See Also","text":"<ul> <li>In-process devices</li> </ul>","path":["Explanations","Architecture","Devices"],"tags":[]},{"location":"explanations/architecture/in-process-device/","level":1,"title":"In-process devices","text":"<p>In-process devices provide interaction with the device API in the same process:</p> <ul> <li>by importing the API as a Python package and use it as a local object: API via aggregation;</li> <li>by inheriting from an existing class that encapsulates the commands of your device: API via inheritance.</li> </ul>","path":["Explanations","Architecture","In-process devices"],"tags":[]},{"location":"explanations/architecture/in-process-device/#api-via-aggregation","level":2,"title":"API via aggregation","text":"<p>\"Aggregation\" means when an object is constructed inside a class.</p> <p>In this usage, a standard device is simply a wrapper around the actual device interface you want to control.</p> <p>The wrapped interface is often referred to as <code>handler</code>, although it varies depending on implementation details. The external application should not interact directly with the <code>handler</code> object; instead, the Device wrapping it should take care of calling the appropriate methods of the <code>handler</code> to perform the required tasks.</p> <p>Tip</p> <p>It is good practice to mark your handler object via a double underscore <code>__</code>, i.e. <code>__handler</code>, symbolizing that this is a private attribute (meaning that only your Device object can use it internally and it is not accessible from the outside). In truth, Python does not really enforce private attributes - meaning that there are ways to circumvent the privacy - but it is considered standard practice to annotate them in this manner.</p> UMLPython <pre><code>classDiagram\n    class MyDevice {\n        -DeviceHandler __handler\n        +str name\n        +None parent\n        configure() None\n        read_configuration() dict[str, Reading]\n        describe_configuration() dict[str, DataKey]\n    }\n    class DeviceHandler {\n        +int param1\n        +float param2\n        device_method() void\n    }\n\n    MyDevice *-- DeviceHandler</code></pre> my_plugin/device.py<pre><code>from sunflare.device import Device\nfrom device_package import DeviceHandler\nfrom bluesky.protocols import Reading, Descriptor\n\nclass MyDevice(Device):\n    def __init__(self, name: str, **kwargs) -&gt; None:\n        super().__init__(name, **kwargs)\n\n        # unpack the parameters you need\n        # to initialize DeviceHandler,\n        # or provide them hard-coded\n        param1 = kwargs.get(\"param1\", 0)\n        param2 = kwargs.get(\"param2\", 0.0)\n        self.__handler = DeviceHandler(int_param=param1, float_param=param2, bool_param=True)\n\n    def configure(self) -&gt; None:\n        # here goes your implementation;\n        self.__handler.configure()\n\n    def read_configuration(self) -&gt; dict[str, Reading]:\n        # here goes your implementation;\n        return self.__handler.read_configuration()\n\n    def describe_configuration(self) -&gt; dict[str, Descriptor]:\n        # here goes your implementation;\n        return self.__handler.describe_configuration()\n</code></pre> <p>Furthermore, a single Device can encapsulate multiple handlers, each of them with different functionalities. Keep in mind that it is your responsability (as developer) to associate the execution of Bluesky messages with the appropriate device handler.</p> my_plugin/device.py<pre><code># a dummy representation of a plugin package that encapsulates\n# a Device wrapping controls for a camera and a motor\nfrom sunflare.device import Device\nfrom device_package import CameraHandler, MotorHandler\n\nclass MyDevice(Device):\n    def __init__(self, name: str, **kwargs) -&gt; None:\n        super().__init__(name, **kwargs)\n\n        self.__motor_handler = MotorHandler(**kwargs.get(\"motor_parameters\", {}))\n        self.__camera_handler = CameraHandler(**kwargs.get(\"camera_parameters\", {}))\n</code></pre>","path":["Explanations","Architecture","In-process devices"],"tags":[]},{"location":"explanations/architecture/in-process-device/#api-via-inheritance","level":2,"title":"API via inheritance","text":"<p>Using aggregation to control your device interface may be impractical if <code>DeviceHandler</code> already leverages a lot of internal code. Inheriting your Device from a pre-existing class gives the benefit of reusing it without having to rewrite any of the internals.</p> UMLPython <pre><code>classDiagram\n    class MyDevice {\n        +str name\n        +None parent\n        configure() None\n        read_configuration() dict[str, Reading]\n        describe_configuration() dict[str, DataKey]\n    }\n    class DeviceHandler {\n        device_method() void\n    }\n\n    MyDevice &lt;|-- DeviceHandler</code></pre> my_plugin/device.py<pre><code>from sunflare.device import Device\nfrom device_package import DeviceHandler\nfrom bluesky.protocols import Reading, Descriptor\n\nclass MyDevice(Device, DeviceHandler):\n    def __init__(self, name: str, **kwargs) -&gt; None:\n        super().__init__(name, **kwargs)\n\n    def configure(self) -&gt; None:\n        # here goes your implementation;\n        super().configure()\n\n    def read_configuration(self) -&gt; dict[str, Reading]:\n        # here goes your implementation;\n        return super().read_configuration()\n\n    def describe_configuration(self) -&gt; dict[str, Descriptor]:\n        # here goes your implementation;\n        return super().describe_configuration()\n</code></pre> <p>Just like in the aggregated API, your device can also inherit from multiple classes. Again, it is your responsibility (as developer) to ensure that the appropriate Bluesky protocols are invoked on the correct device.</p> my_plugin/device.py<pre><code># a dummy representation of a plugin package that encapsulates\n# a Device wrapping controls for a camera and a motor\nfrom sunflare.device import Device\nfrom device_package import CameraHandler, MotorHandler\n\nclass MyDevice(Device, CameraHandler, MotorHandler):\n    def __init__(self, name: str, **kwargs) -&gt; None:\n        super().__init__(name, **kwargs)\n</code></pre>","path":["Explanations","Architecture","In-process devices"],"tags":[]},{"location":"explanations/architecture/in-process-device/#key-differences","level":2,"title":"Key differences","text":"<p>Although they may initially look similar, there are key differences and advantages in each approach.</p> <p>Aggregation is useful... - ... when you want to have a more fine-grained control over your device; - ... when your device interface doesn't have an actual class encapsulating methods and parameters but instead uses a different programming paradigm; - ... when you don't want to expose certain behaviors of your device to the end-user (a.k.a. inhibiting the possibility to call public methods); - ... when your device interface is built using another language (C++, Rust, ...) and you want to keep a minimal level of abstraction between the device and the handler; - ... when your handler actually controls the interaction with multiple devices topology and you want to expose only a sub-set of those functionalities.</p> <p>An example candidate for aggregation is the [<code>pymmcore-plus</code>] package, which wraps the controls of multiple Micro-Manager devices behind the [<code>CMMCorePlus</code>] interface and provides additional functionalities (such as the [<code>MDAEngine</code>]).</p> <p>Inheritance is useful... - ... when your device has a lot of code and you want to quickly wrap it to be Bluesky-compatible; - ... when it provides extra functionalities that allow to work with remote devices by default; - ... when it is already a Bluesky-compatible device and you just want to make it as a plugin for Redsun.</p> <p>Example candidates for inheritance are the [<code>microscope</code>] and [<code>openwfs</code>] packages, as they provide pre-configured interfaces that can be extended with additional Bluesky methods.</p>","path":["Explanations","Architecture","In-process devices"],"tags":[]},{"location":"explanations/architecture/presenters/","level":1,"title":"Presenters","text":"<p><code>Presenters</code> represent the execution logic of your system.</p> <p>Where <code>Devices</code> are \"workers\" (as they instruct your device to perform a certain task), <code>Presenters</code> can be \"orchestrators\", in the sense that they define the sequence of actions that workers must perform through Bluesky plans.</p> <p>We highlight \"can be\" because <code>Presenters</code> are not limited to that:</p> <ul> <li>they can consume Bluesky documents for on-the-fly processing, intermediate storage or redirection to a GUI (i.e. computing the FFT of an image and sending it to the GUI for display);</li> <li>they can provide manual control for device task execution and/or configuration;</li> <li>in comparison to plans (which represents an experimental procedure), one may wish to - for example - manually move a motor stage from the GUI, or change the exposure time of a camera; the <code>Presenter</code> in this case acts as a middle-man between the GUI and the device, directly calling Bluesky methods and bypassing the <code>RunEngine</code>;</li> <li>they can act as communication points with external applications to trigger actions via a custom communication protocol (or wait for possible commands incoming by said applications).</li> </ul> <p><code>Presenters</code> are meant to communicate between each other via the <code>VirtualBus</code>, which takes care of redirecting information (commands and/or documents) to the appropriate destination (whether it is another <code>Presenter</code> or a <code>View</code>).</p> <p>All presenters must implement the <code>PPresenter</code> interface to be recognized by Redsun.</p> <p>The <code>PPresenter</code> requires two things in its initialization:</p> <ul> <li>a <code>Mapping[str, Device]</code> of the allocated devices in the session;</li> <li>a reference to the <code>VirtualBus</code> in order to provide a communication point with other presenters and widgets.</li> </ul> <p>Additional parameters can be passed via keyword arguments, which are parsed from the session configuration file.</p>","path":["Explanations","Architecture","Presenters"],"tags":[]},{"location":"explanations/architecture/virtual/","level":1,"title":"Virtual bus","text":"<p>The <code>VirtualBus</code> is a class encapsulating different communication mechanism to allow different presenters and widgets to exchange controls and/or data streams. It provides a \"Qt-like\" mechanism of signal connection through the <code>psygnal</code> package, where objects can dinamically register signals and connect to remote slots for communication in the main thread.</p>","path":["Explanations","Architecture","Virtual bus"],"tags":[]},{"location":"explanations/architecture/virtual/#signal-connection","level":2,"title":"Signal connection","text":"<p>The <code>VirtualBus</code> allows to create a connection between objects living in different plugins.</p> <p>Suppose you have the following example:</p> emitter_plugin.py<pre><code>class Emitter:\n    sigSender = Signal(int)\n</code></pre> receiver_plugin.py<pre><code>class Receiver:\n\n    def receiver_slot(param: int) -&gt; None:\n        print(\"I received\", param)\n</code></pre> <p>In a normal scenario where you have access to the codebase of both <code>Emitter</code> and <code>Receiver</code>, you would simply do the following:</p> <pre><code>emitter = Emitter()\nreceiver = Receiver()\n\nemitter.sigSender.connect(receiver.receiver_slot)\nemitter.sigSender.emit(10)\n\n# prints \"I received 10\"\n</code></pre> <p>Redsun operates by dinamically loading plugins, which means that <code>Emitter</code> and <code>Receiver</code> may come from different packages.</p> <p>The <code>VirtualBus</code> takes care of giving a common exposure and retrieval point between different plugins. The catch is that to be able to share a connection, <code>Emitter</code> and <code>Receiver</code> must be adapted to talk to the bus:</p> emitter_plugin.py<pre><code>from sunflare.virtual import VirtualBus\n\nclass Emitter:\n    sigSender = Signal(int)\n\n    def __init__(self, virtual_bus: VirtualBus) -&gt; None:\n        self.virtual_bus = virtual_bus\n\n    def registration_phase(self) -&gt; None:\n        self.virtual_bus.register_signals(self)\n</code></pre> receiver_plugin.py<pre><code>from sunflare.virtual import VirtualBus\n\nclass Receiver:\n\n    def __init__(self, virtual_bus: VirtualBus):\n        self.virtual_bus = virtual_bus\n\n    def receiver_slot(param: int) -&gt; None:\n        print(\"I received\", param)\n\n    def connection_phase(self) -&gt; None:\n        self.virtual_bus[\"Emitter\"][\"sigSender\"].connect(self.receiver_slot)\n</code></pre> <p>With this modifications, <code>Emitter</code> has informed the <code>VirtualBus</code> of the existence of <code>sigSender</code>, and <code>Receiver</code> can retrieve <code>sigSender</code> from <code>Emitter</code> to connect the signal to its slot <code>receiver_slot</code>.</p> <p>This enforces a specific call order: all <code>Emitter</code>-like object must call the <code>registration_phase</code> method before any <code>Receiver</code>-like object can call the <code>connection_phase</code> method, otherwise there will be a mismatch.</p> <p>Note</p> <p>If a <code>Receiver</code>-like object tries to connect to a non-defined signal, your application will not crash, but there will be simply no connection enstablished with your slots.</p> <p>As a user, you only need to provide these two methods to ensure a safe connection. When Redsun is launched, it takes care of calling <code>registration_phase</code> and <code>connection_phase</code> in the correct order to ensure a safe connection.</p> <p>Using Sunflare without Redsun</p> <p>If you're using Sunflare in a non-Redsun application, you'll have to:</p> <ul> <li>create an instance of <code>VirtualBus</code>;</li> <li>ensure <code>Emitter</code> objects call their <code>registration_phase</code> method before <code>Receiver</code> objects call their <code>connection_phase</code> method.</li> </ul> <pre><code>from sunflare.virtual import VirtualBus\n\nbus = VirtualBus()\n\nemitter = Emitter(bus)\nreceiver = Receiver(bus)\n\n# Register signals first\nemitter.registration_phase()\n\n# Then connect to them\nreceiver.connection_phase()\n\n# ... run your application\n</code></pre>","path":["Explanations","Architecture","Virtual bus"],"tags":[]},{"location":"how-to/","level":1,"title":"How-to guides","text":"<ul> <li>Installation - How to install <code>sunflare</code> in different environments.</li> <li>Build documentation - How to build the documentation locally.</li> <li>Run tests - How to run the test suite and generate coverage reports.</li> </ul>","path":["How to","How-to guides"],"tags":[]},{"location":"how-to/build-docs/","level":1,"title":"Build documentation","text":"<p>This guide shows you how to build the Sunflare documentation locally.</p>","path":["How to","Build documentation"],"tags":[]},{"location":"how-to/build-docs/#prerequisites","level":2,"title":"Prerequisites","text":"<p>Make sure you have installed <code>sunflare</code> with development dependencies.</p>","path":["How to","Build documentation"],"tags":[]},{"location":"how-to/build-docs/#build-with-zensical","level":2,"title":"Build with <code>zensical</code>","text":"<p>You can build the documentation by running the following command from the project root:</p> <pre><code>uv run mkdocs build\n</code></pre> <p>The built documentation will be in the <code>site/</code> directory. Open <code>site/index.html</code> in your browser to view it.</p>","path":["How to","Build documentation"],"tags":[]},{"location":"how-to/build-docs/#serve-documentation-locally","level":2,"title":"Serve documentation locally","text":"<p>For development, you can serve the documentation with live reload:</p> <pre><code>uv run zensical serve\n</code></pre> <p>This will start a local server at <code>http://localhost:8000</code> and automatically rebuild the documentation when you make changes.</p>","path":["How to","Build documentation"],"tags":[]},{"location":"how-to/build-docs/#troubleshooting","level":2,"title":"Troubleshooting","text":"","path":["How to","Build documentation"],"tags":[]},{"location":"how-to/build-docs/#missing-dependencies","level":3,"title":"Missing dependencies","text":"<p>If you get errors about missing dependencies, make sure you've installed the development dependencies:</p> <pre><code>uv sync\n</code></pre>","path":["How to","Build documentation"],"tags":[]},{"location":"how-to/build-docs/#port-already-in-use","level":3,"title":"Port already in use","text":"<p>If port 8000 is already in use, you can specify a different port:</p> <pre><code>uv run zensical serve --dev-addr localhost:8080\n</code></pre>","path":["How to","Build documentation"],"tags":[]},{"location":"how-to/build-docs/#next-steps","level":2,"title":"Next Steps","text":"<ul> <li>Learn how to run tests</li> <li>Read about <code>sunflare</code> architecture</li> </ul>","path":["How to","Build documentation"],"tags":[]},{"location":"how-to/installation/","level":1,"title":"Installation","text":"<p>This guide shows you how to install Sunflare in different environments.</p>","path":["How to","Installation"],"tags":[]},{"location":"how-to/installation/#create-a-virtual-environment","level":2,"title":"Create a Virtual Environment","text":"<p>It is recommended to install the package in a virtual environment.</p> uv (recommended)venvcondamamba <pre><code>uv venv --python 3.10\n\n# For Linux/macOS\nsource .venv/bin/activate\n\n# For Windows Command Prompt\n.venv\\Scripts\\activate.bat\n\n# For Windows PowerShell\n.venv\\Scripts\\Activate.ps1\n</code></pre> <pre><code># Python version depends on the globally installed Python\npython -m venv sunflare-env\n\n# For Linux/macOS\nsource sunflare-env/bin/activate\n\n# For Windows Command Prompt\nsunflare-env\\Scripts\\activate.bat\n\n# For Windows PowerShell\nsunflare-env\\Scripts\\Activate.ps1\n</code></pre> <pre><code>conda create -n sunflare-env python=3.10\nconda activate sunflare-env\n</code></pre> <pre><code>mamba create -n sunflare-env python=3.10\nmamba activate sunflare-env\n</code></pre>","path":["How to","Installation"],"tags":[]},{"location":"how-to/installation/#install-sunflare","level":2,"title":"Install <code>sunflare</code>","text":"<p>You can install the package from PyPI or directly from the GitHub repository.</p> PyPIGitHub (Development) <pre><code>uv pip install sunflare\n\n# ... or without uv\npip install -U sunflare\n</code></pre> <pre><code>git clone https://github.com/redsun-acquisition/sunflare.git\ncd sunflare\n\nuv sync\n\n# ... or without uv\npip install -e .[dev]\n</code></pre>","path":["How to","Installation"],"tags":[]},{"location":"how-to/installation/#install-development-dependencies","level":2,"title":"Install development dependencies","text":"<p>If you're contributing to Sunflare or want to run tests locally, install the development dependencies via PEP-735 dependency groups.</p> uv (recommended)pip <pre><code># Dev dependencies are automatically synchronized\nuv sync\n</code></pre> <pre><code>pip install -e .[dev]\n</code></pre>","path":["How to","Installation"],"tags":[]},{"location":"how-to/installation/#next-steps","level":2,"title":"Next steps","text":"<ul> <li>Build the documentation</li> <li>Run tests</li> <li>Check the tutorials to get started with Sunflare</li> </ul>","path":["How to","Installation"],"tags":[]},{"location":"how-to/run-tests/","level":1,"title":"Run tests","text":"<p>This guide shows you how to run the Sunflare test suite and generate coverage reports.</p>","path":["How to","Run tests"],"tags":[]},{"location":"how-to/run-tests/#prerequisites","level":2,"title":"Prerequisites","text":"<p>Make sure you have installed Sunflare with development dependencies.</p>","path":["How to","Run tests"],"tags":[]},{"location":"how-to/run-tests/#run-all-tests","level":2,"title":"Run all tests","text":"<p>You can run the tests by running the following command from the project root:</p> <pre><code>pytest\n</code></pre>","path":["How to","Run tests"],"tags":[]},{"location":"how-to/run-tests/#generate-coverage-reports","level":2,"title":"Generate coverage reports","text":"<p>You can obtain a test coverage report by running:</p> <pre><code>pytest --cov=sunflare --cov-report=html\n</code></pre> <p>This will generate an <code>htmlcov/</code> directory with the test coverage report. Open <code>htmlcov/index.html</code> in your browser to view it.</p>","path":["How to","Run tests"],"tags":[]},{"location":"how-to/run-tests/#run-tests-on-multiple-python-versions","level":2,"title":"Run tests on multiple Python versions","text":"<p><code>sunflare</code> provides a <code>noxfile.py</code> to run tests with <code>nox</code> on all supported Python versions.</p> <p>If you use <code>uv</code>, you can run tests as follows:</p> <pre><code># Install nox globally\nuv tool install nox\n\n# Run tests on all Python versions\nnox -s tests\n</code></pre> <p>This will test against all supported Python versions (3.10, 3.11, 3.12, 3.13).</p>","path":["How to","Run tests"],"tags":[]},{"location":"how-to/run-tests/#verbose-output","level":2,"title":"Verbose output","text":"<p>For more detailed output, use the <code>-v</code> flag:</p> <pre><code>pytest -v\n</code></pre>","path":["How to","Run tests"],"tags":[]},{"location":"how-to/run-tests/#stop-on-first-failure","level":2,"title":"Stop on First Failure","text":"<p>To stop at the first failing test:</p> <pre><code>pytest -x\n</code></pre>","path":["How to","Run tests"],"tags":[]},{"location":"how-to/run-tests/#next-steps","level":2,"title":"Next Steps","text":"<ul> <li>Build the documentation</li> <li><code>sunflare</code> architecture</li> <li>API reference</li> </ul>","path":["How to","Run tests"],"tags":[]},{"location":"reference/","level":1,"title":"Reference","text":"<ul> <li>API reference</li> <li>Changelog</li> </ul>","path":["Reference"],"tags":[]},{"location":"reference/api/","level":1,"title":"API reference","text":"<p>Classes:</p> Name Description <code>Device</code> <p>Base class for devices.</p> <code>PDevice</code> <p>Minimal required protocol for a recognizable device in Redsun.</p> <p>Classes:</p> Name Description <code>PPresenter</code> <p>Presenter protocol class.</p> <code>Presenter</code> <p>Presenter base class.</p> <p>Classes:</p> Name Description <code>VirtualBus</code> <p>Data exchange layer.</p> <code>HasShutdown</code> <p>Protocol marking your class as capable of shutting down.</p> <code>IsInjectable</code> <p>Protocol marking a class as injectable with dependencies from the container.</p> <code>IsProvider</code> <p>Protocol marking a class as a provider of dependencies.</p> <code>VirtualAware</code> <p>Protocol marking a class as aware of the virtual bus and able to connect to it.</p> <p>Attributes:</p> Name Type Description <code>CallbackType</code> <code>TypeAlias</code> <p>Type alias for document callback functions.</p> <code>SignalCache</code> <code>TypeAlias</code> <p>Cache type for signals of a specific class.</p> <p>Modules:</p> Name Description <code>qt</code> <p>Classes:</p> Name Description <code>PView</code> <p>Minimmal protocol a view component should implement.</p> <code>View</code> <p>Base view class.</p> <code>ViewPosition</code> <p>Supported view positions.</p> <p>Classes:</p> Name Description <code>Loggable</code> <p>Mixin class that adds a logger to a class instance with extra contextual information.</p> <p>Classes:</p> Name Description <code>Status</code> <p>Track the status of a potentially-lengthy action like moving or triggering.</p> <code>RunEngine</code> <p>The Run Engine execute messages and emits Documents.</p>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.device.Device","level":2,"title":"Device","text":"<p>               Bases: <code>PDevice</code>, <code>ABC</code></p> <p>Base class for devices.</p> <p>Users may subclass from this device and implement their own configuration properties and methods.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the device. Serves as a unique identifier for the object created from it.</p> required <code>kwargs</code> <code>Any</code> <p>Additional keyword arguments for device subclasses.</p> <code>{}</code> <p>Methods:</p> Name Description <code>describe_configuration</code> <p>Provide a description of the device configuration.</p> <code>read_configuration</code> <p>Provide a description of the device configuration.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the device, serving as a unique identifier.</p> <code>parent</code> <code>None</code> <p>Parent of the device. Always returns None for compliance with <code>HasParent</code> protocol.</p> Source code in <code>src/sunflare/device/_base.py</code> <pre><code>class Device(PDevice, abc.ABC):\n    \"\"\"Base class for devices.\n\n    Users may subclass from this device and implement their own\n    configuration properties and methods.\n\n    Parameters\n    ----------\n    name : str\n        Name of the device. Serves as a unique identifier for the object created from it.\n    kwargs : Any, optional\n        Additional keyword arguments for device subclasses.\n    \"\"\"\n\n    @abc.abstractmethod\n    def __init__(self, name: str, /, **kwargs: Any) -&gt; None:\n        self._name = name\n        super().__init__(**kwargs)\n\n    @abc.abstractmethod\n    def describe_configuration(self) -&gt; dict[str, Descriptor]:\n        \"\"\"Provide a description of the device configuration.\n\n        Subclasses should override this method to provide their own\n        configuration description compatible with the Bluesky event model.\n\n        Returns\n        -------\n        dict[str, Descriptor]\n            A dictionary with the description of each field of the device configuration.\n        \"\"\"\n        raise NotImplementedError\n\n    @abc.abstractmethod\n    def read_configuration(self) -&gt; dict[str, Reading[Any]]:\n        \"\"\"Provide a description of the device configuration.\n\n        Subclasses should override this method to provide their own\n        configuration reading compatible with the Bluesky event model.\n\n        Returns\n        -------\n        dict[str, Reading[Any]]\n            A dictionary with the reading of each field of the device configuration.\n        \"\"\"\n        raise NotImplementedError\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"The name of the device, serving as a unique identifier.\"\"\"\n        return self._name\n\n    @property\n    def parent(self) -&gt; None:\n        \"\"\"Parent of the device. Always returns None for compliance with [`HasParent`]() protocol.\"\"\"\n        return None\n</code></pre>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.device.Device.name","level":3,"title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>The name of the device, serving as a unique identifier.</p>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.device.Device.parent","level":3,"title":"parent  <code>property</code>","text":"<pre><code>parent: None\n</code></pre> <p>Parent of the device. Always returns None for compliance with <code>HasParent</code> protocol.</p>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.device.Device.describe_configuration","level":3,"title":"describe_configuration  <code>abstractmethod</code>","text":"<pre><code>describe_configuration() -&gt; dict[str, Descriptor]\n</code></pre> <p>Provide a description of the device configuration.</p> <p>Subclasses should override this method to provide their own configuration description compatible with the Bluesky event model.</p> <p>Returns:</p> Type Description <code>dict[str, Descriptor]</code> <p>A dictionary with the description of each field of the device configuration.</p> Source code in <code>src/sunflare/device/_base.py</code> <pre><code>@abc.abstractmethod\ndef describe_configuration(self) -&gt; dict[str, Descriptor]:\n    \"\"\"Provide a description of the device configuration.\n\n    Subclasses should override this method to provide their own\n    configuration description compatible with the Bluesky event model.\n\n    Returns\n    -------\n    dict[str, Descriptor]\n        A dictionary with the description of each field of the device configuration.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.device.Device.read_configuration","level":3,"title":"read_configuration  <code>abstractmethod</code>","text":"<pre><code>read_configuration() -&gt; dict[str, Reading[Any]]\n</code></pre> <p>Provide a description of the device configuration.</p> <p>Subclasses should override this method to provide their own configuration reading compatible with the Bluesky event model.</p> <p>Returns:</p> Type Description <code>dict[str, Reading[Any]]</code> <p>A dictionary with the reading of each field of the device configuration.</p> Source code in <code>src/sunflare/device/_base.py</code> <pre><code>@abc.abstractmethod\ndef read_configuration(self) -&gt; dict[str, Reading[Any]]:\n    \"\"\"Provide a description of the device configuration.\n\n    Subclasses should override this method to provide their own\n    configuration reading compatible with the Bluesky event model.\n\n    Returns\n    -------\n    dict[str, Reading[Any]]\n        A dictionary with the reading of each field of the device configuration.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.device.PDevice","level":2,"title":"PDevice","text":"<p>               Bases: <code>HasName</code>, <code>HasParent</code>, <code>Configurable[Any]</code>, <code>Protocol</code></p> <p>Minimal required protocol for a recognizable device in Redsun.</p> Source code in <code>src/sunflare/device/_base.py</code> <pre><code>@runtime_checkable\nclass PDevice(HasName, HasParent, Configurable[Any], Protocol):  # pragma: no cover\n    \"\"\"Minimal required protocol for a recognizable device in Redsun.\"\"\"\n</code></pre>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.presenter.PPresenter","level":2,"title":"PPresenter","text":"<p>               Bases: <code>Protocol</code></p> <p>Presenter protocol class.</p> <p>Provides the interface for a class that Redsun can recognize as a presenter by implementing the defined attributes.</p> <p>Attributes:</p> Name Type Description <code>devices</code> <code>Mapping[str, Device]</code> <p>Reference to the devices used in the presenter.</p> <code>virtual_bus</code> <code>VirtualBus</code> <p>Reference to the virtual bus.</p> Source code in <code>src/sunflare/presenter/_base.py</code> <pre><code>@runtime_checkable\nclass PPresenter(Protocol):  # pragma: no cover\n    \"\"\"Presenter protocol class.\n\n    Provides the interface for a class\n    that Redsun can recognize as a presenter by\n    implementing the defined attributes.\n\n    Attributes\n    ----------\n    devices : Mapping[str, sunflare.device.Device]\n        Reference to the devices used in the presenter.\n    virtual_bus : VirtualBus\n        Reference to the virtual bus.\n    \"\"\"\n\n    virtual_bus: VirtualBus\n    devices: Mapping[str, Device]\n</code></pre>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.presenter.Presenter","level":2,"title":"Presenter","text":"<p>               Bases: <code>PPresenter</code>, <code>ABC</code></p> <p>Presenter base class.</p> <p>Classes that do not directly inherit from it will need to match the <code>__init__</code> signature to ensure that at runtime Redsun registers them as virtual subclasses.</p> <p>Parameters:</p> Name Type Description Default <code>devices</code> <code>Mapping[str, Device]</code> <p>Reference to the devices used in the presenter.</p> required <code>virtual_bus</code> <code>VirtualBus</code> <p>Reference to the virtual bus.</p> required <code>kwargs</code> <code>Any</code> <p>Additional keyword arguments for presenter subclasses. These are parsed from the session configuration file.</p> <code>{}</code> Source code in <code>src/sunflare/presenter/_base.py</code> <pre><code>class Presenter(PPresenter, ABC):\n    \"\"\"Presenter base class.\n\n    Classes that do not directly inherit from it\n    will need to match the `__init__` signature\n    to ensure that at runtime Redsun registers\n    them as virtual subclasses.\n\n    Parameters\n    ----------\n    devices : Mapping[str, sunflare.device.Device]\n        Reference to the devices used in the presenter.\n    virtual_bus : sunflare.virtual.VirtualBus\n        Reference to the virtual bus.\n    kwargs : Any, optional\n        Additional keyword arguments for presenter subclasses.\n        These are parsed from the session configuration file.\n    \"\"\"\n\n    @abstractmethod\n    def __init__(\n        self, devices: Mapping[str, Device], virtual_bus: VirtualBus, /, **kwargs: Any\n    ) -&gt; None:\n        self.devices = devices\n        self.virtual_bus = virtual_bus\n        super().__init__(**kwargs)\n</code></pre>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.virtual.CallbackType","level":2,"title":"CallbackType  <code>module-attribute</code>","text":"<pre><code>CallbackType: TypeAlias = (\n    Callable[[str, Document], None] | DocumentRouter\n)\n</code></pre> <p>Type alias for document callback functions.</p>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.virtual.SignalCache","level":2,"title":"SignalCache  <code>module-attribute</code>","text":"<pre><code>SignalCache: TypeAlias = dict[str, SignalInstance]\n</code></pre> <p>Cache type for signals of a specific class.</p>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.virtual.VirtualBus","level":2,"title":"VirtualBus","text":"<p>               Bases: <code>Loggable</code></p> <p>Data exchange layer.</p> <p>The <code>VirtualBus</code> is a mechanism to exchange data between different parts of the system. Communication can happen between plugins on the same layer as well as between different layers of the system.</p> <p>It can be used to emit notifications and carry information to other plugins, or to register document callbacks that process documents generated during data acquisition.</p> <p>Methods:</p> Name Description <code>register_signals</code> <p>Register the signals of an object in the virtual bus.</p> <code>register_callbacks</code> <p>Register a document callback in the virtual bus.</p> <p>Attributes:</p> Name Type Description <code>callbacks</code> <code>dict[str, CallbackType]</code> <p>The currently registered document callbacks in the virtual bus.</p> <code>signals</code> <code>dict[str, SignalCache]</code> <p>The currently registered signals in the virtual bus.</p> Source code in <code>src/sunflare/virtual/_bus.py</code> <pre><code>class VirtualBus(Loggable):\n    \"\"\"Data exchange layer.\n\n    The ``VirtualBus`` is a mechanism to exchange\n    data between different parts of the system. Communication\n    can happen between plugins on the same layer as\n    well as between different layers of the system.\n\n    It can be used to emit notifications and carry information\n    to other plugins, or to register document callbacks\n    that process documents generated during data acquisition.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        self._signals: dict[str, SignalCache] = {}\n        self._callbacks: dict[str, CallbackType] = {}\n\n    def register_signals(\n        self, owner: object, only: Iterable[str] | None = None\n    ) -&gt; None:\n        \"\"\"\n        Register the signals of an object in the virtual bus.\n\n        Parameters\n        ----------\n        owner : object\n            The instance whose class's signals are to be cached.\n        only : Iterable[str], optional\n            A list of signal names to cache. If not provided, all\n            signals in the class will be cached automatically by inspecting\n            the class attributes.\n\n        Notes\n        -----\n        This method inspects the attributes of the owner's class to find\n        [`psygnal.Signal`][] descriptors. For each such descriptor, it retrieves\n        the [`psygnal.SignalInstance`][] from the owner using the descriptor protocol and\n        stores it in the registry.\n        \"\"\"\n        owner_class = type(owner)  # Get the class of the object\n        class_name = owner_class.__name__  # Name of the class\n\n        if only is None:\n            # Automatically detect all attributes of the class that are psygnal.Signal descriptors\n            only = [\n                name\n                for name in dir(owner_class)\n                if isinstance(getattr(owner_class, name, None), Signal)\n            ]\n\n        # Initialize the registry for this class if not already present\n        if class_name not in self._signals:\n            self._signals[class_name] = SignalCache()\n\n        # Iterate over the specified signal names and cache their instances\n        for name in only:\n            signal_descriptor = getattr(owner_class, name, None)\n            if isinstance(signal_descriptor, Signal):\n                # Retrieve the SignalInstance using the descriptor protocol\n                signal_instance = getattr(owner, name)\n                self._signals[class_name][name] = signal_instance\n\n    def register_callbacks(self, callback: CallbackType) -&gt; None:\n        \"\"\"Register a document callback in the virtual bus.\n\n        Allows other components of the system access to\n        specific document routers through the `callbacks` property.\n\n        Parameters\n        ----------\n        callback : CallbackType\n            The document callback to register.\n\n        Raises\n        ------\n        TypeError\n            If the provided callback is not callable or does not\n            accept the correct parameters.\n        \"\"\"\n        if isinstance(callback, DocumentRouter):\n            self._callbacks[callback.__class__.__name__] = callback\n        else:\n            if not callable(callback):\n                raise TypeError(f\"{callback} is not callable.\")\n            # validate that the callback accepts only two parameters\n            try:\n                inspect.signature(callback).bind(None, None)\n            except TypeError as e:\n                raise TypeError(\n                    \"The callback function must accept exactly two parameters: \"\n                    \"'name' (str) and 'document' (Document).\"\n                ) from e\n\n            # determine the key based on the type of callback\n            if inspect.ismethod(callback):\n                # bound method: if it's __call__, use the class name; otherwise use the method name\n                if callback.__name__ == \"__call__\":\n                    key = callback.__self__.__class__.__name__\n                else:\n                    key = callback.__name__\n            elif inspect.isfunction(callback):\n                # regular function: use the function name\n                key = callback.__name__\n            elif hasattr(callback, \"__call__\"):\n                # callable object (instance with __call__ method): use the class name\n                key = callback.__class__.__name__\n            else:\n                # fallback (should not reach here due to earlier callable check)\n                key = callback.__name__\n\n            self._callbacks[key] = callback\n\n    @property\n    def callbacks(self) -&gt; dict[str, CallbackType]:\n        \"\"\"The currently registered document callbacks in the virtual bus.\"\"\"\n        return self._callbacks\n\n    @property\n    def signals(self) -&gt; dict[str, SignalCache]:\n        \"\"\"The currently registered signals in the virtual bus.\"\"\"\n        return self._signals\n</code></pre>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.virtual.VirtualBus.callbacks","level":3,"title":"callbacks  <code>property</code>","text":"<pre><code>callbacks: dict[str, CallbackType]\n</code></pre> <p>The currently registered document callbacks in the virtual bus.</p>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.virtual.VirtualBus.signals","level":3,"title":"signals  <code>property</code>","text":"<pre><code>signals: dict[str, SignalCache]\n</code></pre> <p>The currently registered signals in the virtual bus.</p>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.virtual.VirtualBus.register_signals","level":3,"title":"register_signals","text":"<pre><code>register_signals(\n    owner: object, only: Iterable[str] | None = None\n) -&gt; None\n</code></pre> <p>Register the signals of an object in the virtual bus.</p> <p>Parameters:</p> Name Type Description Default <code>owner</code> <code>object</code> <p>The instance whose class's signals are to be cached.</p> required <code>only</code> <code>Iterable[str]</code> <p>A list of signal names to cache. If not provided, all signals in the class will be cached automatically by inspecting the class attributes.</p> <code>None</code> Notes <p>This method inspects the attributes of the owner's class to find <code>psygnal.Signal</code> descriptors. For each such descriptor, it retrieves the <code>psygnal.SignalInstance</code> from the owner using the descriptor protocol and stores it in the registry.</p> Source code in <code>src/sunflare/virtual/_bus.py</code> <pre><code>def register_signals(\n    self, owner: object, only: Iterable[str] | None = None\n) -&gt; None:\n    \"\"\"\n    Register the signals of an object in the virtual bus.\n\n    Parameters\n    ----------\n    owner : object\n        The instance whose class's signals are to be cached.\n    only : Iterable[str], optional\n        A list of signal names to cache. If not provided, all\n        signals in the class will be cached automatically by inspecting\n        the class attributes.\n\n    Notes\n    -----\n    This method inspects the attributes of the owner's class to find\n    [`psygnal.Signal`][] descriptors. For each such descriptor, it retrieves\n    the [`psygnal.SignalInstance`][] from the owner using the descriptor protocol and\n    stores it in the registry.\n    \"\"\"\n    owner_class = type(owner)  # Get the class of the object\n    class_name = owner_class.__name__  # Name of the class\n\n    if only is None:\n        # Automatically detect all attributes of the class that are psygnal.Signal descriptors\n        only = [\n            name\n            for name in dir(owner_class)\n            if isinstance(getattr(owner_class, name, None), Signal)\n        ]\n\n    # Initialize the registry for this class if not already present\n    if class_name not in self._signals:\n        self._signals[class_name] = SignalCache()\n\n    # Iterate over the specified signal names and cache their instances\n    for name in only:\n        signal_descriptor = getattr(owner_class, name, None)\n        if isinstance(signal_descriptor, Signal):\n            # Retrieve the SignalInstance using the descriptor protocol\n            signal_instance = getattr(owner, name)\n            self._signals[class_name][name] = signal_instance\n</code></pre>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.virtual.VirtualBus.register_callbacks","level":3,"title":"register_callbacks","text":"<pre><code>register_callbacks(callback: CallbackType) -&gt; None\n</code></pre> <p>Register a document callback in the virtual bus.</p> <p>Allows other components of the system access to specific document routers through the <code>callbacks</code> property.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>CallbackType</code> <p>The document callback to register.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>If the provided callback is not callable or does not accept the correct parameters.</p> Source code in <code>src/sunflare/virtual/_bus.py</code> <pre><code>def register_callbacks(self, callback: CallbackType) -&gt; None:\n    \"\"\"Register a document callback in the virtual bus.\n\n    Allows other components of the system access to\n    specific document routers through the `callbacks` property.\n\n    Parameters\n    ----------\n    callback : CallbackType\n        The document callback to register.\n\n    Raises\n    ------\n    TypeError\n        If the provided callback is not callable or does not\n        accept the correct parameters.\n    \"\"\"\n    if isinstance(callback, DocumentRouter):\n        self._callbacks[callback.__class__.__name__] = callback\n    else:\n        if not callable(callback):\n            raise TypeError(f\"{callback} is not callable.\")\n        # validate that the callback accepts only two parameters\n        try:\n            inspect.signature(callback).bind(None, None)\n        except TypeError as e:\n            raise TypeError(\n                \"The callback function must accept exactly two parameters: \"\n                \"'name' (str) and 'document' (Document).\"\n            ) from e\n\n        # determine the key based on the type of callback\n        if inspect.ismethod(callback):\n            # bound method: if it's __call__, use the class name; otherwise use the method name\n            if callback.__name__ == \"__call__\":\n                key = callback.__self__.__class__.__name__\n            else:\n                key = callback.__name__\n        elif inspect.isfunction(callback):\n            # regular function: use the function name\n            key = callback.__name__\n        elif hasattr(callback, \"__call__\"):\n            # callable object (instance with __call__ method): use the class name\n            key = callback.__class__.__name__\n        else:\n            # fallback (should not reach here due to earlier callable check)\n            key = callback.__name__\n\n        self._callbacks[key] = callback\n</code></pre>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.virtual.HasShutdown","level":2,"title":"HasShutdown","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol marking your class as capable of shutting down.</p> <p>Tip</p> <p>This protocol is optional and only available for <code>Presenters</code>. <code>Widgets</code> and <code>Devices</code> will not be affected by this protocol.</p> <p>Methods:</p> Name Description <code>shutdown</code> <p>Shutdown an object. Performs cleanup operations.</p> Source code in <code>src/sunflare/virtual/_protocols.py</code> <pre><code>@runtime_checkable\nclass HasShutdown(Protocol):  # pragma: no cover\n    \"\"\"Protocol marking your class as capable of shutting down.\n\n    !!! tip\n        This protocol is optional and only available for\n        ``Presenters``. ``Widgets`` and ``Devices`` will not\n        be affected by this protocol.\n    \"\"\"\n\n    @abstractmethod\n    def shutdown(self) -&gt; None:\n        \"\"\"Shutdown an object. Performs cleanup operations.\n\n        If the object holds any kind of resources,\n        this method should invoke any equivalent shutdown method for each resource.\n        \"\"\"\n        ...\n</code></pre>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.virtual.HasShutdown.shutdown","level":3,"title":"shutdown  <code>abstractmethod</code>","text":"<pre><code>shutdown() -&gt; None\n</code></pre> <p>Shutdown an object. Performs cleanup operations.</p> <p>If the object holds any kind of resources, this method should invoke any equivalent shutdown method for each resource.</p> Source code in <code>src/sunflare/virtual/_protocols.py</code> <pre><code>@abstractmethod\ndef shutdown(self) -&gt; None:\n    \"\"\"Shutdown an object. Performs cleanup operations.\n\n    If the object holds any kind of resources,\n    this method should invoke any equivalent shutdown method for each resource.\n    \"\"\"\n    ...\n</code></pre>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.virtual.IsInjectable","level":2,"title":"IsInjectable","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol marking a class as injectable with dependencies from the container.</p> <p>Tip</p> <p>This protocol is optional and only available for <code>Views</code>. <code>Presenters</code> and <code>Devices</code> will not be affected by it.</p> <p>Methods:</p> Name Description <code>inject_dependencies</code> <p>Inject dependencies from the container.</p> Source code in <code>src/sunflare/virtual/_protocols.py</code> <pre><code>@runtime_checkable\nclass IsInjectable(Protocol):  # pragma: no cover\n    \"\"\"Protocol marking a class as injectable with dependencies from the container.\n\n    !!! tip\n        This protocol is optional and only available for ``Views``.\n        ``Presenters`` and ``Devices`` will not be affected by it.\n    \"\"\"\n\n    @abstractmethod\n    def inject_dependencies(self, container: DynamicContainer) -&gt; None:\n        \"\"\"Inject dependencies from the container.\n\n        This method is invoked after the view is built object is built,\n        allowing to inject dependencies from the container\n        in order to customize the view after its construction.\n        \"\"\"\n        ...\n</code></pre>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.virtual.IsInjectable.inject_dependencies","level":3,"title":"inject_dependencies  <code>abstractmethod</code>","text":"<pre><code>inject_dependencies(container: DynamicContainer) -&gt; None\n</code></pre> <p>Inject dependencies from the container.</p> <p>This method is invoked after the view is built object is built, allowing to inject dependencies from the container in order to customize the view after its construction.</p> Source code in <code>src/sunflare/virtual/_protocols.py</code> <pre><code>@abstractmethod\ndef inject_dependencies(self, container: DynamicContainer) -&gt; None:\n    \"\"\"Inject dependencies from the container.\n\n    This method is invoked after the view is built object is built,\n    allowing to inject dependencies from the container\n    in order to customize the view after its construction.\n    \"\"\"\n    ...\n</code></pre>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.virtual.IsProvider","level":2,"title":"IsProvider","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol marking a class as a provider of dependencies.</p> <p>Tip</p> <p>This protocol is optional and only available for <code>Presenters</code>. <code>Widgets</code> and <code>Devices</code> will not be affected by it.</p> <p>Methods:</p> Name Description <code>register_providers</code> <p>Register providers in the dependency injection container.</p> Source code in <code>src/sunflare/virtual/_protocols.py</code> <pre><code>@runtime_checkable\nclass IsProvider(Protocol):  # pragma: no cover\n    \"\"\"Protocol marking a class as a provider of dependencies.\n\n    !!! tip\n        This protocol is optional and only available for\n        ``Presenters``. ``Widgets`` and ``Devices`` will not\n        be affected by it.\n    \"\"\"\n\n    @abstractmethod\n    def register_providers(self, container: DynamicContainer) -&gt; None:\n        \"\"\"Register providers in the dependency injection container.\n\n        This method is invoked after the presenter is built,\n        allowing to register providers in the DI container before any view is built.\n\n        !!! tip\n            This protocol is optional and only available for ``Presenters``.\n            ``Views`` and ``Devices`` will not be affected by it.\n        \"\"\"\n        ...\n</code></pre>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.virtual.IsProvider.register_providers","level":3,"title":"register_providers  <code>abstractmethod</code>","text":"<pre><code>register_providers(container: DynamicContainer) -&gt; None\n</code></pre> <p>Register providers in the dependency injection container.</p> <p>This method is invoked after the presenter is built, allowing to register providers in the DI container before any view is built.</p> <p>Tip</p> <p>This protocol is optional and only available for <code>Presenters</code>. <code>Views</code> and <code>Devices</code> will not be affected by it.</p> Source code in <code>src/sunflare/virtual/_protocols.py</code> <pre><code>@abstractmethod\ndef register_providers(self, container: DynamicContainer) -&gt; None:\n    \"\"\"Register providers in the dependency injection container.\n\n    This method is invoked after the presenter is built,\n    allowing to register providers in the DI container before any view is built.\n\n    !!! tip\n        This protocol is optional and only available for ``Presenters``.\n        ``Views`` and ``Devices`` will not be affected by it.\n    \"\"\"\n    ...\n</code></pre>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.virtual.VirtualAware","level":2,"title":"VirtualAware","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol marking a class as aware of the virtual bus and able to connect to it.</p> <p>Tip</p> <p>This protocol is optional and only usable with <code>Presenters</code> and <code>Views</code>. <code>Devices</code> will not be affected by it.</p> <p>Note</p> <p>In the future, this may be extended to support <code>Devices</code> as well.</p> <p>Methods:</p> Name Description <code>connect_to_virtual</code> <p>Connect to other objects via the virtual bus.</p> Source code in <code>src/sunflare/virtual/_protocols.py</code> <pre><code>@runtime_checkable\nclass VirtualAware(Protocol):  # pragma: no cover\n    \"\"\"Protocol marking a class as aware of the virtual bus and able to connect to it.\n\n    !!! tip\n        This protocol is optional and only usable with ``Presenters`` and ``Views``.\n        ``Devices`` will not be affected by it.\n\n    !!! note\n        In the future, this may be extended to support ``Devices`` as well.\n    \"\"\"\n\n    @abstractmethod\n    def connect_to_virtual(self) -&gt; None:\n        \"\"\"Connect to other objects via the virtual bus.\n\n        At application start-up, objects within Redsun can't know what signals are available from other parts of the session.\n        This method is invoked after the object's construction and after `registration_phase` as well, allowing to\n        connect to all available registered signals in the virtual bus.\n        Objects may be able to connect to other signals even after this phase (provided those signals\n        were registered before).\n\n        An implementation example:\n\n        ```python\n        def connect_to_virtual(self) -&gt; None:\n            # you can connect signals from another controller to your local slots...\n            self.virtual_bus[\"OtherController\"][\"signal\"].connect(self._my_slot)\n\n            # ... or to other signals ...\n            self.virtual_bus[\"OtherController\"][\"signal\"].connect(self.sigMySignal)\n\n            # ... or connect to a view component\n            self.virtual_bus[\"OtherWidget\"][\"sigWidget\"].connect(self._my_slot)\n        ```\n        \"\"\"\n        ...\n</code></pre>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.virtual.VirtualAware.connect_to_virtual","level":3,"title":"connect_to_virtual  <code>abstractmethod</code>","text":"<pre><code>connect_to_virtual() -&gt; None\n</code></pre> <p>Connect to other objects via the virtual bus.</p> <p>At application start-up, objects within Redsun can't know what signals are available from other parts of the session. This method is invoked after the object's construction and after <code>registration_phase</code> as well, allowing to connect to all available registered signals in the virtual bus. Objects may be able to connect to other signals even after this phase (provided those signals were registered before).</p> <p>An implementation example:</p> <pre><code>def connect_to_virtual(self) -&gt; None:\n    # you can connect signals from another controller to your local slots...\n    self.virtual_bus[\"OtherController\"][\"signal\"].connect(self._my_slot)\n\n    # ... or to other signals ...\n    self.virtual_bus[\"OtherController\"][\"signal\"].connect(self.sigMySignal)\n\n    # ... or connect to a view component\n    self.virtual_bus[\"OtherWidget\"][\"sigWidget\"].connect(self._my_slot)\n</code></pre> Source code in <code>src/sunflare/virtual/_protocols.py</code> <pre><code>@abstractmethod\ndef connect_to_virtual(self) -&gt; None:\n    \"\"\"Connect to other objects via the virtual bus.\n\n    At application start-up, objects within Redsun can't know what signals are available from other parts of the session.\n    This method is invoked after the object's construction and after `registration_phase` as well, allowing to\n    connect to all available registered signals in the virtual bus.\n    Objects may be able to connect to other signals even after this phase (provided those signals\n    were registered before).\n\n    An implementation example:\n\n    ```python\n    def connect_to_virtual(self) -&gt; None:\n        # you can connect signals from another controller to your local slots...\n        self.virtual_bus[\"OtherController\"][\"signal\"].connect(self._my_slot)\n\n        # ... or to other signals ...\n        self.virtual_bus[\"OtherController\"][\"signal\"].connect(self.sigMySignal)\n\n        # ... or connect to a view component\n        self.virtual_bus[\"OtherWidget\"][\"sigWidget\"].connect(self._my_slot)\n    ```\n    \"\"\"\n    ...\n</code></pre>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.view.PView","level":2,"title":"PView","text":"<p>               Bases: <code>Protocol</code></p> <p>Minimmal protocol a view component should implement.</p> <p>Attributes:</p> Name Type Description <code>virtual_bus</code> <code>VirtualBus</code> <p>Main virtual bus for the Redsun instance.</p> Source code in <code>src/sunflare/view/_base.py</code> <pre><code>@runtime_checkable\nclass PView(Protocol):\n    \"\"\"Minimmal protocol a view component should implement.\n\n    Attributes\n    ----------\n    virtual_bus : VirtualBus\n        Main virtual bus for the Redsun instance.\n    \"\"\"\n\n    virtual_bus: VirtualBus\n\n    @property\n    @abstractmethod\n    def view_position(self) -&gt; ViewPosition:\n        \"\"\"Position of the view component in the main view of the UI.\"\"\"\n</code></pre>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.view.PView.view_position","level":3,"title":"view_position  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>view_position: ViewPosition\n</code></pre> <p>Position of the view component in the main view of the UI.</p>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.view.View","level":2,"title":"View","text":"<p>               Bases: <code>PView</code>, <code>ABC</code></p> <p>Base view class.</p> <p>Parameters:</p> Name Type Description Default <code>virtual_bus</code> <code>VirtualBus</code> <p>Main virtual bus for the Redsun instance.</p> required <code>kwargs</code> <code>``Any``</code> <p>Additional keyword arguments for view subclasses.</p> <code>{}</code> <p>Attributes:</p> Name Type Description <code>view_position</code> <code>ViewPosition</code> <p>Position of the view component in the main view of the UI.</p> Source code in <code>src/sunflare/view/_base.py</code> <pre><code>class View(PView, ABC):\n    \"\"\"Base view class.\n\n    Parameters\n    ----------\n    virtual_bus : VirtualBus\n        Main virtual bus for the Redsun instance.\n    kwargs : ``Any``, optional\n        Additional keyword arguments for view subclasses.\n    \"\"\"\n\n    @abstractmethod\n    def __init__(self, virtual_bus: VirtualBus, /, **kwargs: Any) -&gt; None:\n        self.virtual_bus = virtual_bus\n        super().__init__(**kwargs)\n\n    @property\n    @abstractmethod\n    def view_position(self) -&gt; ViewPosition:\n        \"\"\"Position of the view component in the main view of the UI.\"\"\"\n</code></pre>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.view.View.view_position","level":3,"title":"view_position  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>view_position: ViewPosition\n</code></pre> <p>Position of the view component in the main view of the UI.</p>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.view.ViewPosition","level":2,"title":"ViewPosition","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Supported view positions.</p> <p>Used to define the position of a view component in the main view of the UI.</p> <p>Warning</p> <p>These values are based on how Qt manages dock widgets. They may change in the future.</p> <p>Attributes:</p> Name Type Description <code>CENTER</code> <code>str</code> <p>Center view position.</p> <code>LEFT</code> <code>str</code> <p>Left view position.</p> <code>RIGHT</code> <code>str</code> <p>Right view position.</p> <code>TOP</code> <code>str</code> <p>Top view position.</p> <code>BOTTOM</code> <code>str</code> <p>Bottom view position.</p> Source code in <code>src/sunflare/view/__init__.py</code> <pre><code>@unique\nclass ViewPosition(str, Enum):\n    \"\"\"Supported view positions.\n\n    Used to define the position of a view component in the main view of the UI.\n\n    !!! warning\n        These values are based on how Qt manages dock widgets.\n        They may change in the future.\n\n    Attributes\n    ----------\n    CENTER : str\n        Center view position.\n    LEFT : str\n        Left view position.\n    RIGHT : str\n        Right view position.\n    TOP : str\n        Top view position.\n    BOTTOM : str\n        Bottom view position.\n    \"\"\"\n\n    CENTER = \"center\"\n    LEFT = \"left\"\n    RIGHT = \"right\"\n    TOP = \"top\"\n    BOTTOM = \"bottom\"\n</code></pre>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.log.Loggable","level":2,"title":"Loggable","text":"<p>Mixin class that adds a logger to a class instance with extra contextual information.</p> <p>Attributes:</p> Name Type Description <code>logger</code> <code>_LoggerAdapter</code> <p>Logger instance with contextual information.</p> Source code in <code>src/sunflare/log.py</code> <pre><code>class Loggable:\n    \"\"\"Mixin class that adds a logger to a class instance with extra contextual information.\"\"\"\n\n    @cached_property\n    def logger(self) -&gt; _LoggerAdapter:\n        \"\"\"Logger instance with contextual information.\"\"\"\n        return ContextualAdapter(logging.getLogger(\"redsun\"), self)\n</code></pre>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.log.Loggable.logger","level":3,"title":"logger  <code>cached</code> <code>property</code>","text":"<pre><code>logger: _LoggerAdapter\n</code></pre> <p>Logger instance with contextual information.</p>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.engine.Status","level":2,"title":"Status","text":"<p>               Bases: <code>Status</code></p> <p>Track the status of a potentially-lengthy action like moving or triggering.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>float | None</code> <p>The amount of time to wait before marking the Status as failed.  If <code>None</code> (default) wait forever. It is strongly encouraged to set a finite timeout.  If settle_time below is set, that time is added to the effective timeout.</p> <code>None</code> <code>settle_time</code> <code>float | None</code> <p>The amount of time to wait between the caller specifying that the status has completed to running callbacks. Default is 0.</p> <code>0</code> Notes <p>Theory of operation:</p> <p>This employs two <code>threading.Event</code> objects, one thread that runs for (timeout + settle_time) seconds, and one thread that runs for settle_time seconds (if settle_time is nonzero).</p> <p>At init time, a timeout and settle_time are specified. A thread is started, on which user callbacks, registered after init time via <code>add_callback</code>, will eventually be run. The thread waits on an Event be set or (timeout + settle_time) seconds to pass, whichever happens first.</p> <p>If (timeout + settle_time) expires and the Event has not been set, an internal Exception is set to <code>StatusTimeoutError</code>, and a second Event is set, marking the Status as done and failed. The callbacks are run.</p> <p>If a callback is registered after the Status is done, it will be run immediately.</p> <p>If the first Event is set before (timeout + settle_time) expires, then the second Event is set and no internal Exception is set, marking the Status as done and successful. The callbacks are run.</p> <p>There are two methods that directly set the first Event. One, <code>set_exception</code>, sets it directly after setting the internal Exception.  The other, <code>set_finished</code>, starts a <code>threading.Timer</code> that will set it after a delay (the settle_time). One of these methods may be called, and at most once. If one is called twice or if both are called, <code>InvalidState</code> is raised. If they are called too late to prevent a <code>StatusTimeoutError</code>, they are ignored but one call is still allowed. Thus, an external callback, e.g. pyepics, may reports success or failure after the Status object has expired, but to no effect because the callbacks have already been called and the program has moved on.</p> <p>Methods:</p> Name Description <code>set_exception</code> <p>Mark as finished but failed with the given Exception.</p> <code>set_finished</code> <p>Mark as finished successfully.</p> <code>exception</code> <p>Return the exception raised by the action.</p> <code>wait</code> <p>Block until the action completes.</p> <code>add_callback</code> <p>Register a callback to be called once when the Status finishes.</p> <p>Attributes:</p> Name Type Description <code>timeout</code> <code>float | None</code> <p>The timeout for this action.</p> <code>settle_time</code> <code>float</code> <p>A delay between when <code>set_finished</code> is when the Status is done.</p> <code>done</code> <code>bool</code> <p>Boolean indicating whether associated operation has completed.</p> <code>success</code> <code>bool</code> <p>Boolean indicating whether associated operation has completed.</p> <code>callbacks</code> <code>deque[Callable[[Status], None]]</code> <p>Callbacks to be run when the status is marked as finished.</p> Source code in <code>src/sunflare/engine/_status.py</code> <pre><code>class Status(PStatus):\n    \"\"\"\n    Track the status of a potentially-lengthy action like moving or triggering.\n\n    Parameters\n    ----------\n    timeout: float, optional\n        The amount of time to wait before marking the Status as failed.  If\n        ``None`` (default) wait forever. It is strongly encouraged to set a\n        finite timeout.  If settle_time below is set, that time is added to the\n        effective timeout.\n    settle_time: float, optional\n        The amount of time to wait between the caller specifying that the\n        status has completed to running callbacks. Default is 0.\n\n    Notes\n    -----\n    Theory of operation:\n\n    This employs two ``threading.Event`` objects, one thread that runs for\n    (timeout + settle_time) seconds, and one thread that runs for\n    settle_time seconds (if settle_time is nonzero).\n\n    At __init__ time, a *timeout* and *settle_time* are specified. A thread\n    is started, on which user callbacks, registered after __init__ time via\n    [`add_callback`](), will eventually be run. The thread waits on an\n    Event be set or (timeout + settle_time) seconds to pass, whichever\n    happens first.\n\n    If (timeout + settle_time) expires and the Event has not\n    been set, an internal Exception is set to ``StatusTimeoutError``, and a\n    second Event is set, marking the Status as done and failed. The\n    callbacks are run.\n\n    If a callback is registered after the Status is done, it will be run\n    immediately.\n\n    If the first Event is set before (timeout + settle_time) expires,\n    then the second Event is set and no internal Exception is set, marking\n    the Status as done and successful. The callbacks are run.\n\n    There are two methods that directly set the first Event. One,\n    [`set_exception`](), sets it directly after setting the internal\n    Exception.  The other, [`set_finished`](), starts a\n    ``threading.Timer`` that will set it after a delay (the settle_time).\n    One of these methods may be called, and at most once. If one is called\n    twice or if both are called, ``InvalidState`` is raised. If they are\n    called too late to prevent a ``StatusTimeoutError``, they are ignored\n    but one call is still allowed. Thus, an external callback, e.g. pyepics,\n    may reports success or failure after the Status object has expired, but\n    to no effect because the callbacks have already been called and the\n    program has moved on.\n    \"\"\"\n\n    def __init__(self, *, timeout: float | None = None, settle_time: float | None = 0):\n        super().__init__()\n        self._logger = logging.getLogger(\"redsun\")\n        self._tname = None\n        self._lock = threading.RLock()\n        self._event = threading.Event()  # state associated with done-ness\n        self._settled_event = threading.Event()\n        # \"Externally initiated\" means set_finished() or set_exception(exc) was\n        # called, as opposed to completion via an internal timeout.\n        self._externally_initiated_completion_lock = threading.Lock()\n        self._externally_initiated_completion = False\n        self._callbacks: deque[Callable[[Status], None]] = deque()\n        self._exception: BaseException | None = None\n\n        if settle_time is None:\n            settle_time = 0.0\n\n        self._settle_time = float(settle_time)\n\n        if timeout is not None:\n            timeout = float(timeout)\n        self._timeout = timeout\n\n        self._callback_thread = threading.Thread(\n            target=self._run_callbacks, daemon=True, name=self._tname\n        )\n        self._callback_thread.start()\n\n    @property\n    def timeout(self) -&gt; float | None:\n        \"\"\"The timeout for this action.\n\n        This is set when the Status is created, and it cannot be changed.\n        \"\"\"\n        return self._timeout\n\n    @property\n    def settle_time(self) -&gt; float:\n        \"\"\"A delay between when [`set_finished`]() is when the Status is done.\n\n        This is set when the Status is created, and it cannot be changed.\n        \"\"\"\n        return self._settle_time\n\n    @property\n    def done(self) -&gt; bool:\n        \"\"\"Boolean indicating whether associated operation has completed.\n\n        This is set to True at __init__ time or by calling\n        [`set_finished`](), [`set_exception`]().\n        Once True, it can never become False.\n        \"\"\"\n        return self._event.is_set()\n\n    @property\n    def success(self) -&gt; bool:\n        \"\"\"Boolean indicating whether associated operation has completed.\n\n        This is set to True at __init__ time or by calling\n        [`set_finished`](), [`set_exception`]()\n        . Once True, it can never become False.\n        \"\"\"\n        return self.done and self._exception is None\n\n    def _handle_failure(self) -&gt; None:\n        \"\"\"Do something if an exception occurred during the action.\"\"\"\n        # TODO: implement this; maybe ophyd has a good example\n        pass\n\n    def _settled(self) -&gt; None:\n        \"\"\"Connect to this this when status has completed and settled.\"\"\"\n        # TODO: implement this; maybe ophyd has a good example\n        pass\n\n    def _run_callbacks(self) -&gt; None:\n        \"\"\"Set the Event and run the callbacks.\"\"\"\n        if self.timeout is None:\n            timeout = None\n        else:\n            timeout = self.timeout + self.settle_time\n        if not self._settled_event.wait(timeout):\n            # We have timed out. It's possible that set_finished() has already\n            # been called but we got here before the settle_time timer expired.\n            # And it's possible that in this space be between the above\n            # statement timing out grabbing the lock just below,\n            # set_exception(exc) has been called. Both of these possibilties\n            # are accounted for.\n            self._logger.warning(\"%r has timed out\", self)\n            with self._externally_initiated_completion_lock:\n                # Set the exception and mark the Status as done, unless\n                # set_exception(exc) was called externally before we grabbed\n                # the lock.\n                if self._exception is None:\n                    exc = StatusTimeoutError(\n                        f\"Status {self!r} failed to complete in specified timeout.\"\n                    )\n                    self._exception = exc\n        # Mark this as \"settled\".\n        try:\n            self._settled()\n        except Exception:\n            # No alternative but to log this. We can't supersede set_exception,\n            # and we have to continue and run the callbacks.\n            self._logger.exception(\"%r encountered error during _settled()\", self)\n        # Now we know whether or not we have succeed or failed, either by\n        # timeout above or by set_exception(exc), so we can set the Event that\n        # will mark this Status as done.\n        with self._lock:\n            self._event.set()\n        if self._exception is not None:\n            try:\n                self._handle_failure()\n            except Exception:\n                self._logger.exception(\n                    \"%r encountered an error during _handle_failure()\", self\n                )\n        # The callbacks have access to self, from which they can distinguish\n        # success or failure.\n        for cb in self._callbacks:\n            try:\n                cb(self)\n            except Exception:\n                self._logger.exception(\n                    \"An error was raised on a background thread while \"\n                    \"running the callback %r(%r).\",\n                    cb,\n                    self,\n                )\n        self._callbacks.clear()\n\n    def set_exception(self, exc: BaseException) -&gt; None:\n        \"\"\"Mark as finished but failed with the given Exception.\n\n        This method should generally not be called by the *recipient* of this\n        Status object, but only by the object that created and returned it.\n\n        Parameters\n        ----------\n        exc: BaseException\n            The exception that caused the failure.\n        \"\"\"\n        # Since we rely on this being raise-able later, check proactively to\n        # avoid potentially very confusing failures.\n        if not (isinstance(exc, BaseException)):\n            # Note that Python allows `raise Exception` or raise Exception()`\n            # so we allow a class or an instance here too.\n            raise ValueError(f\"Expected an Exception, got {exc!r}\")\n\n        # Ban certain Timeout subclasses that have special significance. This\n        # would probably never come up except due to some rare user error, but\n        # if it did it could be very confusing indeed!\n        for exc_class in (StatusTimeoutError, WaitTimeoutError):\n            if isinstance(exc, exc_class):\n                raise ValueError(\n                    f\"{exc_class} has special significance and cannot be set \"\n                    \"as the exception. Use a plain TimeoutError or some other \"\n                    \"subclass thereof.\"\n                )\n\n        with self._externally_initiated_completion_lock:\n            if self._externally_initiated_completion:\n                raise InvalidState(\n                    \"Either set_finished() or set_exception() has \"\n                    f\"already been called on {self!r}\"\n                )\n            self._externally_initiated_completion = True\n            if isinstance(self._exception, StatusTimeoutError):\n                # We have already timed out.\n                return\n            self._exception = exc\n            self._settled_event.set()\n\n    def set_finished(self) -&gt; None:\n        \"\"\"Mark as finished successfully.\n\n        This method should generally not be called by the *recipient* of this\n        Status object, but only by the object that created and returned it.\n        \"\"\"\n        with self._externally_initiated_completion_lock:\n            if self._externally_initiated_completion:\n                raise InvalidState(\n                    \"Either set_finished() or set_exception() has \"\n                    f\"already been called on {self!r}\"\n                )\n            self._externally_initiated_completion = True\n        # Note that in either case, the callbacks themselves are run from the\n        # same thread. This just sets an Event, either from this thread (the\n        # one calling set_finished) or the thread created below.\n        if self.settle_time &gt; 0:\n            threading.Timer(self.settle_time, self._settled_event.set).start()\n        else:\n            self._settled_event.set()\n\n    def exception(self, timeout: float | None = None) -&gt; BaseException | None:\n        \"\"\"Return the exception raised by the action.\n\n        If the action has completed successfully, return ``None``. If it has\n        finished in error, return the exception.\n\n        Parameters\n        ----------\n        timeout: float | None, optional\n            If None (default) wait indefinitely until the status finishes.\n\n        Returns\n        -------\n        Exception:\n            The exception raised by the action. If the action has completed\n            successfully, return ``None``.\n\n        Raises\n        ------\n        WaitTimeoutError\n            If the status has not completed within ``timeout`` (starting from\n            when this method was called, not from the beginning of the action).\n        \"\"\"\n        if not self._event.wait(timeout=timeout):\n            raise WaitTimeoutError(\"Status has not completed yet.\")\n        return self._exception\n\n    def wait(self, timeout: float | None = None) -&gt; None:\n        \"\"\"Block until the action completes.\n\n        When the action has finished succesfully, return ``None``. If the\n        action has failed, raise the exception.\n\n        Parameters\n        ----------\n        timeout: ``float``, optional\n            If ``None`` (default) wait indefinitely until the status finishes.\n\n        Raises\n        ------\n        WaitTimeoutError\n            If the status has not completed within ``timeout`` (starting from\n            when this method was called, not from the beginning of the action).\n        StatusTimeoutError\n            If the status has failed because the *timeout* that it was\n            initialized with has expired.\n        Exception\n            This is ``status.exception()``, raised if the status has finished\n            with an error.  This may include ``TimeoutError``, which\n            indicates that the action itself raised ``TimeoutError``, distinct\n            from ``WaitTimeoutError`` above.\n        \"\"\"\n        if not self._event.wait(timeout=timeout):\n            raise WaitTimeoutError(\"Status has not completed yet.\")\n        if self._exception is not None:\n            raise self._exception\n\n    @property\n    def callbacks(self) -&gt; deque[Callable[[Status], None]]:\n        \"\"\"Callbacks to be run when the status is marked as finished.\"\"\"\n        return self._callbacks\n\n    def add_callback(self, callback: Callable[[Status], None]) -&gt; None:\n        \"\"\"Register a callback to be called once when the Status finishes.\n\n        The callback will be called exactly once. If the Status is finished\n        before a callback is added, it will be called immediately. This is\n        threadsafe.\n        The callback will be called regardless of success of failure. The\n        callback has access to this status object, so it can distinguish success\n        or failure by inspecting the object.\n\n        Parameters\n        ----------\n        callback: ``Callable[[Status], None]``\n            The callback to be called when the status is marked as finished.\n\n            ```python\n            def callback(status: Status) -&gt; None:\n                # Do something with the status object\n                ...\n            ```\n        \"\"\"\n        with self._lock:\n            if self.done:\n                # Call it once and do not hold a reference to it.\n                callback(self)\n            else:\n                # Hold a strong reference to this. In other contexts we tend to\n                # hold weak references to callbacks, but this is a single-shot\n                # callback, so we will hold a strong reference until we call it,\n                # and then clear this cache to drop the reference(s).\n                self._callbacks.append(callback)\n</code></pre>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.engine.Status.timeout","level":3,"title":"timeout  <code>property</code>","text":"<pre><code>timeout: float | None\n</code></pre> <p>The timeout for this action.</p> <p>This is set when the Status is created, and it cannot be changed.</p>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.engine.Status.settle_time","level":3,"title":"settle_time  <code>property</code>","text":"<pre><code>settle_time: float\n</code></pre> <p>A delay between when <code>set_finished</code> is when the Status is done.</p> <p>This is set when the Status is created, and it cannot be changed.</p>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.engine.Status.done","level":3,"title":"done  <code>property</code>","text":"<pre><code>done: bool\n</code></pre> <p>Boolean indicating whether associated operation has completed.</p> <p>This is set to True at init time or by calling <code>set_finished</code>, <code>set_exception</code>. Once True, it can never become False.</p>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.engine.Status.success","level":3,"title":"success  <code>property</code>","text":"<pre><code>success: bool\n</code></pre> <p>Boolean indicating whether associated operation has completed.</p> <p>This is set to True at init time or by calling <code>set_finished</code>, <code>set_exception</code> . Once True, it can never become False.</p>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.engine.Status.callbacks","level":3,"title":"callbacks  <code>property</code>","text":"<pre><code>callbacks: deque[Callable[[Status], None]]\n</code></pre> <p>Callbacks to be run when the status is marked as finished.</p>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.engine.Status.set_exception","level":3,"title":"set_exception","text":"<pre><code>set_exception(exc: BaseException) -&gt; None\n</code></pre> <p>Mark as finished but failed with the given Exception.</p> <p>This method should generally not be called by the recipient of this Status object, but only by the object that created and returned it.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>BaseException</code> <p>The exception that caused the failure.</p> required Source code in <code>src/sunflare/engine/_status.py</code> <pre><code>def set_exception(self, exc: BaseException) -&gt; None:\n    \"\"\"Mark as finished but failed with the given Exception.\n\n    This method should generally not be called by the *recipient* of this\n    Status object, but only by the object that created and returned it.\n\n    Parameters\n    ----------\n    exc: BaseException\n        The exception that caused the failure.\n    \"\"\"\n    # Since we rely on this being raise-able later, check proactively to\n    # avoid potentially very confusing failures.\n    if not (isinstance(exc, BaseException)):\n        # Note that Python allows `raise Exception` or raise Exception()`\n        # so we allow a class or an instance here too.\n        raise ValueError(f\"Expected an Exception, got {exc!r}\")\n\n    # Ban certain Timeout subclasses that have special significance. This\n    # would probably never come up except due to some rare user error, but\n    # if it did it could be very confusing indeed!\n    for exc_class in (StatusTimeoutError, WaitTimeoutError):\n        if isinstance(exc, exc_class):\n            raise ValueError(\n                f\"{exc_class} has special significance and cannot be set \"\n                \"as the exception. Use a plain TimeoutError or some other \"\n                \"subclass thereof.\"\n            )\n\n    with self._externally_initiated_completion_lock:\n        if self._externally_initiated_completion:\n            raise InvalidState(\n                \"Either set_finished() or set_exception() has \"\n                f\"already been called on {self!r}\"\n            )\n        self._externally_initiated_completion = True\n        if isinstance(self._exception, StatusTimeoutError):\n            # We have already timed out.\n            return\n        self._exception = exc\n        self._settled_event.set()\n</code></pre>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.engine.Status.set_finished","level":3,"title":"set_finished","text":"<pre><code>set_finished() -&gt; None\n</code></pre> <p>Mark as finished successfully.</p> <p>This method should generally not be called by the recipient of this Status object, but only by the object that created and returned it.</p> Source code in <code>src/sunflare/engine/_status.py</code> <pre><code>def set_finished(self) -&gt; None:\n    \"\"\"Mark as finished successfully.\n\n    This method should generally not be called by the *recipient* of this\n    Status object, but only by the object that created and returned it.\n    \"\"\"\n    with self._externally_initiated_completion_lock:\n        if self._externally_initiated_completion:\n            raise InvalidState(\n                \"Either set_finished() or set_exception() has \"\n                f\"already been called on {self!r}\"\n            )\n        self._externally_initiated_completion = True\n    # Note that in either case, the callbacks themselves are run from the\n    # same thread. This just sets an Event, either from this thread (the\n    # one calling set_finished) or the thread created below.\n    if self.settle_time &gt; 0:\n        threading.Timer(self.settle_time, self._settled_event.set).start()\n    else:\n        self._settled_event.set()\n</code></pre>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.engine.Status.exception","level":3,"title":"exception","text":"<pre><code>exception(\n    timeout: float | None = None,\n) -&gt; BaseException | None\n</code></pre> <p>Return the exception raised by the action.</p> <p>If the action has completed successfully, return <code>None</code>. If it has finished in error, return the exception.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>float | None</code> <p>If None (default) wait indefinitely until the status finishes.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Exception</code> <code>BaseException | None</code> <p>The exception raised by the action. If the action has completed successfully, return <code>None</code>.</p> <p>Raises:</p> Type Description <code>WaitTimeoutError</code> <p>If the status has not completed within <code>timeout</code> (starting from when this method was called, not from the beginning of the action).</p> Source code in <code>src/sunflare/engine/_status.py</code> <pre><code>def exception(self, timeout: float | None = None) -&gt; BaseException | None:\n    \"\"\"Return the exception raised by the action.\n\n    If the action has completed successfully, return ``None``. If it has\n    finished in error, return the exception.\n\n    Parameters\n    ----------\n    timeout: float | None, optional\n        If None (default) wait indefinitely until the status finishes.\n\n    Returns\n    -------\n    Exception:\n        The exception raised by the action. If the action has completed\n        successfully, return ``None``.\n\n    Raises\n    ------\n    WaitTimeoutError\n        If the status has not completed within ``timeout`` (starting from\n        when this method was called, not from the beginning of the action).\n    \"\"\"\n    if not self._event.wait(timeout=timeout):\n        raise WaitTimeoutError(\"Status has not completed yet.\")\n    return self._exception\n</code></pre>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.engine.Status.wait","level":3,"title":"wait","text":"<pre><code>wait(timeout: float | None = None) -&gt; None\n</code></pre> <p>Block until the action completes.</p> <p>When the action has finished succesfully, return <code>None</code>. If the action has failed, raise the exception.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>float | None</code> <p>If <code>None</code> (default) wait indefinitely until the status finishes.</p> <code>None</code> <p>Raises:</p> Type Description <code>WaitTimeoutError</code> <p>If the status has not completed within <code>timeout</code> (starting from when this method was called, not from the beginning of the action).</p> <code>StatusTimeoutError</code> <p>If the status has failed because the timeout that it was initialized with has expired.</p> <code>Exception</code> <p>This is <code>status.exception()</code>, raised if the status has finished with an error.  This may include <code>TimeoutError</code>, which indicates that the action itself raised <code>TimeoutError</code>, distinct from <code>WaitTimeoutError</code> above.</p> Source code in <code>src/sunflare/engine/_status.py</code> <pre><code>def wait(self, timeout: float | None = None) -&gt; None:\n    \"\"\"Block until the action completes.\n\n    When the action has finished succesfully, return ``None``. If the\n    action has failed, raise the exception.\n\n    Parameters\n    ----------\n    timeout: ``float``, optional\n        If ``None`` (default) wait indefinitely until the status finishes.\n\n    Raises\n    ------\n    WaitTimeoutError\n        If the status has not completed within ``timeout`` (starting from\n        when this method was called, not from the beginning of the action).\n    StatusTimeoutError\n        If the status has failed because the *timeout* that it was\n        initialized with has expired.\n    Exception\n        This is ``status.exception()``, raised if the status has finished\n        with an error.  This may include ``TimeoutError``, which\n        indicates that the action itself raised ``TimeoutError``, distinct\n        from ``WaitTimeoutError`` above.\n    \"\"\"\n    if not self._event.wait(timeout=timeout):\n        raise WaitTimeoutError(\"Status has not completed yet.\")\n    if self._exception is not None:\n        raise self._exception\n</code></pre>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.engine.Status.add_callback","level":3,"title":"add_callback","text":"<pre><code>add_callback(callback: Callable[[Status], None]) -&gt; None\n</code></pre> <p>Register a callback to be called once when the Status finishes.</p> <p>The callback will be called exactly once. If the Status is finished before a callback is added, it will be called immediately. This is threadsafe. The callback will be called regardless of success of failure. The callback has access to this status object, so it can distinguish success or failure by inspecting the object.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[Status], None]</code> <p>The callback to be called when the status is marked as finished.</p> <pre><code>def callback(status: Status) -&gt; None:\n    # Do something with the status object\n    ...\n</code></pre> required Source code in <code>src/sunflare/engine/_status.py</code> <pre><code>def add_callback(self, callback: Callable[[Status], None]) -&gt; None:\n    \"\"\"Register a callback to be called once when the Status finishes.\n\n    The callback will be called exactly once. If the Status is finished\n    before a callback is added, it will be called immediately. This is\n    threadsafe.\n    The callback will be called regardless of success of failure. The\n    callback has access to this status object, so it can distinguish success\n    or failure by inspecting the object.\n\n    Parameters\n    ----------\n    callback: ``Callable[[Status], None]``\n        The callback to be called when the status is marked as finished.\n\n        ```python\n        def callback(status: Status) -&gt; None:\n            # Do something with the status object\n            ...\n        ```\n    \"\"\"\n    with self._lock:\n        if self.done:\n            # Call it once and do not hold a reference to it.\n            callback(self)\n        else:\n            # Hold a strong reference to this. In other contexts we tend to\n            # hold weak references to callbacks, but this is a single-shot\n            # callback, so we will hold a strong reference until we call it,\n            # and then clear this cache to drop the reference(s).\n            self._callbacks.append(callback)\n</code></pre>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.engine.RunEngine","level":2,"title":"RunEngine","text":"<p>               Bases: <code>RunEngine</code></p> <p>The Run Engine execute messages and emits Documents.</p> <p>This is a wrapper for the <code>bluesky.run_engine.RunEngine</code> class that allows execution without blocking the main thread. The main difference is that the <code>__call__</code> method is executed in a separate thread, and it returns a concurrent.futures.Future object representing the result of the plan execution.</p> <p>Parameters:</p> Name Type Description Default <code>md</code> <code>dict[str, Any]</code> <p>The default is a standard Python dictionary, but fancier objects can be used to store long-term history and persist it between sessions. The standard configuration instantiates a Run Engine with historydict.HistoryDict, a simple interface to a sqlite file. Any object supporting <code>__getitem__</code>, <code>__setitem__</code>, and <code>clear</code> will work.</p> <code>None</code> <code>loop</code> <code>AbstractEventLoop | None</code> <p>An asyncio event loop to be used for executing plans. If not provided, the RunEngine will create a new event loop using <code>asyncio.new_event_loop()</code>; e.g., <code>asyncio.get_event_loop()</code> or <code>asyncio.new_event_loop()</code></p> <code>None</code> <code>preprocessors</code> <code>list</code> <p>Generator functions that take in a plan (generator instance) and modify its messages on the way out. Suitable examples include the functions in the module <code>bluesky.plans</code> with names ending in 'wrapper'.  Functions are composed in order: the preprocessors <code>[f, g]</code> are applied like <code>f(g(plan))</code>.</p> <code>None</code> <code>md_validator</code> <code>Callable[dict[str, Any], None]</code> <p>a function that raises and prevents starting a run if it deems the metadata to be invalid or incomplete Function should raise if md is invalid. What that means is completely up to the user. The function's return value is ignored.</p> <code>None</code> <code>md_normalizer</code> <code>Callable[dict[str, Any], dict[str, Any]]</code> <p>a function that, similar to md_validator, raises and prevents starting a run if it deems the metadata to be invalid or incomplete. If it succeeds, it returns the normalized/transformed version of the original metadata. Function should raise if md is invalid. What that means is completely up to the user. Expected return: normalized metadata</p> <code>None</code> <code>scan_id_source</code> <code>Callable[dict[str, Any], int | Awaitable[int]]</code> <p>a (possibly async) function that will be used to calculate scan_id. Default is to increment scan_id by 1 each time. However you could pass in a customized function to get a scan_id from any source. Expected return: updated scan_id value</p> <code>default_scan_id_source</code> <code>call_returns_result</code> <code>bool</code> <p>A flag that controls the return value of <code>__call__</code>. If <code>True</code>, the <code>RunEngine</code> will return a :class:<code>RunEngineResult</code> object that contains information about the plan that was run. If <code>False</code>, the <code>RunEngine</code> will return a tuple of uids. The potential return value is encapsulated in the returned Future object, accessible via <code>future.result()</code>. Defaults to <code>True</code>.</p> <code>True</code> <p>Attributes:</p> Name Type Description <code>md</code> <p>Direct access to the dict-like persistent storage described above</p> <code>record_interruptions</code> <p>False by default. Set to True to generate an extra event stream that records any interruptions (pauses, suspensions).</p> <code>state</code> <p>{'idle', 'running', 'paused'}</p> <code>suspenders</code> <p>Read-only collection of <code>bluesky.suspenders.SuspenderBase</code> objects which can suspend and resume execution; see related methods.</p> <code>preprocessors</code> <code>list</code> <p>Generator functions that take in a plan (generator instance) and modify its messages on the way out. Suitable examples include the functions in the module <code>bluesky.plans</code> with names ending in 'wrapper'.  Functions are composed in order: the preprocessors <code>[f, g]</code> are applied like <code>f(g(plan))</code>.</p> <code>msg_hook</code> <p>Callable that receives all messages before they are processed (useful for logging or other development purposes); expected signature is <code>f(msg)</code> where <code>msg</code> is a <code>bluesky.Msg</code>, a kind of namedtuple; default is None.</p> <code>state_hook</code> <p>Callable with signature <code>f(new_state, old_state)</code> that will be called whenever the RunEngine's state attribute is updated; default is None</p> <code>waiting_hook</code> <p>Callable with signature <code>f(status_object)</code> that will be called whenever the RunEngine is waiting for long-running commands (trigger, set, kickoff, complete) to complete. This hook is useful to incorporate a progress bar.</p> <code>ignore_callback_exceptions</code> <p>Boolean, False by default.</p> <code>call_returns_result</code> <p>Boolean, False by default. If False, RunEngine will return uuid list after running a plan. If True, RunEngine will return a RunEngineResult object that contains the plan result, error status, and uuid list.</p> <code>loop</code> <code>asyncio event loop</code> <p>e.g., <code>asyncio.get_event_loop()</code> or <code>asyncio.new_event_loop()</code></p> <code>max_depth</code> <p>Maximum stack depth; set this to prevent users from calling the RunEngine inside a function (which can result in unexpected behavior and breaks introspection tools). Default is None. For built-in Python interpreter, set to 2. For IPython, set to 11 (tested on IPython 5.1.0; other versions may vary).</p> <code>pause_msg</code> <code>str</code> <p>The message printed when a run is interrupted. This message includes instructions of changing the state of the RunEngine. It is set to <code>bluesky.run_engine.PAUSE_MSG</code> by default and can be modified based on needs.</p> <code>commands</code> <p>The list of commands available to Msg.</p> <p>Methods:</p> Name Description <code>resume</code> <p>Resume the paused plan in a separate thread.</p> Source code in <code>src/sunflare/engine/_wrapper.py</code> <pre><code>class RunEngine(BlueskyRunEngine):\n    \"\"\"The Run Engine execute messages and emits Documents.\n\n    This is a wrapper for the `bluesky.run_engine.RunEngine` class that\n    allows execution without blocking the main thread.\n    The main difference is that the ``__call__`` method\n    is executed in a separate thread,\n    and it returns a concurrent.futures.Future object\n    representing the result of the plan execution.\n\n    Parameters\n    ----------\n    md : dict[str, Any], optional\n        The default is a standard Python dictionary, but fancier\n        objects can be used to store long-term history and persist\n        it between sessions. The standard configuration\n        instantiates a Run Engine with historydict.HistoryDict, a\n        simple interface to a sqlite file. Any object supporting\n        `__getitem__`, `__setitem__`, and `clear` will work.\n\n    loop: asyncio.AbstractEventLoop, optional\n        An asyncio event loop to be used for executing plans. If not provided,\n        the RunEngine will create a new event loop using ``asyncio.new_event_loop()``;\n        e.g., ``asyncio.get_event_loop()`` or ``asyncio.new_event_loop()``\n\n    preprocessors : list, optional\n        Generator functions that take in a plan (generator instance) and\n        modify its messages on the way out. Suitable examples include\n        the functions in the module ``bluesky.plans`` with names ending in\n        'wrapper'.  Functions are composed in order: the preprocessors\n        ``[f, g]`` are applied like ``f(g(plan))``.\n\n    md_validator : Callable[dict[str, Any], None], optional\n        a function that raises and prevents starting a run if it deems\n        the metadata to be invalid or incomplete\n        Function should raise if md is invalid. What that means is\n        completely up to the user. The function's return value is\n        ignored.\n\n    md_normalizer : Callable[dict[str, Any], dict[str, Any]], optional\n        a function that, similar to md_validator, raises and prevents starting\n        a run if it deems the metadata to be invalid or incomplete.\n        If it succeeds, it returns the normalized/transformed version of\n        the original metadata.\n        Function should raise if md is invalid. What that means is\n        completely up to the user.\n        Expected return: normalized metadata\n\n    scan_id_source : Callable[dict[str, Any], int | Awaitable[int]], optional\n        a (possibly async) function that will be used to calculate scan_id.\n        Default is to increment scan_id by 1 each time. However you could pass\n        in a customized function to get a scan_id from any source.\n        Expected return: updated scan_id value\n\n    call_returns_result : bool, default True\n        A flag that controls the return value of ``__call__``.\n        If ``True``, the ``RunEngine`` will return a :class:``RunEngineResult``\n        object that contains information about the plan that was run.\n        If ``False``, the ``RunEngine`` will return a tuple of uids.\n        The potential return value is encapsulated in the returned Future object,\n        accessible via ``future.result()``.\n        Defaults to ``True``.\n\n\n    Attributes\n    ----------\n    md\n        Direct access to the dict-like persistent storage described above\n\n    record_interruptions\n        False by default. Set to True to generate an extra event stream\n        that records any interruptions (pauses, suspensions).\n\n    state\n        {'idle', 'running', 'paused'}\n\n    suspenders\n        Read-only collection of `bluesky.suspenders.SuspenderBase` objects\n        which can suspend and resume execution; see related methods.\n\n    preprocessors : list\n        Generator functions that take in a plan (generator instance) and\n        modify its messages on the way out. Suitable examples include\n        the functions in the module ``bluesky.plans`` with names ending in\n        'wrapper'.  Functions are composed in order: the preprocessors\n        ``[f, g]`` are applied like ``f(g(plan))``.\n\n    msg_hook\n        Callable that receives all messages before they are processed\n        (useful for logging or other development purposes); expected\n        signature is ``f(msg)`` where ``msg`` is a ``bluesky.Msg``, a\n        kind of namedtuple; default is None.\n\n    state_hook\n        Callable with signature ``f(new_state, old_state)`` that will be\n        called whenever the RunEngine's state attribute is updated; default\n        is None\n\n    waiting_hook\n        Callable with signature ``f(status_object)`` that will be called\n        whenever the RunEngine is waiting for long-running commands\n        (trigger, set, kickoff, complete) to complete. This hook is useful to\n        incorporate a progress bar.\n\n    ignore_callback_exceptions\n        Boolean, False by default.\n\n    call_returns_result\n        Boolean, False by default. If False, RunEngine will return uuid list\n        after running a plan. If True, RunEngine will return a RunEngineResult\n        object that contains the plan result, error status, and uuid list.\n\n    loop : asyncio event loop\n        e.g., ``asyncio.get_event_loop()`` or ``asyncio.new_event_loop()``\n\n    max_depth\n        Maximum stack depth; set this to prevent users from calling the\n        RunEngine inside a function (which can result in unexpected\n        behavior and breaks introspection tools). Default is None.\n        For built-in Python interpreter, set to 2. For IPython, set to 11\n        (tested on IPython 5.1.0; other versions may vary).\n\n    pause_msg : str\n        The message printed when a run is interrupted. This message\n        includes instructions of changing the state of the RunEngine.\n        It is set to ``bluesky.run_engine.PAUSE_MSG`` by default and\n        can be modified based on needs.\n\n    commands:\n        The list of commands available to Msg.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        md: dict[str, Any] | None = None,\n        *,\n        loop: asyncio.AbstractEventLoop | None = None,\n        preprocessors: list[Preprocessor] | None = None,\n        md_validator: MDValidator | None = None,\n        md_normalizer: MDNormalizer | None = None,\n        scan_id_source: MDScanIDSource | None = default_scan_id_source,\n        call_returns_result: bool = True,\n    ):\n        # force the context_managers to be empty,\n        # otherwise the RunEngine will try to use the\n        # SignalHandler context manager\n        self._executor = ThreadPoolExecutor(max_workers=1)\n\n        super().__init__(\n            md=md,\n            loop=loop,\n            preprocessors=preprocessors,\n            md_validator=md_validator,\n            md_normalizer=md_normalizer,\n            scan_id_source=scan_id_source,  # type: ignore[arg-type]\n            call_returns_result=call_returns_result,\n            context_managers=[],\n        )\n\n        # override pause message to be an empty string\n        self.pause_msg = \"\"\n\n    def __call__(  # type: ignore[override]\n        self,\n        plan: Iterable[Msg],\n        subs: Subscribers | None = None,\n        /,\n        **metadata_kw: Any,\n    ) -&gt; Future[RunEngineResult | tuple[str, ...]]:\n        \"\"\"Execute a plan.\n\n        Any keyword arguments will be interpreted as metadata and recorded with\n        any run(s) created by executing the plan. Notice that the plan\n        (required) and extra subscriptions (optional) must be given as\n        positional arguments.\n\n        Parameters\n        ----------\n        plan : typing.Iterable[`bluesky.utils.Msg`]\n            A generator or that yields ``Msg`` objects (or an iterable that\n            returns such a generator).\n        subs : `bluesky.utils.Subscribers`, optional (positional only)\n            Temporary subscriptions (a.k.a. callbacks) to be used on this run.\n            For convenience, any of the following are accepted:\n\n            * a callable, which will be subscribed to 'all'\n            * a list of callables, which again will be subscribed to 'all'\n            * a dictionary, mapping specific subscriptions to callables or\n              lists of callables; valid keys are {'all', 'start', 'stop',\n              'event', 'descriptor'}\n\n        Returns\n        -------\n        Future[RunEngineResult | tuple[str, ...]]\n            Future object representing the result of the plan execution.\n\n        The result contained in the future is either:\n        uids : tuple\n            list of uids (i.e. RunStart Document uids) of run(s)\n            if :attr:`RunEngine._call_returns_result` is ``False``\n        result : :class:`RunEngineResult`\n            if :attr:`RunEngine._call_returns_result` is ``True``\n        \"\"\"\n        return self._executor.submit(\n            super().__call__,\n            plan,\n            subs,\n            **metadata_kw,\n        )\n\n    def resume(self) -&gt; Future[RunEngineResult | tuple[str, ...]]:\n        \"\"\"Resume the paused plan in a separate thread.\n\n        If the plan has been paused, the initial\n        future returned by ``__call__`` will be set as completed.\n\n        With this method, the plan is resumed in a separate thread,\n        and a new future is returned.\n\n        Returns\n        -------\n        ``Future[RunEngineResult | tuple[str, ...]]``\n            Future object representing the result of the resumed plan.\n        \"\"\"\n        return self._executor.submit(super().resume)\n</code></pre>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.engine.RunEngine.resume","level":3,"title":"resume","text":"<pre><code>resume() -&gt; Future[RunEngineResult | tuple[str, ...]]\n</code></pre> <p>Resume the paused plan in a separate thread.</p> <p>If the plan has been paused, the initial future returned by <code>__call__</code> will be set as completed.</p> <p>With this method, the plan is resumed in a separate thread, and a new future is returned.</p> <p>Returns:</p> Type Description <code>``Future[RunEngineResult | tuple[str, ...]]``</code> <p>Future object representing the result of the resumed plan.</p> Source code in <code>src/sunflare/engine/_wrapper.py</code> <pre><code>def resume(self) -&gt; Future[RunEngineResult | tuple[str, ...]]:\n    \"\"\"Resume the paused plan in a separate thread.\n\n    If the plan has been paused, the initial\n    future returned by ``__call__`` will be set as completed.\n\n    With this method, the plan is resumed in a separate thread,\n    and a new future is returned.\n\n    Returns\n    -------\n    ``Future[RunEngineResult | tuple[str, ...]]``\n        Future object representing the result of the resumed plan.\n    \"\"\"\n    return self._executor.submit(super().resume)\n</code></pre>","path":["Reference","API reference"],"tags":[]},{"location":"reference/changelog/","level":1,"title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p> <p>Dates are specified in the format <code>DD-MM-YYYY</code>.</p>","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#091-19-02-2026","level":2,"title":"0.9.1 - 19-02-2026","text":"","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#changed","level":3,"title":"Changed","text":"<ul> <li>Moved <code>ViewPositionTypes</code> (renamed to <code>ViewPosition</code>) from app layer to <code>sunflare.view</code></li> </ul>","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#added","level":3,"title":"Added","text":"<ul> <li>Added smoke tests for view layer</li> </ul>","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#fixed","level":3,"title":"Fixed","text":"<ul> <li>Updated changelog format with missing fields of Keep a Changelog</li> </ul>","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#090-16-02-2026","level":2,"title":"0.9.0 - 16-02-2026","text":"","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#changed_1","level":3,"title":"Changed","text":"<ul> <li>Fully reworked the package to remove the need of <code>config.py</code></li> <li>Renamed <code>Model</code> to <code>Device</code> for more idiomatic representation of said layer</li> <li>All objects of all layers are now meant to be created using keyword-arguments parameters</li> <li>Exception to these are the <code>name</code> and <code>virtual_bus</code> keyword<ul> <li><code>name</code> is used to uniquely identify each device</li> <li><code>virtual_bus</code> is provided to the <code>Presenter</code> and <code>View</code> layers when a container is built</li> </ul> </li> <li>Switch documentation to use <code>zensical</code></li> </ul>","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#080-21-12-2025","level":2,"title":"0.8.0 - 21-12-2025","text":"","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#removed","level":3,"title":"Removed","text":"<ul> <li>Removed the overall dependency on <code>pyzmq</code> and <code>msgspec</code>:</li> <li>The original idea was to create a local network of document dispatch via the <code>inproc</code> protocol.</li> <li>This idea is now discarded and will be reworked in favor of a more consistent approach using multiple processes     controlled centrally by the application.</li> </ul>","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#changed_2","level":3,"title":"Changed","text":"<ul> <li>Expose signals registered to the <code>VirtualBus</code> through the <code>signals</code> property.</li> </ul>","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#added_1","level":3,"title":"Added","text":"<ul> <li>Add the ability to register callbacks in the <code>VirtualBus</code> for other components to retrieve (primarely other run engines).</li> <li>Expose callbacks via the <code>callbacks</code> property.</li> </ul>","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#070-15-12-2025","level":2,"title":"0.7.0 - 15-12-2025","text":"","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#changed_3","level":3,"title":"Changed","text":"<ul> <li>Remove <code>__init__</code> from common protocols</li> <li>Make parameters of <code>__init__</code> as read-write protocol attributes</li> <li>Rename all protocols to make them shorter</li> <li>Remove the socket implementation from the RunEngine</li> <li>Unused and not accurate feature</li> </ul>","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#063-14-12-2025","level":2,"title":"0.6.3 - 14-12-2025","text":"","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#added_2","level":3,"title":"Added","text":"<ul> <li>Add appropriate <code>resume</code> method to the <code>RunEngine</code> wrapper</li> <li>Ensure that it does not block the main thread</li> <li>Requires better documentation</li> </ul>","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#062-06-10-2025","level":2,"title":"0.6.2 - 06-10-2025","text":"","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#changed_4","level":3,"title":"Changed","text":"<ul> <li>Synchronize all dependencies correctly via <code>uv</code></li> <li>Bump <code>bluesky</code> version to <code>1.14.5</code></li> <li>Fix type hints accordingly</li> <li>Trigger CI for docs deployment and PyPI publishing from GitHub release page</li> <li>Previously new tag had to be manually pushed from CLI</li> <li>Add support for Python 3.13</li> <li>Add <code>noxfile.py</code> to run tests via <code>nox</code> for multiple Python versions locally</li> </ul>","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#061-04-07-2025","level":2,"title":"0.6.1 - 04-07-2025","text":"","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#fixed_1","level":3,"title":"Fixed","text":"<ul> <li>Inject <code>ViewInfoProtocol</code> and not the base class in the view base classes</li> </ul>","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#060-04-07-2025","level":2,"title":"0.6.0 - 04-07-2025","text":"","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#added_3","level":3,"title":"Added","text":"<ul> <li>Added <code>sunflare.containers</code> module for dynamically registering protocols and plans</li> <li>Provided 4 functions<ul> <li><code>register/get_plans</code></li> <li><code>register/get_protocols</code></li> </ul> </li> <li>Plan signatures are unwrapped within <code>PlanSignature</code> dataclass object<ul> <li>The signatures can be retrieved via <code>get_signatures</code></li> </ul> </li> <li>Registered plans must be type annotated to be correctly registered and used by other plugins</li> <li>Added initial testing</li> </ul>","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#changed_5","level":3,"title":"Changed","text":"<ul> <li>Dropped support for 3.9</li> <li>Removed usage of <code>Optional</code> and <code>Union</code></li> <li>Replaced with built-in <code>|</code> instead</li> <li>Switch to <code>uv</code> for dependency management</li> <li>Added <code>uv.lock</code> file</li> <li>Removed <code>engine</code> field from <code>RedsunSessionInfo</code></li> <li>Not really meaningful, was part of old concept</li> <li>Renamed <code>Widget</code> components to <code>View</code></li> <li>Ex-<code>Widget</code> classes are now injected with <code>ViewInfo</code> in initializer rather than <code>RedSunSessionInfo</code></li> </ul>","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#055-02-04-2025","level":2,"title":"0.5.5 - 02-04-2025","text":"","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#fixed_2","level":3,"title":"Fixed","text":"<ul> <li>catch exception when <code>RunEngine.stop()</code> is called from main thread</li> </ul>","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#054-31-03-2025","level":2,"title":"0.5.4 - 31-03-2025","text":"","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#fixed_3","level":3,"title":"Fixed","text":"<ul> <li>fixed <code>msgspec</code> decoding hook</li> <li>now returns the object when it's not of type <code>np.ndarray</code></li> <li>fixed <code>RunEngine</code> document emission</li> <li><code>emit</code> was failing to parse the document name</li> </ul>","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#053-25-03-2025","level":2,"title":"0.5.3 - 25-03-2025","text":"","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#changed_6","level":3,"title":"Changed","text":"<ul> <li>Reworked <code>log.py</code></li> <li>When calling <code>obj.debug</code>, the line where the call was emitted redirected to <code>Loggable</code></li> <li>using a <code>logging.LoggerAdapter</code> prevents this</li> <li>it also make the usage of <code>Loggable</code> more consistent by simply returning a <code>cached_property</code>, which now enforces usage of <code>obj.logger.debug</code> which is less confusing</li> </ul>","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#052-13-03-2025","level":2,"title":"0.5.2 - 13-03-2025","text":"","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#changed_7","level":3,"title":"Changed","text":"<ul> <li>Enhanced <code>sunflare.log</code> in order to separate log calls between two handlers.</li> </ul>","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#051-06-03-2025","level":2,"title":"0.5.1 - 06-03-2025","text":"","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#changed_8","level":3,"title":"Changed","text":"<ul> <li>Dropped upper bound limit for <code>numpy</code> dependency</li> </ul>","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#050-03-03-2025","level":2,"title":"0.5.0 - 03-03-2025","text":"","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#changed_9","level":3,"title":"Changed","text":"<ul> <li>Rearranged the structure of virtual-related classes</li> <li>Everything related to creating connections with the virtual bus have been brought to the <code>sunflare.virtual</code> module</li> <li>Set the default log level to <code>INFO</code> (was <code>DEBUG</code> before)</li> <li>Reworked <code>sunflare.config</code> to accomodate for new plugin system</li> </ul>","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#added_4","level":3,"title":"Added","text":"<ul> <li>Added a <code>Model</code> base class for quicker development.</li> </ul>","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#removed_1","level":3,"title":"Removed","text":"<ul> <li><code>configure</code> protocol is not part of the <code>ModelProtocol</code> anymore; see this PR</li> </ul>","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#042-24-02-2025","level":2,"title":"0.4.2 - 24-02-2025","text":"","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#changed_10","level":3,"title":"Changed","text":"<ul> <li>Changed <code>ModelProtocol.configure</code> signature</li> <li>Previous signature was not consistent with the command issued by the <code>RunEngine</code></li> </ul>","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#041-23-02-2025","level":2,"title":"0.4.1 - 23-02-2025","text":"","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#added_5","level":3,"title":"Added","text":"<ul> <li>Added support for <code>Mapping</code> types (i.e. <code>dict</code>) in <code>ModelInfo</code> methods (<code>read/describe_configuration</code>)</li> <li>Added optional parameters for <code>read/describe_configuration</code></li> <li><code>read_configuration</code>: <code>timestamp</code> (i.e. use <code>time.time()</code> for a timestamp of the last reading time)</li> <li><code>describe_configuration</code>: <code>source</code>, to specify the source of the configuration parameter</li> </ul>","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#040-22-02-2025","level":2,"title":"0.4.0 - 22-02-2025","text":"","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#added_6","level":3,"title":"Added","text":"<ul> <li>Implemented support for ZMQ messaging via <code>pyzmq</code></li> <li>Added initial support for <code>msgspec</code></li> <li>Added mixin classes for creating publisher/subscribers</li> <li>Added mixin classes for <code>Signal</code>-enabled controllers</li> <li>Added more documentation for the virtual module</li> <li>Reorganized code in different modules to avoid circular imports</li> <li>Split controller in different protocols</li> <li>Added <code>ModelInfoProtocol</code> to deploy models from packages that don't have a strict dependency with Sunflare</li> <li>Added more tests, both for existing and new code</li> </ul>","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#035-11-02-2025","level":2,"title":"0.3.5 - 11-02-2025","text":"","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#added_7","level":3,"title":"Added","text":"<ul> <li>Added protocol equivalent for <code>ModelInfo</code></li> <li>Currently untested</li> <li>This can be used in combination with <code>ModelProtocol</code> to define a Model interface from an external package without direct dependency to the <code>sunflare</code> package.</li> <li>Added documentation for <code>Controller</code></li> <li>Added tests for <code>RunEngine</code> wrapper</li> </ul>","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#changed_11","level":3,"title":"Changed","text":"<ul> <li>Minor docstring and renaming fixes</li> <li><code>engine</code> and <code>frontend</code> fields of <code>RedSunSessionInfo</code> are not optional anymore</li> </ul>","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#fixed_4","level":3,"title":"Fixed","text":"<ul> <li><code>RunEngine.__call__</code> fails in Python 3.9 unless explictly setting the event loop in the executor</li> </ul>","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#034-05-02-2025","level":2,"title":"0.3.4 - 05-02-2025","text":"","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#fixed_5","level":3,"title":"Fixed","text":"<ul> <li>Fixed bug in <code>RedSunSessionInfo.store_yaml</code> which was not correctly parsing <code>Enum</code> and <code>tuple</code> types</li> </ul>","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#033-04-02-2025","level":2,"title":"0.3.3 - 04-02-2025","text":"","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#changed_12","level":3,"title":"Changed","text":"<ul> <li>Minor renaming</li> <li>RedSun -&gt; Redsun</li> <li>SunFlare -&gt; Sunflare</li> </ul>","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#added_8","level":3,"title":"Added","text":"<ul> <li>Added documentation</li> <li>Notions of O.O.P.</li> <li>Minimal model doc</li> <li>Added test for VirtualBus connection mechanism</li> <li>Added <code>WidgetInfo</code> class</li> <li>Provides information for widgets</li> <li>Redsun uses it to correctly allocate dock widgets in the main view</li> <li>Currently adapted to be used with <code>PyQt</code> and <code>PySide</code><ul> <li>For web-based frameworks may require adjustments somehow</li> </ul> </li> <li>Added <code>RedSunSessionInfo.store_yaml</code> to save the configuration file elsewhere</li> <li>We could think of supporting dynamic plugin loading; this would mean changing the content of <code>RedSunSessionInfo</code> on the fly.</li> </ul>","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#032-29-01-2025","level":2,"title":"0.3.2 - 29-01-2025","text":"","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#added_9","level":3,"title":"Added","text":"<ul> <li><code>session</code> field in <code>RedSunSessionInfo</code></li> <li>used as main window title and as bluesky metadata</li> <li>added <code>**kwargs</code> to <code>configure</code> method</li> <li>need investigation on how to actually use it</li> <li>added optional <code>shutdown</code> method in <code>ModelProtocol</code></li> <li>it still must be implemented although not mandatory</li> </ul>","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#removed_2","level":3,"title":"Removed","text":"<ul> <li>removed built-in protocols <code>Detector</code> and <code>Motor</code></li> <li>each plugin should take care of deciding what they are</li> </ul>","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#changed_13","level":3,"title":"Changed","text":"<ul> <li>fixed metaclass error in <code>BaseQtWidget</code></li> </ul>","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#031-27-01-2025","level":2,"title":"0.3.1 - 27-01-2025","text":"","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#added_10","level":3,"title":"Added","text":"<ul> <li>Added parts of <code>Configurable</code> protocol in <code>ModelInfo</code> for easier handling</li> </ul>","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#030-27-01-2025","level":2,"title":"0.3.0 - 27-01-2025","text":"","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#changed_14","level":3,"title":"Changed","text":"<ul> <li>Refactor: simplify <code>virtual</code> module and remove <code>EngineHandler</code></li> <li>Use <code>typing_extensions.Protocol</code> in case of <code>Python &lt; 3.11</code></li> </ul>","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#added_11","level":3,"title":"Added","text":"<ul> <li>Added a wrapper of <code>RunEngine</code> which leaves the main thread unblocked</li> </ul>","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#022-02-01-2025","level":2,"title":"0.2.2 - 02-01-2025","text":"","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#changed_15","level":3,"title":"Changed","text":"<ul> <li>Correct engine handler API.</li> <li>Update CI action versions.</li> </ul>","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#021-02-01-2025","level":2,"title":"0.2.1 - 02-01-2025","text":"","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#changed_16","level":3,"title":"Changed","text":"<ul> <li>Engine handler now stores plans as dictionary of dictionaries.</li> <li>The key of the main dictionary is the controller name which holds the plans;</li> <li>The values are dictionaries:<ul> <li>Keys are the plan names;</li> <li>Values are plans built with <code>functools.partial</code></li> </ul> </li> </ul>","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#020-31-12-2024","level":2,"title":"0.2.0 - 31-12-2024","text":"","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#added_12","level":3,"title":"Added","text":"<ul> <li>Change configuration classes to use attrs in https://github.com/redsun-acquisition/sunflare/pull/8</li> <li>Model API rework in https://github.com/redsun-acquisition/sunflare/pull/9</li> </ul>","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#011-26-12-2024","level":2,"title":"0.1.1 - 26-12-2024","text":"<ul> <li>Same changes as [v0.1.1a1]</li> <li>Some typo adjustments</li> </ul>","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#011a1-25-12-2024","level":2,"title":"0.1.1a1 - 25-12-2024","text":"<p>(Only available on TestPyPI)</p>","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#added_13","level":3,"title":"Added","text":"<ul> <li>Rework handler by @jacopoabramo in #6</li> <li>Reworked a lot of logic</li> <li>Models are now subclassed in Models for easier type hinting management</li> <li>Using RedSunInstanceInfo in handler</li> <li>RedSunInstance info now holds logic to load and check yaml file as static method</li> </ul>","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#010-23-12-2024","level":2,"title":"0.1.0 - 23-12-2024","text":"","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#added_14","level":3,"title":"Added","text":"<ul> <li>First release on PyPI;</li> <li>Reached above 90% coverage;</li> </ul>","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#010a1-22-12-2024","level":2,"title":"0.1.0a1 - 22-12-2024","text":"<p>(Only available on TestPyPI)</p>","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#added_15","level":3,"title":"Added","text":"<ul> <li>Alpha release;</li> <li>Basic project infrastructure;</li> </ul>","path":["Reference","Changelog"],"tags":[]},{"location":"tutorials/","level":1,"title":"Tutorials","text":"<ul> <li>OOP Crash Course</li> </ul>","path":["Tutorials"],"tags":[]},{"location":"tutorials/oop-crash-course/","level":1,"title":"O.O.P. crash course","text":"<p>This sections offers a very quick crash course in commonly used programming patterns in the object-oriented programming paradigm.</p> <p>Python is a multi-paradigm language (meaning that it leverages OOP but also other paradigms), but the Redsun ecosystem mostly focuses on this paradigm.</p> <p>We will use Unified Modeling Language (UML) diagrams made with mermaid for visual representation of these patterns.</p>","path":["Tutorials","Oop crash course","O.O.P. crash course"],"tags":[]},{"location":"tutorials/oop-crash-course/inheritance/","level":1,"title":"Inheritance","text":"<p>Inheritance is a mechanism of basing a class on the implementation of another class. The original class is often referred to as a parent, the class that implements the original is often referred to as a child class.</p> <p>In Python, parent classes can provide abstract methods, functions without actual executable code but instead serving as a customizable template.</p> <pre><code>classDiagram\n    class Animal{\n        +int paws\n        fly()*void\n        talk()*void\n        how_many_paws() int\n    }\n    class Duck {\n        fly() void\n        talk() void\n    }\n\n    Animal &lt;|-- Duck : inherits from\n    note for Animal \"Duck inherits from Animal\"</code></pre> <p>The diagram shows an example this: <code>Animal</code> provides an interface with both abstract and normal methods, while <code>Duck</code> provides an implementation for the abstract methods. In Python, this would be equivalent to:</p> <pre><code>from abc import ABC, abstractmethod\n\nclass Animal(ABC):\n    paws: int\n\n    @abstractmethod\n    def fly(self):\n        ...\n    @abstractmethod\n    def talk(self):\n        ...\n\n    def how_many_paws(self):\n        print(\"I have\", self.paws, \"paws\")\n\nclass Duck(Animal):\n    def __init__():\n        self.paws = 2\n\n    def fly(self):\n        print(\"Flying!\")\n    def talk(self):\n        print(\"Quack!\")\n\nanimal = Duck(2)\nduck.fly() # prints \"Flying!\"\nduck.talk() # prints \"Quack!\"\nduck.how_many_paws() # prints \"I have 2 paws\"\n</code></pre> <p>It's an effective pattern which allows to reuse the same code and extend it depending on the need.</p> <p>But sometimes it may become an hinderance. If we want to create a <code>Cat</code> class instead ...</p> <pre><code>class Cat(Animal):\n    def __init__(self):\n        self.paws = 4\n\n    # cats can't fly,\n    # they can only talk\n    def talk(self):\n        print(\"Meow!\")\n\ncat = Cat()\n# the line above causes an exception:\n# TypeError: Can't instantiate abstract class Cat with abstract method fly\n</code></pre> <p>... we get an error! Of course, we could just implement <code>fly()</code> and simply print <code>I can't fly</code>, but a real situation that method may be doing a computation or performing another action which is inconsistent with the defined base class <code>Animal</code>.</p>","path":["Tutorials","Oop crash course","Inheritance"],"tags":[]}]}
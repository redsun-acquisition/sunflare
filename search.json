{"config":{"separator":"[\\s\\-_,:!=\\[\\]()\\\\\"`/]+|\\.(?!\\d)"},"items":[{"location":"","level":1,"title":"<code>sunflare</code>","text":"<p>Warning</p> <p>This project is currently under active development and it may (and most likely will) receive breaking changes. Use at your own risk.</p> <p><code>sunflare</code> is a software development kit (SDK) which provides common, reusable components for building plugins which can interact with <code>redsun</code>.</p> <p>The aim is to provide reusable patterns in developing software applications for scientific device orchestration leveraging the Bluesky hardware interface and data model.</p> <ul> <li> <p>Tutorials</p> <p>Learn Sunflare from the ground up with step-by-step lessons.</p> <p>Start learning </p> </li> <li> <p>How-to guides</p> <p>Practical guides for common tasks and problems.</p> <p>Browse guides </p> </li> <li> <p>Reference</p> <p>Technical documentation and API reference.</p> <p>View reference </p> </li> <li> <p>Explanations</p> <p>Understand the concepts and design behind Sunflare</p> <p>Read explanations </p> </li> </ul>","path":["sunflare"],"tags":[]},{"location":"#about-the-documentation","level":2,"title":"About the documentation","text":"<p>This documentation follows the Diátaxis framework, organizing content into four distinct categories based on your needs:</p> <ul> <li>Tutorials are learning-oriented lessons.</li> <li>How-to guides are task-oriented recipes.</li> <li>Reference is information-oriented technical descriptions.</li> <li>Explanations is understanding-oriented discussions.</li> </ul>","path":["sunflare"],"tags":[]},{"location":"#project-links","level":2,"title":"Project links","text":"<ul> <li>GitHub repository</li> <li>PyPI package</li> <li>Redsun framework</li> </ul>","path":["sunflare"],"tags":[]},{"location":"explanations/","level":1,"title":"Explanations","text":"<ul> <li>Statement of Need</li> </ul>","path":["Explanations"],"tags":[]},{"location":"explanations/#architectural-design","level":2,"title":"Architectural design","text":"<ul> <li>Devices</li> <li>Presenters</li> <li>Virtual container</li> </ul>","path":["Explanations"],"tags":[]},{"location":"explanations/statement/","level":1,"title":"Statement of need","text":"<p>The goal of <code>sunflare</code> is to provide shared and recognizable programming patterns accross the entire <code>redsun</code> ecosystem. <code>redsun</code> heavily leverages the concept of components, and there is a need to provide a clear representation and a shared communication channel between the plugins that in the end build the desired application.</p> Framework structure <pre><code>graph LR\n    sunflare --&gt;|builds| components\n    sunflare --&gt;|builds| redsun\n    components --&gt;|used in| redsun</code></pre> <p>The diagram shows the relationship between <code>redsun</code>, <code>sunflare</code> and the custom components. Effectively, <code>redsun</code> is nothing more than \"glue\" code that constructs your custom application. What it does is:</p> <ul> <li>retrieve the user components via Python entry points;</li> <li>build these components and catch any possible exception throw by them;</li> <li>build the final application and connecting all the components together.</li> </ul> <p>This approach ensures that <code>sunflare</code> can be reused as a standalone package to provide reusable code to create custom control interfaces for your device, which fit the <code>bluesky</code> message protocol and data model.</p> <p>Furthermore, if you have an existing package for hardware control, <code>sunflare</code> can be used to create a wrapper for your classes which can then \"talk\" the <code>bluesky</code> language.</p>","path":["Explanations","Statement of need"],"tags":[]},{"location":"explanations/architecture/devices/","level":1,"title":"Devices","text":"<p>A <code>Device</code> class represents an interface with a hardware device.</p> <p>The definition of a device is quite fluid, as there are many ways that it can interact with the hardware depending on your needs.</p> <p>All devices must inherit from the <code>Device</code> base class, either:</p> <ul> <li>directly, via inheritance;</li> <li>indirectly, following structural subtyping (PEP 544) via the <code>PDevice</code> protocol.</li> </ul> <p>Each device requires a positional-only argument <code>name</code> that serves as a unique identifier for a <code>redsun</code> session; additional initialization parameters can be provided as keyword-only arguments.</p> <pre><code>from sunflare.device import Device\n\nclass MyDevice(Device)\n\n    def __init__(self, name: str, /, int_param: int, str_param: str) -&gt; None:\n        ... # your implementation\n</code></pre>","path":["Explanations","Architecture","Devices"],"tags":[]},{"location":"explanations/architecture/devices/#see-also","level":2,"title":"See Also","text":"<ul> <li>In-process devices</li> </ul>","path":["Explanations","Architecture","Devices"],"tags":[]},{"location":"explanations/architecture/in-process-device/","level":1,"title":"In-process devices","text":"<p>In-process devices provide interaction with the device API in the same process:</p> <ul> <li>by importing the API as a Python package and use it as a local object: API via aggregation;</li> <li>by inheriting from an existing class that encapsulates the commands of your device: API via inheritance.</li> </ul>","path":["Explanations","Architecture","In-process devices"],"tags":[]},{"location":"explanations/architecture/in-process-device/#api-via-aggregation","level":2,"title":"API via aggregation","text":"<p>\"Aggregation\" means when an object is constructed inside a class.</p> <p>In this usage, a standard device is simply a wrapper around the actual device interface you want to control.</p> <p>The wrapped interface is often referred to as <code>handler</code>, although it varies depending on implementation details. The external application should not interact directly with the <code>handler</code> object; instead, the Device wrapping it should take care of calling the appropriate methods of the <code>handler</code> to perform the required tasks.</p> <p>Tip</p> <p>It is good practice to mark your handler object via a double underscore <code>__</code>, i.e. <code>__handler</code>, symbolizing that this is a private attribute (meaning that only your Device object can use it internally and it is not accessible from the outside). In truth, Python does not really enforce private attributes - meaning that there are ways to circumvent the privacy - but it is considered standard practice to annotate them in this manner.</p> UMLPython <pre><code>classDiagram\n    class MyDevice {\n        -DeviceHandler __handler\n        +str name\n        +None parent\n        configure() None\n        read_configuration() dict[str, Reading]\n        describe_configuration() dict[str, DataKey]\n    }\n    class DeviceHandler {\n        +int param1\n        +float param2\n        device_method() void\n    }\n\n    MyDevice *-- DeviceHandler</code></pre> my_plugin/device.py<pre><code>from sunflare.device import Device\nfrom device_package import DeviceHandler\nfrom bluesky.protocols import Reading, Descriptor\n\nclass MyDevice(Device):\n    def __init__(self, name: str, /, **kwargs) -&gt; None:\n        super().__init__(name, /, **kwargs)\n\n        # unpack the parameters you need\n        # to initialize DeviceHandler,\n        # or provide them hard-coded\n        param1 = kwargs.get(\"param1\", 0)\n        param2 = kwargs.get(\"param2\", 0.0)\n        self.__handler = DeviceHandler(int_param=param1, float_param=param2, bool_param=True)\n\n    def configure(self) -&gt; None:\n        # here goes your implementation;\n        self.__handler.configure()\n\n    def read_configuration(self) -&gt; dict[str, Reading]:\n        # here goes your implementation;\n        return self.__handler.read_configuration()\n\n    def describe_configuration(self) -&gt; dict[str, Descriptor]:\n        # here goes your implementation;\n        return self.__handler.describe_configuration()\n</code></pre> <p>Furthermore, a single Device can encapsulate multiple handlers, each of them with different functionalities. Keep in mind that it is your responsability (as developer) to associate the execution of Bluesky messages with the appropriate device handler.</p> my_plugin/device.py<pre><code># a dummy representation of a plugin package that encapsulates\n# a Device wrapping controls for a camera and a motor\nfrom sunflare.device import Device\nfrom device_package import CameraHandler, MotorHandler\n\nclass MyDevice(Device):\n    def __init__(self, name: str, /, **kwargs) -&gt; None:\n        super().__init__(name, **kwargs)\n\n        self.__motor_handler = MotorHandler(**kwargs.get(\"motor_parameters\", {}))\n        self.__camera_handler = CameraHandler(**kwargs.get(\"camera_parameters\", {}))\n</code></pre>","path":["Explanations","Architecture","In-process devices"],"tags":[]},{"location":"explanations/architecture/in-process-device/#api-via-inheritance","level":2,"title":"API via inheritance","text":"<p>Using aggregation to control your device interface may be impractical if <code>DeviceHandler</code> already leverages a lot of internal code. Inheriting your Device from a pre-existing class gives the benefit of reusing it without having to rewrite any of the internals.</p> UMLPython <pre><code>classDiagram\n    class MyDevice {\n        +str name\n        +None parent\n        configure() None\n        read_configuration() dict[str, Reading]\n        describe_configuration() dict[str, DataKey]\n    }\n    class DeviceHandler {\n        device_method() void\n    }\n\n    MyDevice &lt;|-- DeviceHandler</code></pre> my_plugin/device.py<pre><code>from sunflare.device import Device\nfrom device_package import DeviceHandler\nfrom bluesky.protocols import Reading, Descriptor\n\nclass MyDevice(Device, DeviceHandler):\n    def __init__(self, name: str, /, **kwargs) -&gt; None:\n        super().__init__(name, **kwargs)\n\n    def configure(self) -&gt; None:\n        # here goes your implementation;\n        super().configure()\n\n    def read_configuration(self) -&gt; dict[str, Reading]:\n        # get the current configuration values\n        config = super().get_settings_values()\n\n        # whatever output is returned, it must\n        # be converted to a dictionary of readings\n\n        return super().describe_configuration()\n\n    def describe_configuration(self) -&gt; dict[str, Descriptor]:\n        # first get whatever description your device provides\n        config = super().get_settings_description()\n\n        # whatever output is returned, it must\n        # be converted to be a dictionary of descriptors\n        reading = convert_to_reading(config) # your implementation\n\n        return reading\n</code></pre> <p>Just like in the aggregated API, your device can also inherit from multiple classes. Again, it is your responsibility (as developer) to ensure that the appropriate Bluesky protocols are invoked on the correct device.</p> my_plugin/device.py<pre><code># a dummy representation of a plugin package that encapsulates\n# a Device wrapping controls for a camera and a motor\nfrom sunflare.device import Device\nfrom device_package import CameraHandler, MotorHandler\n\nclass MyDevice(Device, CameraHandler, MotorHandler):\n    def __init__(self, name: str, **kwargs) -&gt; None:\n        super().__init__(name, **kwargs)\n</code></pre>","path":["Explanations","Architecture","In-process devices"],"tags":[]},{"location":"explanations/architecture/in-process-device/#key-differences","level":2,"title":"Key differences","text":"<p>Although they may initially look similar, there are key differences and advantages in each approach.</p> <p>Aggregation is useful... - ... when you want to have a more fine-grained control over your device; - ... when your device interface doesn't have an actual class encapsulating methods and parameters but instead uses a different programming paradigm; - ... when you don't want to expose certain behaviors of your device to the end-user (a.k.a. inhibiting the possibility to call public methods); - ... when your device interface is built using another language (C++, Rust, ...) and you want to keep a minimal level of abstraction between the device and the handler; - ... when your handler actually controls the interaction with multiple devices topology and you want to expose only a sub-set of those functionalities.</p> <p>An example candidate for aggregation is the [<code>pymmcore-plus</code>] package, which wraps the controls of multiple Micro-Manager devices behind the [<code>CMMCorePlus</code>] interface and provides additional functionalities (such as the [<code>MDAEngine</code>]).</p> <p>Inheritance is useful... - ... when your device has a lot of code and you want to quickly wrap it to be Bluesky-compatible; - ... when it provides extra functionalities that allow to work with remote devices by default; - ... when it is already a Bluesky-compatible device and you just want to make it as a plugin for Redsun.</p> <p>Example candidates for inheritance are the [<code>microscope</code>] and [<code>openwfs</code>] packages, as they provide pre-configured interfaces that can be extended with additional Bluesky methods.</p>","path":["Explanations","Architecture","In-process devices"],"tags":[]},{"location":"explanations/architecture/presenters/","level":1,"title":"Presenters","text":"<p><code>Presenters</code> represent the execution logic of your system.</p> <p>Where <code>Devices</code> are \"workers\" (as they instruct your device to perform a certain task), <code>Presenters</code> can be \"orchestrators\", in the sense that they define the sequence of actions that workers must perform through Bluesky plans.</p> <p>We highlight \"can be\" because <code>Presenters</code> are not limited to that:</p> <ul> <li>they can consume Bluesky documents for on-the-fly processing, intermediate storage or redirection to a GUI (i.e. computing the FFT of an image and sending it to the GUI for display);</li> <li>they can provide manual control for device task execution and/or configuration;</li> <li>in comparison to plans (which represents an experimental procedure), one may wish to - for example - manually move a motor stage from the GUI, or change the exposure time of a camera; the <code>Presenter</code> in this case acts as a middle-man between the GUI and the device, directly calling Bluesky methods and bypassing the <code>RunEngine</code>;</li> <li>they can act as communication points with external applications to trigger actions via a custom communication protocol (or wait for possible commands incoming by said applications).</li> </ul> <p><code>Presenters</code> are meant to communicate between each other via the <code>VirtualBus</code>, which takes care of redirecting information (commands and/or documents) to the appropriate destination (whether it is another <code>Presenter</code> or a <code>View</code>).</p> <p>All presenters must implement the <code>PPresenter</code> interface to be recognized by Redsun.</p> <p>The <code>PPresenter</code> requires two things in its initialization:</p> <ul> <li>a <code>name</code> which to be used as a unique identifier for the <code>Presenter</code> object</li> <li>a <code>Mapping[str, Device]</code> of the allocated devices in the session;</li> </ul> <p>Additional parameters can be passed via keyword arguments, which are parsed from the session configuration file.</p>","path":["Explanations","Architecture","Presenters"],"tags":[]},{"location":"explanations/architecture/storage/","level":1,"title":"Storage","text":"<p>Design inspiration</p> <p>The storage architecture described here is heavily inspired by ophyd-async, developed by the Bluesky collaboration. The patterns — shared writer, path providers, <code>FrameSink</code>, <code>StorageProxy</code> protocol — were adapted to fit the sunflare/redsun container model.</p> <p>The <code>sunflare.storage</code> subpackage provides the infrastructure for writing detector frames to a persistent store. The design follows a small set of principles:</p> <ul> <li>One shared writer per session — all devices write to the same store; each device owns its own array key within it.</li> <li>Storage is opt-in per device — devices that need storage declare a <code>StorageDescriptor</code> field; the base <code>Device</code> class carries no storage attribute.</li> <li>The container injects the writer — devices never construct or look up a writer themselves; the application container builds one writer and injects it into every opted-in device at session start.</li> <li>Backend classes are internal — only the abstract <code>Writer</code> and the <code>StorageProxy</code> protocol are public; concrete backends (e.g. <code>ZarrWriter</code>) are selected and instantiated by the container from the session configuration.</li> <li>Backend dependencies are optional extras — <code>acquire-zarr</code> is not a core dependency of sunflare. Install <code>sunflare[zarr]</code> to enable the Zarr backend.</li> </ul>","path":["Explanations","Architecture","Storage"],"tags":[]},{"location":"explanations/architecture/storage/#opting-in-to-storage","level":2,"title":"Opting in to storage","text":"<p>A device signals that it needs storage by declaring a class-level <code>StorageDescriptor</code>:</p> <pre><code>import numpy as np\nfrom sunflare.device import Device\nfrom sunflare.storage import StorageDescriptor\n\n\nclass MyDetector(Device):\n    storage = StorageDescriptor()\n\n    def __init__(self, name: str, /) -&gt; None:\n        super().__init__(name)\n\n    def prepare(self, capacity: int) -&gt; None:\n        if self.storage is None:\n            raise RuntimeError(\"No storage backend configured for this session.\")\n        self.storage.update_source(\n            self.name,\n            dtype=np.dtype(\"uint16\"),\n            shape=(512, 512),\n        )\n        self._sink = self.storage.prepare(self.name, capacity=capacity)\n</code></pre> <p>The descriptor initialises to <code>None</code>; the container sets it to the shared writer before any acquisition begins. Device code checks <code>self.storage is None</code> to handle sessions that have no storage configured.</p>","path":["Explanations","Architecture","Storage"],"tags":[]},{"location":"explanations/architecture/storage/#acquisition-lifecycle","level":2,"title":"Acquisition lifecycle","text":"<p>Once the writer has been injected, a device interacts with storage through a fixed call sequence:</p> <pre><code># 1. Register the data source (dtype, shape, optional backend-specific metadata)\nself.storage.update_source(self.name, dtype=np.dtype(\"uint16\"), shape=(512, 512))\n\n# 2. Prepare for one acquisition; returns a FrameSink bound to this device\nsink = self.storage.prepare(self.name, capacity=100)\n\n# 3. Open the backend (called once, shared across all devices)\nself.storage.kickoff()\n\n# 4. Push frames — thread-safe, multiple sinks may write concurrently\nsink.write(frame)\n\n# 5. Signal completion for this device\nsink.close()\n</code></pre> <p><code>FrameSink.close</code> delegates to <code>Writer.complete</code>. The backend is finalised automatically once every active sink has been closed.</p>","path":["Explanations","Architecture","Storage"],"tags":[]},{"location":"explanations/architecture/storage/#path-providers","level":2,"title":"Path providers","text":"<p>The writer resolves store paths through a composable <code>PathProvider</code>. A <code>PathProvider</code> is a callable that accepts a device name and returns a <code>PathInfo</code> describing where and how to write that device's data.</p> <p><code>sunflare.storage</code> ships three <code>FilenameProvider</code> strategies that can be composed with <code>StaticPathProvider</code>:</p> Static filenameUUID filenameAuto-increment filename <pre><code>from sunflare.storage import StaticFilenameProvider, StaticPathProvider\n\n# Every acquisition writes to the same filename\npath_provider = StaticPathProvider(\n    StaticFilenameProvider(\"scan001\"),\n    base_uri=\"file:///data\",\n)\n# Produces: file:///data/scan001  (array key = device name)\n</code></pre> <pre><code>from sunflare.storage import UUIDFilenameProvider, StaticPathProvider\n\n# Each acquisition gets a unique UUID filename\npath_provider = StaticPathProvider(\n    UUIDFilenameProvider(),\n    base_uri=\"file:///data\",\n)\n# Produces: file:///data/3f2504e0-...  (array key = device name)\n</code></pre> <pre><code>from sunflare.storage import AutoIncrementFilenameProvider, StaticPathProvider\n\n# Filenames increment: scan_00000, scan_00001, ...\npath_provider = StaticPathProvider(\n    AutoIncrementFilenameProvider(base=\"scan\", max_digits=5),\n    base_uri=\"file:///data\",\n)\n</code></pre> <p><code>PathInfo</code> uses URIs rather than filesystem paths, so the same provider interface works for both local (<code>file://</code>) and remote (<code>s3://</code>) backends.</p>","path":["Explanations","Architecture","Storage"],"tags":[]},{"location":"explanations/architecture/storage/#the-storageproxy-protocol","level":2,"title":"The StorageProxy protocol","text":"<p>Device code never holds a reference to a concrete backend class. It interacts only through the <code>StorageProxy</code> protocol:</p> <pre><code>from sunflare.storage import StorageProxy\n\nclass StorageProxy(Protocol):\n    def update_source(self, name, dtype, shape, extra=None) -&gt; None: ...\n    def prepare(self, name, capacity=0) -&gt; FrameSink: ...\n    def kickoff(self) -&gt; None: ...\n    def complete(self, name) -&gt; None: ...\n    def get_indices_written(self, name=None) -&gt; int: ...\n    def collect_stream_docs(self, name, indices_written) -&gt; Iterator[StreamAsset]: ...\n</code></pre> <p><code>Writer</code> satisfies this protocol structurally. Future remote proxy objects will too, so device code is identical regardless of whether storage is local or remote.</p> <p>Tip</p> <p>When testing devices in isolation, pass a <code>MagicMock(spec=StorageProxy)</code> as the injected writer — no real backend is needed and all interactions are captured for assertion.</p> <pre><code>from unittest.mock import MagicMock\nfrom sunflare.storage import StorageProxy\n\ndevice = MyDetector(\"camera\")\ndevice.storage = MagicMock(spec=StorageProxy)\n\ndevice.prepare(capacity=10)\ndevice.storage.update_source.assert_called_once()\n</code></pre>","path":["Explanations","Architecture","Storage"],"tags":[]},{"location":"explanations/architecture/storage/#implementing-a-custom-backend","level":2,"title":"Implementing a custom backend","text":"<p>To add a new storage backend, subclass <code>Writer</code> and implement the four abstract members:</p> <pre><code>from sunflare.storage import Writer, FrameSink\nimport numpy.typing as npt\n\n\nclass MyWriter(Writer):\n\n    @property\n    def mimetype(self) -&gt; str:\n        return \"application/x-myformat\"\n\n    def prepare(self, name: str, capacity: int = 0) -&gt; FrameSink:\n        # backend-specific setup for this source ...\n        return super().prepare(name, capacity)  # (1)\n\n    def kickoff(self) -&gt; None:\n        if self.is_open:\n            return\n        # open your backend here ...\n        super().kickoff()  # (2)\n\n    def _write_frame(self, name: str, frame: npt.NDArray) -&gt; None:\n        # write one frame to the backend under the key for `name`\n        ...\n\n    def _finalize(self) -&gt; None:\n        # close the backend; called automatically when all sinks are done\n        ...\n</code></pre> <ol> <li><code>super().prepare()</code> resets per-source counters and returns the bound <code>FrameSink</code> — always call it.</li> <li><code>super().kickoff()</code> sets <code>is_open</code> — always call it.</li> </ol> <p>Warning</p> <p><code>_write_frame</code> is called by <code>FrameSink.write</code> under the writer lock. Do not acquire the lock again inside <code>_write_frame</code> or call any method that does.</p>","path":["Explanations","Architecture","Storage"],"tags":[]},{"location":"explanations/architecture/storage/#see-also","level":2,"title":"See also","text":"<ul> <li><code>sunflare.storage</code> API reference</li> <li>Devices</li> </ul>","path":["Explanations","Architecture","Storage"],"tags":[]},{"location":"explanations/architecture/virtual/","level":1,"title":"Virtual container","text":"<p>At application construction, <code>redsun</code> creates a <code>VirtualContainer</code>, a shared resource container which provides the following things:</p> <ul> <li>a registration point for <code>psygnal.Signals</code> declared in your component;</li> <li>a registration point for <code>bluesky</code>-compliant callbacks to consume documents produced by a <code>RunEngine</code> during a plan execution;</li> <li>a way to dynamically registering any kind of resource to make them available to the rest of the application, giving control to the single component to expose whatever additional information it can provide or should be able to retrieve.</li> </ul> <p>Additionally it provides a view of the configuration file app-level fields, described in <code>RedSunConfig</code>.</p>","path":["Explanations","Architecture","Virtual container"],"tags":[]},{"location":"explanations/architecture/virtual/#provider-components","level":2,"title":"Provider components","text":"<p>Components that may wish to inject one of the above functionalities must implement the <code>IsProvider</code> protocol, by adding the following method:</p> <pre><code>from sunflare.virtual import VirtualContainer\nfrom dependency_injector import providers\nfrom event_model.documents import Document\n\nclass MyComponent:\n\n    mySignal: Signal()\n    myOtherSignal: Signal(int)\n\n    my_provider: dict[str, Any] = {}\n\n    def my_callback(name: str, document: Document) -&gt; None\n        # a callback a RunEngine can consume\n\n    def my_other_callback(name: str, document: Document) -&gt; None\n        # a second callback from the same owner\n\n    def register_providers(self, container: VirtualContainer) -&gt; None:\n        # register a signal via \"register signals\", which can be accessed via\n        # container.signals[\"MyComponent\"][\"mySignal\"]\n        container.register_signals(self)\n\n        # you can also provide an alias for the component to be cached\n        container.register_signals(self, \"my-component\")\n\n        # you can selectively specify which signal to expose via the \"only\" keyword\n        # and provide an iterable object containing names matching the signal attributes\n        # you wish to register, hiding the others\n        container.register_signals(self, only=[\"mySignal\"])\n\n        # you can register your callbacks; by default the owner's name attribute\n        # is used as the registry key; if your component subclasses DocumentRouter\n        # directly, it is accepted as-is without signature inspection since the\n        # interface is guaranteed by the base class\n        container.register_callbacks(self)\n\n        # you can override the registry key with an explicit name\n        container.register_callbacks(self, name=\"my-callback\")\n\n        # if you need to expose more than one callback from the same owner,\n        # use the callback_map parameter; each entry is registered independently\n        # under its own key, and the owner-level name is ignored\n        container.register_callbacks(self, callback_map={\n            \"live-data\": self.my_callback,\n            \"scan-meta\": self.my_other_callback,\n        })\n\n        # you can dynamically register objects the other components can get access to,\n        # using the dependency_injector.providers module\n        container.my_object = providers.Object(self.my_provider)\n</code></pre> <p><code>python-dependency-injector</code> offers a great deal of options of what kind of resource to shared with other components. Refer to its documentation for more information.</p>","path":["Explanations","Architecture","Virtual container"],"tags":[]},{"location":"explanations/architecture/virtual/#injected-components","level":2,"title":"Injected components","text":"<p>Through the <code>VirtualContainer</code>, objects provided by other components may be retrieved by implementing the <code>IsInjectable</code> protocol.</p> <pre><code>from sunflare.virtual import VirtualContainer\nfrom dependency_injector import providers\nfrom event_model.documents import Document\n\nclass MyOtherComponent:\n\n    def my_slot(self) -&gt; None:\n        ...\n\n    def inject_dependencies(self, container: VirtualContainer) -&gt; None:\n        # get the currently cached signals so you can connect them\n        # to your own slots, to provide event-based communication\n        # between components; be sure to handle the case\n        # where the component might not be existent\n        container.signals[\"MyComponent\"][\"MySignal\"].connect(self.my_slot)\n\n        # get the currently available callbacks so you can consume RunEngine documents;\n        # this is useful when your component contains a RunEngine itself and you wish\n        # to dispatch documents to other components\n        callback = container.callbacks[\"my-callback\"]\n        self.engine.subscribe(callback)\n\n        # get any object registered by other components\n        object_from_component = container.my_object()\n</code></pre> <p>Note</p> <p>Dynamically registering objects via <code>container.my_object = providers.Object()</code> or any other provider does not allow other components to be aware of the type hints associated with that injected object; it is the responsibility of component developers to document whatever object is stored in the virtual container and what type does it represent.</p>","path":["Explanations","Architecture","Virtual container"],"tags":[]},{"location":"how-to/","level":1,"title":"How-to guides","text":"<ul> <li>Installation - How to install <code>sunflare</code> in different environments.</li> <li>Build documentation - How to build the documentation locally.</li> <li>Run tests - How to run the test suite and generate coverage reports.</li> </ul>","path":["How to","How-to guides"],"tags":[]},{"location":"how-to/build-docs/","level":1,"title":"Build documentation","text":"<p>This guide shows you how to build the Sunflare documentation locally.</p>","path":["How to","Build documentation"],"tags":[]},{"location":"how-to/build-docs/#prerequisites","level":2,"title":"Prerequisites","text":"<p>Make sure you have installed <code>sunflare</code> with development dependencies.</p>","path":["How to","Build documentation"],"tags":[]},{"location":"how-to/build-docs/#build-with-zensical","level":2,"title":"Build with <code>zensical</code>","text":"<p>You can build the documentation by running the following command from the project root:</p> <pre><code>uv run mkdocs build\n</code></pre> <p>The built documentation will be in the <code>site/</code> directory. Open <code>site/index.html</code> in your browser to view it.</p>","path":["How to","Build documentation"],"tags":[]},{"location":"how-to/build-docs/#serve-documentation-locally","level":2,"title":"Serve documentation locally","text":"<p>For development, you can serve the documentation with live reload:</p> <pre><code>uv run zensical serve\n</code></pre> <p>This will start a local server at <code>http://localhost:8000</code> and automatically rebuild the documentation when you make changes.</p>","path":["How to","Build documentation"],"tags":[]},{"location":"how-to/build-docs/#troubleshooting","level":2,"title":"Troubleshooting","text":"","path":["How to","Build documentation"],"tags":[]},{"location":"how-to/build-docs/#missing-dependencies","level":3,"title":"Missing dependencies","text":"<p>If you get errors about missing dependencies, make sure you've installed the development dependencies:</p> <pre><code>uv sync\n</code></pre>","path":["How to","Build documentation"],"tags":[]},{"location":"how-to/build-docs/#port-already-in-use","level":3,"title":"Port already in use","text":"<p>If port 8000 is already in use, you can specify a different port:</p> <pre><code>uv run zensical serve --dev-addr localhost:8080\n</code></pre>","path":["How to","Build documentation"],"tags":[]},{"location":"how-to/build-docs/#next-steps","level":2,"title":"Next Steps","text":"<ul> <li>Learn how to run tests</li> <li>Read about <code>sunflare</code> architecture</li> </ul>","path":["How to","Build documentation"],"tags":[]},{"location":"how-to/installation/","level":1,"title":"Installation","text":"<p>This guide shows you how to install Sunflare in different environments.</p>","path":["How to","Installation"],"tags":[]},{"location":"how-to/installation/#create-a-virtual-environment","level":2,"title":"Create a Virtual Environment","text":"<p>It is recommended to install the package in a virtual environment.</p> uv (recommended)venvcondamamba <pre><code>uv venv --python 3.10\n\n# For Linux/macOS\nsource .venv/bin/activate\n\n# For Windows Command Prompt\n.venv\\Scripts\\activate.bat\n\n# For Windows PowerShell\n.venv\\Scripts\\Activate.ps1\n</code></pre> <pre><code># Python version depends on the globally installed Python\npython -m venv sunflare-env\n\n# For Linux/macOS\nsource sunflare-env/bin/activate\n\n# For Windows Command Prompt\nsunflare-env\\Scripts\\activate.bat\n\n# For Windows PowerShell\nsunflare-env\\Scripts\\Activate.ps1\n</code></pre> <pre><code>conda create -n sunflare-env python=3.10\nconda activate sunflare-env\n</code></pre> <pre><code>mamba create -n sunflare-env python=3.10\nmamba activate sunflare-env\n</code></pre>","path":["How to","Installation"],"tags":[]},{"location":"how-to/installation/#install-sunflare","level":2,"title":"Install <code>sunflare</code>","text":"<p>You can install the package from PyPI or directly from the GitHub repository.</p> PyPIGitHub (Development) <pre><code>uv pip install sunflare\n\n# ... or without uv\npip install -U sunflare\n</code></pre> <pre><code>git clone https://github.com/redsun-acquisition/sunflare.git\ncd sunflare\n\nuv sync\n\n# ... or without uv\npip install -e .[dev]\n</code></pre>","path":["How to","Installation"],"tags":[]},{"location":"how-to/installation/#install-development-dependencies","level":2,"title":"Install development dependencies","text":"<p>If you're contributing to Sunflare or want to run tests locally, install the development dependencies via PEP-735 dependency groups.</p> uv (recommended)pip <pre><code># Dev dependencies are automatically synchronized\nuv sync\n</code></pre> <pre><code>pip install -e .[dev]\n</code></pre>","path":["How to","Installation"],"tags":[]},{"location":"how-to/installation/#next-steps","level":2,"title":"Next steps","text":"<ul> <li>Build the documentation</li> <li>Run tests</li> <li>Check the tutorials to get started with Sunflare</li> </ul>","path":["How to","Installation"],"tags":[]},{"location":"how-to/run-tests/","level":1,"title":"Run tests","text":"<p>This guide shows you how to run the Sunflare test suite and generate coverage reports.</p>","path":["How to","Run tests"],"tags":[]},{"location":"how-to/run-tests/#prerequisites","level":2,"title":"Prerequisites","text":"<p>Make sure you have installed Sunflare with development dependencies.</p>","path":["How to","Run tests"],"tags":[]},{"location":"how-to/run-tests/#run-all-tests","level":2,"title":"Run all tests","text":"<p>You can run the tests by running the following command from the project root:</p> <pre><code>pytest\n</code></pre>","path":["How to","Run tests"],"tags":[]},{"location":"how-to/run-tests/#generate-coverage-reports","level":2,"title":"Generate coverage reports","text":"<p>You can obtain a test coverage report by running:</p> <pre><code>pytest --cov=sunflare --cov-report=html\n</code></pre> <p>This will generate an <code>htmlcov/</code> directory with the test coverage report. Open <code>htmlcov/index.html</code> in your browser to view it.</p>","path":["How to","Run tests"],"tags":[]},{"location":"how-to/run-tests/#run-tests-on-multiple-python-versions","level":2,"title":"Run tests on multiple Python versions","text":"<p><code>sunflare</code> provides a <code>noxfile.py</code> to run tests with <code>nox</code> on all supported Python versions.</p> <p>If you use <code>uv</code>, you can run tests as follows:</p> <pre><code># Install nox globally\nuv tool install nox\n\n# Run tests on all Python versions\nnox -s tests\n</code></pre> <p>This will test against all supported Python versions (3.10, 3.11, 3.12, 3.13).</p>","path":["How to","Run tests"],"tags":[]},{"location":"how-to/run-tests/#verbose-output","level":2,"title":"Verbose output","text":"<p>For more detailed output, use the <code>-v</code> flag:</p> <pre><code>pytest -v\n</code></pre>","path":["How to","Run tests"],"tags":[]},{"location":"how-to/run-tests/#stop-on-first-failure","level":2,"title":"Stop on First Failure","text":"<p>To stop at the first failing test:</p> <pre><code>pytest -x\n</code></pre>","path":["How to","Run tests"],"tags":[]},{"location":"how-to/run-tests/#next-steps","level":2,"title":"Next Steps","text":"<ul> <li>Build the documentation</li> <li><code>sunflare</code> architecture</li> <li>API reference</li> </ul>","path":["How to","Run tests"],"tags":[]},{"location":"reference/","level":1,"title":"Reference","text":"<ul> <li>API reference</li> <li>Changelog</li> </ul>","path":["Reference"],"tags":[]},{"location":"reference/api/","level":1,"title":"API reference","text":"<p>Storage infrastructure for sunflare devices.</p> <p>This subpackage provides the dependency-free primitives for storage:</p> <ul> <li><code>Writer</code> — abstract base class for storage backends</li> <li><code>FrameSink</code> — device-facing handle for pushing frames</li> <li><code>SourceInfo</code> — per-device frame metadata</li> <li><code>PathInfo</code> — storage path and configuration for one device</li> <li><code>FilenameProvider</code> — protocol for filename callables</li> <li><code>PathProvider</code> — protocol for path-info callables</li> <li><code>StaticFilenameProvider</code>,   <code>UUIDFilenameProvider</code>,   <code>AutoIncrementFilenameProvider</code> — concrete filename strategies</li> <li><code>StaticPathProvider</code> — concrete path provider</li> <li><code>StorageProxy</code> — protocol implemented by all storage backends</li> <li><code>StorageDescriptor</code> — descriptor for declaring <code>storage</code> on a device</li> </ul> <p>Concrete backend classes (e.g. <code>ZarrWriter</code>) are internal implementation details and are not exported from this package. The application container is responsible for selecting and instantiating the correct backend based on the session configuration.</p> <p>Devices that require storage declare it explicitly in their class body:</p> <pre><code>from sunflare.storage import StorageDescriptor\n\n\nclass MyDetector(Device):\n    storage = StorageDescriptor()\n</code></pre> <p>Classes:</p> Name Description <code>FrameSink</code> <p>Device-facing handle for pushing frames to a storage backend.</p> <code>SourceInfo</code> <p>Metadata for a registered data source.</p> <code>Writer</code> <p>Abstract base class for data writers.</p> <code>AutoIncrementFilenameProvider</code> <p>Returns a numerically incrementing filename on each call.</p> <code>FilenameProvider</code> <p>Callable that produces a filename (without extension) for a device.</p> <code>PathInfo</code> <p>Where and how a storage backend should write data for one device.</p> <code>PathProvider</code> <p>Callable that produces <code>PathInfo</code> for a device.</p> <code>StaticFilenameProvider</code> <p>Always returns the same filename.</p> <code>StaticPathProvider</code> <p>Provides <code>PathInfo</code> rooted at a fixed base URI.</p> <code>UUIDFilenameProvider</code> <p>Returns a fresh UUID4 string on every call.</p> <code>StorageDescriptor</code> <p>Descriptor that manages the <code>storage</code> slot on a device.</p> <code>StorageProxy</code> <p>Protocol that devices use to interact with a storage backend.</p> <p>Classes:</p> Name Description <code>Device</code> <p>Base class for devices.</p> <code>PDevice</code> <p>Minimal required protocol for a recognizable device in Redsun.</p> <p>Classes:</p> Name Description <code>PPresenter</code> <p>Presenter protocol class.</p> <code>Presenter</code> <p>Presenter base class.</p> <p>Classes:</p> Name Description <code>RedSunConfig</code> <p>Base configuration schema for Redsun applications.</p> <code>VirtualContainer</code> <p>Data exchange and dependency injection layer.</p> <code>HasShutdown</code> <p>Protocol marking your class as capable of shutting down.</p> <code>IsInjectable</code> <p>Protocol marking a class as injectable with dependencies from the container.</p> <code>IsProvider</code> <p>Protocol marking a class as a provider of dependencies.</p> <p>Attributes:</p> Name Type Description <code>CallbackType</code> <code>TypeAlias</code> <p>Type alias for document callback functions.</p> <code>SignalCache</code> <code>TypeAlias</code> <p>Cache type for storing signal instances registered from component classes.</p> <p>Modules:</p> Name Description <code>qt</code> <p>Classes:</p> Name Description <code>PView</code> <p>Minimal protocol a view component should implement.</p> <code>View</code> <p>Base view class.</p> <code>ViewPosition</code> <p>Supported view positions.</p> <p>Classes:</p> Name Description <code>Loggable</code> <p>Mixin class that adds a logger to a class instance with extra contextual information.</p> <p>Classes:</p> Name Description <code>Status</code> <p>Track the status of a potentially-lengthy action like moving or triggering.</p> <code>RunEngine</code> <p>The Run Engine execute messages and emits Documents.</p>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.storage.FrameSink","level":2,"title":"FrameSink","text":"<p>Device-facing handle for pushing frames to a storage backend.</p> <p>Returned by <code>Writer.prepare</code>. Devices write frames by calling <code>write</code>; the sink routes each frame to the correct array inside the shared <code>Writer</code> and updates the frame counter atomically.</p> <p>Calling <code>close</code> is equivalent to calling <code>Writer.complete</code> for this source — it signals that no more frames will arrive and triggers backend finalisation once all active sinks have been closed.</p> <p>Parameters:</p> Name Type Description Default <code>writer</code> <code>Writer</code> <p>The shared writer that owns this sink.</p> required <code>name</code> <code>str</code> <p>Source name this sink is bound to.</p> required <p>Methods:</p> Name Description <code>write</code> <p>Push frame to the storage backend.</p> <code>close</code> <p>Signal that no more frames will be written from this sink.</p> Source code in <code>src/sunflare/storage/_base.py</code> <pre><code>class FrameSink:\n    \"\"\"Device-facing handle for pushing frames to a storage backend.\n\n    Returned by [`Writer.prepare`][sunflare.storage.Writer.prepare].\n    Devices write frames by calling [`write`][sunflare.storage.FrameSink.write];\n    the sink routes each frame to the correct array inside the shared\n    [`Writer`][sunflare.storage.Writer] and updates the frame counter atomically.\n\n    Calling [`close`][sunflare.storage.FrameSink.close] is equivalent to calling\n    [`Writer.complete`][sunflare.storage.Writer.complete] for this source — it\n    signals that no more frames will arrive and triggers backend finalisation\n    once all active sinks have been closed.\n\n    Parameters\n    ----------\n    writer : Writer\n        The shared writer that owns this sink.\n    name : str\n        Source name this sink is bound to.\n    \"\"\"\n\n    def __init__(self, writer: Writer, name: str) -&gt; None:\n        self._writer = writer\n        self._name = name\n\n    def write(self, frame: npt.NDArray[np.generic]) -&gt; None:\n        \"\"\"Push *frame* to the storage backend.\n\n        Thread-safe; multiple sinks may call `write` concurrently.\n\n        Parameters\n        ----------\n        frame : npt.NDArray[np.generic]\n            Array data to write.  dtype and shape must match the source\n            registration from [`Writer.update_source`][sunflare.storage.Writer.update_source].\n        \"\"\"\n        with self._writer._lock:\n            self._writer._write_frame(self._name, frame)\n            self._writer._sources[self._name].frames_written += 1\n\n    def close(self) -&gt; None:\n        \"\"\"Signal that no more frames will be written from this sink.\n\n        Delegates to [`Writer.complete`][sunflare.storage.Writer.complete].\n        The backend is finalised once all active sinks have called `close`.\n        \"\"\"\n        self._writer.complete(self._name)\n</code></pre>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.storage.FrameSink.write","level":3,"title":"write","text":"<pre><code>write(frame: NDArray[generic]) -&gt; None\n</code></pre> <p>Push frame to the storage backend.</p> <p>Thread-safe; multiple sinks may call <code>write</code> concurrently.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>NDArray[generic]</code> <p>Array data to write.  dtype and shape must match the source registration from <code>Writer.update_source</code>.</p> required Source code in <code>src/sunflare/storage/_base.py</code> <pre><code>def write(self, frame: npt.NDArray[np.generic]) -&gt; None:\n    \"\"\"Push *frame* to the storage backend.\n\n    Thread-safe; multiple sinks may call `write` concurrently.\n\n    Parameters\n    ----------\n    frame : npt.NDArray[np.generic]\n        Array data to write.  dtype and shape must match the source\n        registration from [`Writer.update_source`][sunflare.storage.Writer.update_source].\n    \"\"\"\n    with self._writer._lock:\n        self._writer._write_frame(self._name, frame)\n        self._writer._sources[self._name].frames_written += 1\n</code></pre>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.storage.FrameSink.close","level":3,"title":"close","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Signal that no more frames will be written from this sink.</p> <p>Delegates to <code>Writer.complete</code>. The backend is finalised once all active sinks have called <code>close</code>.</p> Source code in <code>src/sunflare/storage/_base.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"Signal that no more frames will be written from this sink.\n\n    Delegates to [`Writer.complete`][sunflare.storage.Writer.complete].\n    The backend is finalised once all active sinks have called `close`.\n    \"\"\"\n    self._writer.complete(self._name)\n</code></pre>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.storage.SourceInfo","level":2,"title":"SourceInfo  <code>dataclass</code>","text":"<p>Metadata for a registered data source.</p> <p>Attributes:</p> Name Type Description <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>An enumeration.</p> required <code>dtype</code> <code>dtype[generic]</code> <p>An enumeration.</p> required <code>shape</code> <code>tuple[int, ...]</code> <p>An enumeration.</p> required <code>data_key</code> <code>str</code> <p>An enumeration.</p> required <code>mimetype</code> <code>str</code> <p>An enumeration.</p> <code>'application/octet-stream'</code> <code>frames_written</code> <code>int</code> <p>An enumeration.</p> <code>0</code> <code>collection_counter</code> <code>int</code> <p>An enumeration.</p> <code>0</code> <code>stream_resource_uid</code> <code>str</code> <code>'d29e05a6-7ad1-40b1-b94d-4532f30cc4ff'</code> <code>extra</code> <code>dict[str, Any]</code> <p>dict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping object's     (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via:     d = {}     for k, v in iterable:         d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs     in the keyword argument list.  For example:  dict(one=1, two=2)</p> <code>&lt;class 'dict'&gt;</code> Source code in <code>src/sunflare/storage/_base.py</code> <pre><code>@dataclass\nclass SourceInfo:\n    \"\"\"Metadata for a registered data source.\n\n    Attributes\n    ----------\n    name : str\n        Name of the data source (e.g. the device name).\n    dtype : np.dtype[np.generic]\n        NumPy data type of the source frames.\n    shape : tuple[int, ...]\n        Shape of individual frames from the source.\n    data_key : str\n        Bluesky data key for stream documents.\n    mimetype : str\n        MIME type hint for the storage backend.\n    frames_written : int\n        Running count of frames written so far.\n    collection_counter : int\n        Frames reported in the current collection cycle.\n    stream_resource_uid : str\n        UID of the current `StreamResource` document.\n    extra : dict[str, Any]\n        Optional extra metadata for backend-specific use (e.g. OME-Zarr\n        axis labels, physical units).  Base [`Writer`][sunflare.storage.Writer]\n        ignores this field; specialised subclasses may read it.\n    \"\"\"\n\n    name: str\n    dtype: np.dtype[np.generic]\n    shape: tuple[int, ...]\n    data_key: str\n    mimetype: str = \"application/octet-stream\"\n    frames_written: int = 0\n    collection_counter: int = 0\n    stream_resource_uid: str = field(default_factory=lambda: str(uuid.uuid4()))\n    extra: dict[str, Any] = field(default_factory=dict)\n</code></pre>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.storage.Writer","level":2,"title":"Writer","text":"<p>               Bases: <code>ABC</code>, <code>Loggable</code></p> <p>Abstract base class for data writers.</p> <p>This interface loosely follows the Bluesky <code>Flyable</code> protocol while remaining generic — methods do not need to return a <code>Status</code> object; that is left to the device that owns the writer.</p> <p>A single <code>Writer</code> instance is shared by all devices in a session. Each device registers itself as a source via <code>update_source</code> and obtains a dedicated <code>FrameSink</code> via <code>prepare</code>.</p> <p>Call order per acquisition:</p> <ol> <li><code>update_source(name, dtype, shape)</code> — register the device</li> <li><code>prepare(name, capacity)</code> — returns a <code>FrameSink</code></li> <li><code>kickoff()</code> — opens the backend</li> <li><code>sink.write(frame)</code> — push frames (thread-safe)</li> <li><code>sink.close()</code> — signals completion (calls <code>complete</code>)</li> </ol> <p>Subclasses must implement:</p> <ul> <li><code>mimetype</code> — MIME type string for this backend</li> <li><code>prepare</code> — source-specific setup; must call <code>super().prepare()</code></li> <li><code>kickoff</code> — open the backend; must call <code>super().kickoff()</code></li> <li><code>_write_frame</code> — write one frame to the backend</li> <li><code>_finalize</code> — close the backend when all sources are complete</li> </ul> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Unique name for this writer instance (used for logging).</p> required <p>Methods:</p> Name Description <code>update_source</code> <p>Register or update a data source.</p> <code>clear_source</code> <p>Remove a registered data source.</p> <code>get_indices_written</code> <p>Return the number of frames written for a source.</p> <code>reset_collection_state</code> <p>Reset the collection counter for a new acquisition.</p> <code>kickoff</code> <p>Open the storage backend for a new acquisition.</p> <code>prepare</code> <p>Prepare storage for a specific source and return a frame sink.</p> <code>complete</code> <p>Mark acquisition complete for name.</p> <code>collect_stream_docs</code> <p>Yield <code>StreamResource</code> and <code>StreamDatum</code> documents for name.</p> <p>Attributes:</p> Name Type Description <code>is_open</code> <code>bool</code> <p>Return whether the writer is currently open.</p> <code>name</code> <code>str</code> <p>Return the name of this writer.</p> <code>mimetype</code> <code>str</code> <p>Return the MIME type string for this backend.</p> <code>sources</code> <code>MappingProxyType[str, SourceInfo]</code> <p>Return a read-only view of the registered data sources.</p> Source code in <code>src/sunflare/storage/_base.py</code> <pre><code>class Writer(abc.ABC, Loggable):\n    \"\"\"Abstract base class for data writers.\n\n    This interface loosely follows the Bluesky `Flyable` protocol while\n    remaining generic — methods do not need to return a `Status` object;\n    that is left to the device that owns the writer.\n\n    A single `Writer` instance is shared by all devices in a session.\n    Each device registers itself as a *source* via\n    [`update_source`][sunflare.storage.Writer.update_source] and obtains\n    a dedicated [`FrameSink`][sunflare.storage.FrameSink] via\n    [`prepare`][sunflare.storage.Writer.prepare].\n\n    Call order per acquisition:\n\n    1. `update_source(name, dtype, shape)` — register the device\n    2. `prepare(name, capacity)` — returns a [`FrameSink`][sunflare.storage.FrameSink]\n    3. `kickoff()` — opens the backend\n    4. `sink.write(frame)` — push frames (thread-safe)\n    5. `sink.close()` — signals completion (calls [`complete`][sunflare.storage.Writer.complete])\n\n    Subclasses must implement:\n\n    - [`mimetype`][sunflare.storage.Writer.mimetype] — MIME type string for this backend\n    - [`prepare`][sunflare.storage.Writer.prepare] — source-specific setup; must call `super().prepare()`\n    - [`kickoff`][sunflare.storage.Writer.kickoff] — open the backend; must call `super().kickoff()`\n    - `_write_frame` — write one frame to the backend\n    - `_finalize` — close the backend when all sources are complete\n\n    Parameters\n    ----------\n    name : str\n        Unique name for this writer instance (used for logging).\n    \"\"\"\n\n    def __init__(self, name: str) -&gt; None:\n        self._name = name\n        self._store_path = \"\"\n        self._lock = th.Lock()\n        self._is_open = False\n        self._sources: dict[str, SourceInfo] = {}\n        self._active_sinks: set[str] = set()\n\n    # ------------------------------------------------------------------\n    # Properties\n    # ------------------------------------------------------------------\n\n    @property\n    def is_open(self) -&gt; bool:\n        \"\"\"Return whether the writer is currently open.\"\"\"\n        return self._is_open\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"Return the name of this writer.\"\"\"\n        return self._name\n\n    @property\n    @abc.abstractmethod\n    def mimetype(self) -&gt; str:\n        \"\"\"Return the MIME type string for this backend.\"\"\"\n        ...\n\n    @property\n    def sources(self) -&gt; MappingProxyType[str, SourceInfo]:\n        \"\"\"Return a read-only view of the registered data sources.\"\"\"\n        return MappingProxyType(self._sources)\n\n    # ------------------------------------------------------------------\n    # Source management\n    # ------------------------------------------------------------------\n\n    def update_source(\n        self,\n        name: str,\n        dtype: np.dtype[np.generic],\n        shape: tuple[int, ...],\n        extra: dict[str, Any] | None = None,\n    ) -&gt; None:\n        \"\"\"Register or update a data source.\n\n        Parameters\n        ----------\n        name : str\n            Source name (typically the device name).\n        dtype : np.dtype[np.generic]\n            NumPy data type of the frames.\n        shape : tuple[int, ...]\n            Shape of individual frames.\n        extra : dict[str, Any] | None\n            Optional backend-specific metadata forwarded to\n            [`SourceInfo`][sunflare.storage.SourceInfo].\n\n        Raises\n        ------\n        RuntimeError\n            If the writer is currently open.\n        \"\"\"\n        if self._is_open:\n            raise RuntimeError(\"Cannot update sources while writer is open.\")\n\n        data_key = f\"{name}:buffer:stream\"\n        self._sources[name] = SourceInfo(\n            name=name,\n            dtype=dtype,\n            shape=shape,\n            data_key=data_key,\n            mimetype=self.mimetype,\n            extra=extra or {},\n        )\n        self.logger.debug(f\"Updated source '{name}' with shape {shape}\")\n\n    def clear_source(self, name: str, *, raise_if_missing: bool = False) -&gt; None:\n        \"\"\"Remove a registered data source.\n\n        Parameters\n        ----------\n        name : str\n            Source name to remove.\n        raise_if_missing : bool\n            If `True`, raise `KeyError` when the source is absent.\n\n        Raises\n        ------\n        RuntimeError\n            If the writer is currently open.\n        KeyError\n            If *raise_if_missing* is `True` and the source is absent.\n        \"\"\"\n        if self._is_open:\n            raise RuntimeError(\"Cannot clear sources while writer is open.\")\n\n        try:\n            del self._sources[name]\n            self.logger.debug(f\"Cleared source '{name}'\")\n        except KeyError as exc:\n            self.logger.error(f\"Source '{name}' not found.\")\n            if raise_if_missing:\n                raise exc\n\n    def get_indices_written(self, name: str | None = None) -&gt; int:\n        \"\"\"Return the number of frames written for a source.\n\n        Parameters\n        ----------\n        name : str | None\n            Source name.  If `None`, returns the minimum across all\n            sources (useful for synchronisation checks).\n\n        Raises\n        ------\n        KeyError\n            If *name* is not registered.\n        \"\"\"\n        if name is None:\n            if not self._sources:\n                return 0\n            return min(s.frames_written for s in self._sources.values())\n\n        if name not in self._sources:\n            raise KeyError(f\"Unknown source '{name}'\")\n        return self._sources[name].frames_written\n\n    def reset_collection_state(self, name: str) -&gt; None:\n        \"\"\"Reset the collection counter for a new acquisition.\n\n        Parameters\n        ----------\n        name : str\n            Source name to reset.\n        \"\"\"\n        source = self._sources[name]\n        source.collection_counter = 0\n        source.stream_resource_uid = str(uuid.uuid4())\n\n    # ------------------------------------------------------------------\n    # Acquisition lifecycle\n    # ------------------------------------------------------------------\n\n    @abc.abstractmethod\n    def kickoff(self) -&gt; None:\n        \"\"\"Open the storage backend for a new acquisition.\n\n        Subclasses must call `super().kickoff()` to set\n        [`is_open`][sunflare.storage.Writer.is_open].\n        Subsequent calls while already open must be no-ops.\n        \"\"\"\n        if not self._is_open:\n            self._is_open = True\n\n    @abc.abstractmethod\n    def prepare(self, name: str, capacity: int = 0) -&gt; FrameSink:\n        \"\"\"Prepare storage for a specific source and return a frame sink.\n\n        Called once per device per acquisition.  Resets per-source counters\n        and returns a [`FrameSink`][sunflare.storage.FrameSink] bound to *name*.\n\n        Parameters\n        ----------\n        name : str\n            Source name.\n        capacity : int\n            Maximum frames to accept (`0` = unlimited).\n\n        Returns\n        -------\n        FrameSink\n            Bound sink; call `sink.write(frame)` to push frames.\n\n        Raises\n        ------\n        KeyError\n            If *name* has not been registered via\n            [`update_source`][sunflare.storage.Writer.update_source].\n        \"\"\"\n        source = self._sources[name]\n        source.frames_written = 0\n        source.collection_counter = 0\n        source.stream_resource_uid = str(uuid.uuid4())\n        self._active_sinks.add(name)\n        return FrameSink(self, name)\n\n    def complete(self, name: str) -&gt; None:\n        \"\"\"Mark acquisition complete for *name*.\n\n        Called automatically by [`FrameSink.close`][sunflare.storage.FrameSink.close].\n        The backend is finalised once all active sinks have called `close`.\n\n        Parameters\n        ----------\n        name : str\n            Source name.\n        \"\"\"\n        self._active_sinks.discard(name)\n        if not self._active_sinks:\n            self._finalize()\n            self._is_open = False\n\n    # ------------------------------------------------------------------\n    # Backend hooks (subclass responsibility)\n    # ------------------------------------------------------------------\n\n    @abc.abstractmethod\n    def _write_frame(self, name: str, frame: npt.NDArray[np.generic]) -&gt; None:\n        \"\"\"Write one frame to the backend.\n\n        Called by [`FrameSink.write`][sunflare.storage.FrameSink.write]\n        under the writer lock.\n\n        Parameters\n        ----------\n        name : str\n            Source name.\n        frame : npt.NDArray[np.generic]\n            Frame data to write.\n        \"\"\"\n        ...\n\n    @abc.abstractmethod\n    def _finalize(self) -&gt; None:\n        \"\"\"Close the backend after all sinks have been closed.\"\"\"\n        ...\n\n    # ------------------------------------------------------------------\n    # Stream document generation\n    # ------------------------------------------------------------------\n\n    def collect_stream_docs(\n        self,\n        name: str,\n        indices_written: int,\n    ) -&gt; Iterator[StreamAsset]:\n        \"\"\"Yield `StreamResource` and `StreamDatum` documents for *name*.\n\n        Parameters\n        ----------\n        name : str\n            Source name.\n        indices_written : int\n            Number of frames to report in this call.\n\n        Yields\n        ------\n        StreamAsset\n            Tuples of `(\"stream_resource\", doc)` or `(\"stream_datum\", doc)`.\n\n        Raises\n        ------\n        KeyError\n            If *name* is not registered.\n        \"\"\"\n        if name not in self._sources:\n            raise KeyError(f\"Unknown source '{name}'\")\n\n        source = self._sources[name]\n\n        if indices_written == 0:\n            return\n\n        frames_to_report = min(indices_written, source.frames_written)\n\n        if source.collection_counter &gt;= frames_to_report:\n            return\n\n        if source.collection_counter == 0:\n            stream_resource: StreamResource = {\n                \"data_key\": source.data_key,\n                \"mimetype\": source.mimetype,\n                \"parameters\": {\"array_name\": source.name},\n                \"uid\": source.stream_resource_uid,\n                \"uri\": self._store_path,\n            }\n            yield (\"stream_resource\", stream_resource)\n\n        stream_datum: StreamDatum = {\n            \"descriptor\": \"\",\n            \"indices\": {\"start\": source.collection_counter, \"stop\": frames_to_report},\n            \"seq_nums\": {\"start\": 0, \"stop\": 0},\n            \"stream_resource\": source.stream_resource_uid,\n            \"uid\": f\"{source.stream_resource_uid}/{source.collection_counter}\",\n        }\n        yield (\"stream_datum\", stream_datum)\n\n        source.collection_counter = frames_to_report\n</code></pre>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.storage.Writer.is_open","level":3,"title":"is_open  <code>property</code>","text":"<pre><code>is_open: bool\n</code></pre> <p>Return whether the writer is currently open.</p>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.storage.Writer.name","level":3,"title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>Return the name of this writer.</p>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.storage.Writer.mimetype","level":3,"title":"mimetype  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>mimetype: str\n</code></pre> <p>Return the MIME type string for this backend.</p>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.storage.Writer.sources","level":3,"title":"sources  <code>property</code>","text":"<pre><code>sources: MappingProxyType[str, SourceInfo]\n</code></pre> <p>Return a read-only view of the registered data sources.</p>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.storage.Writer.update_source","level":3,"title":"update_source","text":"<pre><code>update_source(\n    name: str,\n    dtype: dtype[generic],\n    shape: tuple[int, ...],\n    extra: dict[str, Any] | None = None,\n) -&gt; None\n</code></pre> <p>Register or update a data source.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Source name (typically the device name).</p> required <code>dtype</code> <code>dtype[generic]</code> <p>NumPy data type of the frames.</p> required <code>shape</code> <code>tuple[int, ...]</code> <p>Shape of individual frames.</p> required <code>extra</code> <code>dict[str, Any] | None</code> <p>Optional backend-specific metadata forwarded to <code>SourceInfo</code>.</p> <code>None</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the writer is currently open.</p> Source code in <code>src/sunflare/storage/_base.py</code> <pre><code>def update_source(\n    self,\n    name: str,\n    dtype: np.dtype[np.generic],\n    shape: tuple[int, ...],\n    extra: dict[str, Any] | None = None,\n) -&gt; None:\n    \"\"\"Register or update a data source.\n\n    Parameters\n    ----------\n    name : str\n        Source name (typically the device name).\n    dtype : np.dtype[np.generic]\n        NumPy data type of the frames.\n    shape : tuple[int, ...]\n        Shape of individual frames.\n    extra : dict[str, Any] | None\n        Optional backend-specific metadata forwarded to\n        [`SourceInfo`][sunflare.storage.SourceInfo].\n\n    Raises\n    ------\n    RuntimeError\n        If the writer is currently open.\n    \"\"\"\n    if self._is_open:\n        raise RuntimeError(\"Cannot update sources while writer is open.\")\n\n    data_key = f\"{name}:buffer:stream\"\n    self._sources[name] = SourceInfo(\n        name=name,\n        dtype=dtype,\n        shape=shape,\n        data_key=data_key,\n        mimetype=self.mimetype,\n        extra=extra or {},\n    )\n    self.logger.debug(f\"Updated source '{name}' with shape {shape}\")\n</code></pre>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.storage.Writer.clear_source","level":3,"title":"clear_source","text":"<pre><code>clear_source(\n    name: str, *, raise_if_missing: bool = False\n) -&gt; None\n</code></pre> <p>Remove a registered data source.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Source name to remove.</p> required <code>raise_if_missing</code> <code>bool</code> <p>If <code>True</code>, raise <code>KeyError</code> when the source is absent.</p> <code>False</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the writer is currently open.</p> <code>KeyError</code> <p>If raise_if_missing is <code>True</code> and the source is absent.</p> Source code in <code>src/sunflare/storage/_base.py</code> <pre><code>def clear_source(self, name: str, *, raise_if_missing: bool = False) -&gt; None:\n    \"\"\"Remove a registered data source.\n\n    Parameters\n    ----------\n    name : str\n        Source name to remove.\n    raise_if_missing : bool\n        If `True`, raise `KeyError` when the source is absent.\n\n    Raises\n    ------\n    RuntimeError\n        If the writer is currently open.\n    KeyError\n        If *raise_if_missing* is `True` and the source is absent.\n    \"\"\"\n    if self._is_open:\n        raise RuntimeError(\"Cannot clear sources while writer is open.\")\n\n    try:\n        del self._sources[name]\n        self.logger.debug(f\"Cleared source '{name}'\")\n    except KeyError as exc:\n        self.logger.error(f\"Source '{name}' not found.\")\n        if raise_if_missing:\n            raise exc\n</code></pre>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.storage.Writer.get_indices_written","level":3,"title":"get_indices_written","text":"<pre><code>get_indices_written(name: str | None = None) -&gt; int\n</code></pre> <p>Return the number of frames written for a source.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>Source name.  If <code>None</code>, returns the minimum across all sources (useful for synchronisation checks).</p> <code>None</code> <p>Raises:</p> Type Description <code>KeyError</code> <p>If name is not registered.</p> Source code in <code>src/sunflare/storage/_base.py</code> <pre><code>def get_indices_written(self, name: str | None = None) -&gt; int:\n    \"\"\"Return the number of frames written for a source.\n\n    Parameters\n    ----------\n    name : str | None\n        Source name.  If `None`, returns the minimum across all\n        sources (useful for synchronisation checks).\n\n    Raises\n    ------\n    KeyError\n        If *name* is not registered.\n    \"\"\"\n    if name is None:\n        if not self._sources:\n            return 0\n        return min(s.frames_written for s in self._sources.values())\n\n    if name not in self._sources:\n        raise KeyError(f\"Unknown source '{name}'\")\n    return self._sources[name].frames_written\n</code></pre>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.storage.Writer.reset_collection_state","level":3,"title":"reset_collection_state","text":"<pre><code>reset_collection_state(name: str) -&gt; None\n</code></pre> <p>Reset the collection counter for a new acquisition.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Source name to reset.</p> required Source code in <code>src/sunflare/storage/_base.py</code> <pre><code>def reset_collection_state(self, name: str) -&gt; None:\n    \"\"\"Reset the collection counter for a new acquisition.\n\n    Parameters\n    ----------\n    name : str\n        Source name to reset.\n    \"\"\"\n    source = self._sources[name]\n    source.collection_counter = 0\n    source.stream_resource_uid = str(uuid.uuid4())\n</code></pre>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.storage.Writer.kickoff","level":3,"title":"kickoff  <code>abstractmethod</code>","text":"<pre><code>kickoff() -&gt; None\n</code></pre> <p>Open the storage backend for a new acquisition.</p> <p>Subclasses must call <code>super().kickoff()</code> to set <code>is_open</code>. Subsequent calls while already open must be no-ops.</p> Source code in <code>src/sunflare/storage/_base.py</code> <pre><code>@abc.abstractmethod\ndef kickoff(self) -&gt; None:\n    \"\"\"Open the storage backend for a new acquisition.\n\n    Subclasses must call `super().kickoff()` to set\n    [`is_open`][sunflare.storage.Writer.is_open].\n    Subsequent calls while already open must be no-ops.\n    \"\"\"\n    if not self._is_open:\n        self._is_open = True\n</code></pre>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.storage.Writer.prepare","level":3,"title":"prepare  <code>abstractmethod</code>","text":"<pre><code>prepare(name: str, capacity: int = 0) -&gt; FrameSink\n</code></pre> <p>Prepare storage for a specific source and return a frame sink.</p> <p>Called once per device per acquisition.  Resets per-source counters and returns a <code>FrameSink</code> bound to name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Source name.</p> required <code>capacity</code> <code>int</code> <p>Maximum frames to accept (<code>0</code> = unlimited).</p> <code>0</code> <p>Returns:</p> Type Description <code>FrameSink</code> <p>Bound sink; call <code>sink.write(frame)</code> to push frames.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If name has not been registered via <code>update_source</code>.</p> Source code in <code>src/sunflare/storage/_base.py</code> <pre><code>@abc.abstractmethod\ndef prepare(self, name: str, capacity: int = 0) -&gt; FrameSink:\n    \"\"\"Prepare storage for a specific source and return a frame sink.\n\n    Called once per device per acquisition.  Resets per-source counters\n    and returns a [`FrameSink`][sunflare.storage.FrameSink] bound to *name*.\n\n    Parameters\n    ----------\n    name : str\n        Source name.\n    capacity : int\n        Maximum frames to accept (`0` = unlimited).\n\n    Returns\n    -------\n    FrameSink\n        Bound sink; call `sink.write(frame)` to push frames.\n\n    Raises\n    ------\n    KeyError\n        If *name* has not been registered via\n        [`update_source`][sunflare.storage.Writer.update_source].\n    \"\"\"\n    source = self._sources[name]\n    source.frames_written = 0\n    source.collection_counter = 0\n    source.stream_resource_uid = str(uuid.uuid4())\n    self._active_sinks.add(name)\n    return FrameSink(self, name)\n</code></pre>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.storage.Writer.complete","level":3,"title":"complete","text":"<pre><code>complete(name: str) -&gt; None\n</code></pre> <p>Mark acquisition complete for name.</p> <p>Called automatically by <code>FrameSink.close</code>. The backend is finalised once all active sinks have called <code>close</code>.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Source name.</p> required Source code in <code>src/sunflare/storage/_base.py</code> <pre><code>def complete(self, name: str) -&gt; None:\n    \"\"\"Mark acquisition complete for *name*.\n\n    Called automatically by [`FrameSink.close`][sunflare.storage.FrameSink.close].\n    The backend is finalised once all active sinks have called `close`.\n\n    Parameters\n    ----------\n    name : str\n        Source name.\n    \"\"\"\n    self._active_sinks.discard(name)\n    if not self._active_sinks:\n        self._finalize()\n        self._is_open = False\n</code></pre>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.storage.Writer.collect_stream_docs","level":3,"title":"collect_stream_docs","text":"<pre><code>collect_stream_docs(\n    name: str, indices_written: int\n) -&gt; Iterator[StreamAsset]\n</code></pre> <p>Yield <code>StreamResource</code> and <code>StreamDatum</code> documents for name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Source name.</p> required <code>indices_written</code> <code>int</code> <p>Number of frames to report in this call.</p> required <p>Yields:</p> Type Description <code>StreamAsset</code> <p>Tuples of <code>(\"stream_resource\", doc)</code> or <code>(\"stream_datum\", doc)</code>.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If name is not registered.</p> Source code in <code>src/sunflare/storage/_base.py</code> <pre><code>def collect_stream_docs(\n    self,\n    name: str,\n    indices_written: int,\n) -&gt; Iterator[StreamAsset]:\n    \"\"\"Yield `StreamResource` and `StreamDatum` documents for *name*.\n\n    Parameters\n    ----------\n    name : str\n        Source name.\n    indices_written : int\n        Number of frames to report in this call.\n\n    Yields\n    ------\n    StreamAsset\n        Tuples of `(\"stream_resource\", doc)` or `(\"stream_datum\", doc)`.\n\n    Raises\n    ------\n    KeyError\n        If *name* is not registered.\n    \"\"\"\n    if name not in self._sources:\n        raise KeyError(f\"Unknown source '{name}'\")\n\n    source = self._sources[name]\n\n    if indices_written == 0:\n        return\n\n    frames_to_report = min(indices_written, source.frames_written)\n\n    if source.collection_counter &gt;= frames_to_report:\n        return\n\n    if source.collection_counter == 0:\n        stream_resource: StreamResource = {\n            \"data_key\": source.data_key,\n            \"mimetype\": source.mimetype,\n            \"parameters\": {\"array_name\": source.name},\n            \"uid\": source.stream_resource_uid,\n            \"uri\": self._store_path,\n        }\n        yield (\"stream_resource\", stream_resource)\n\n    stream_datum: StreamDatum = {\n        \"descriptor\": \"\",\n        \"indices\": {\"start\": source.collection_counter, \"stop\": frames_to_report},\n        \"seq_nums\": {\"start\": 0, \"stop\": 0},\n        \"stream_resource\": source.stream_resource_uid,\n        \"uid\": f\"{source.stream_resource_uid}/{source.collection_counter}\",\n    }\n    yield (\"stream_datum\", stream_datum)\n\n    source.collection_counter = frames_to_report\n</code></pre>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.storage.AutoIncrementFilenameProvider","level":2,"title":"AutoIncrementFilenameProvider","text":"<p>Returns a numerically incrementing filename on each call.</p> <p>Parameters:</p> Name Type Description Default <code>base</code> <code>str</code> <p>Optional base prefix for the filename.</p> <code>''</code> <code>max_digits</code> <code>int</code> <p>Zero-padding width for the counter.</p> <code>5</code> <code>start</code> <code>int</code> <p>Initial counter value.</p> <code>0</code> <code>step</code> <code>int</code> <p>Increment per call.</p> <code>1</code> <code>delimiter</code> <code>str</code> <p>Separator between base and counter.</p> <code>'_'</code> Source code in <code>src/sunflare/storage/_path.py</code> <pre><code>class AutoIncrementFilenameProvider:\n    \"\"\"Returns a numerically incrementing filename on each call.\n\n    Parameters\n    ----------\n    base : str\n        Optional base prefix for the filename.\n    max_digits : int\n        Zero-padding width for the counter.\n    start : int\n        Initial counter value.\n    step : int\n        Increment per call.\n    delimiter : str\n        Separator between *base* and counter.\n    \"\"\"\n\n    def __init__(\n        self,\n        base: str = \"\",\n        max_digits: int = 5,\n        start: int = 0,\n        step: int = 1,\n        delimiter: str = \"_\",\n    ) -&gt; None:\n        self._base = base\n        self._max_digits = max_digits\n        self._current = start\n        self._step = step\n        self._delimiter = delimiter\n\n    def __call__(self, device_name: str | None = None) -&gt; str:\n        \"\"\"Return the next incremented filename.\"\"\"\n        if len(str(self._current)) &gt; self._max_digits:\n            raise ValueError(f\"Counter exceeded maximum of {self._max_digits} digits\")\n        padded = f\"{self._current:0{self._max_digits}}\"\n        name = f\"{self._base}{self._delimiter}{padded}\" if self._base else padded\n        self._current += self._step\n        return name\n</code></pre>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.storage.FilenameProvider","level":2,"title":"FilenameProvider","text":"<p>               Bases: <code>Protocol</code></p> <p>Callable that produces a filename (without extension) for a device.</p> Source code in <code>src/sunflare/storage/_path.py</code> <pre><code>@runtime_checkable\nclass FilenameProvider(Protocol):\n    \"\"\"Callable that produces a filename (without extension) for a device.\"\"\"\n\n    def __call__(self, device_name: str | None = None) -&gt; str:\n        \"\"\"Return a filename for the given device.\n\n        Parameters\n        ----------\n        device_name : str | None\n            Name of the device requesting a filename.  Implementations may\n            ignore this if the filename is device-agnostic.\n\n        Returns\n        -------\n        str\n            A filename string without extension.\n        \"\"\"\n        ...\n</code></pre>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.storage.PathInfo","level":2,"title":"PathInfo  <code>dataclass</code>","text":"<p>Where and how a storage backend should write data for one device.</p> <p>Attributes:</p> Name Type Description <p>Parameters:</p> Name Type Description Default <code>store_uri</code> <code>str</code> <p>An enumeration.</p> required <code>array_key</code> <code>str</code> <p>An enumeration.</p> required <code>capacity</code> <code>int</code> <p>An enumeration.</p> <code>0</code> <code>mimetype_hint</code> <code>str</code> <p>An enumeration.</p> <code>'application/x-zarr'</code> <code>extra</code> <code>dict[str, Any]</code> <p>dict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping object's     (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via:     d = {}     for k, v in iterable:         d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs     in the keyword argument list.  For example:  dict(one=1, two=2)</p> <code>&lt;class 'dict'&gt;</code> Source code in <code>src/sunflare/storage/_path.py</code> <pre><code>@dataclass\nclass PathInfo:\n    \"\"\"Where and how a storage backend should write data for one device.\n\n    Attributes\n    ----------\n    store_uri : str\n        URI of the store root.  For local Zarr this is a `file://` URI;\n        for remote storage it may be `s3://` or similar.\n        Example: `\"file:///data/scan001.zarr\"`.\n    array_key : str\n        Key (array name) within the store for this device's data.\n        Defaults to the device name.\n    capacity : int\n        Maximum number of frames to accept.  `0` means unlimited.\n    mimetype_hint : str\n        MIME type hint for the backend.  Consumers may use this to select\n        the correct reader.\n    extra : dict[str, Any]\n        Optional backend-specific metadata (e.g. OME-Zarr axis labels,\n        physical units).  Base writers ignore this field.\n    \"\"\"\n\n    store_uri: str\n    array_key: str\n    capacity: int = 0\n    mimetype_hint: str = \"application/x-zarr\"\n    extra: dict[str, Any] = field(default_factory=dict)\n</code></pre>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.storage.PathProvider","level":2,"title":"PathProvider","text":"<p>               Bases: <code>Protocol</code></p> <p>Callable that produces <code>PathInfo</code> for a device.</p> <p>Implementations are picklable — they carry no open file handles or mutable process-local state, so they can be safely forwarded to subprocess or remote workers.</p> Source code in <code>src/sunflare/storage/_path.py</code> <pre><code>@runtime_checkable\nclass PathProvider(Protocol):\n    \"\"\"Callable that produces [`PathInfo`][sunflare.storage.PathInfo] for a device.\n\n    Implementations are **picklable** — they carry no open file handles\n    or mutable process-local state, so they can be safely forwarded to\n    subprocess or remote workers.\n    \"\"\"\n\n    def __call__(self, device_name: str | None = None) -&gt; PathInfo:\n        \"\"\"Return path information for the given device.\n\n        Parameters\n        ----------\n        device_name : str | None\n            Name of the device requesting path information.\n\n        Returns\n        -------\n        PathInfo\n            Complete path and storage metadata for the device.\n        \"\"\"\n        ...\n</code></pre>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.storage.StaticFilenameProvider","level":2,"title":"StaticFilenameProvider","text":"<p>Always returns the same filename.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The filename string to return on every call.</p> required Source code in <code>src/sunflare/storage/_path.py</code> <pre><code>class StaticFilenameProvider:\n    \"\"\"Always returns the same filename.\n\n    Parameters\n    ----------\n    filename : str\n        The filename string to return on every call.\n    \"\"\"\n\n    def __init__(self, filename: str) -&gt; None:\n        self._filename = filename\n\n    def __call__(self, device_name: str | None = None) -&gt; str:\n        \"\"\"Return the static filename.\"\"\"\n        return self._filename\n</code></pre>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.storage.StaticPathProvider","level":2,"title":"StaticPathProvider","text":"<p>Provides <code>PathInfo</code> rooted at a fixed base URI.</p> <p>Composes a <code>FilenameProvider</code> (for the array key / filename) with a fixed base_uri (for the store location).</p> <p>Parameters:</p> Name Type Description Default <code>filename_provider</code> <code>FilenameProvider</code> <p>Callable that returns a filename for each device.</p> required <code>base_uri</code> <code>str</code> <p>Base URI for the store root (e.g. <code>\"file:///data\"</code>).</p> required <code>mimetype_hint</code> <code>str</code> <p>MIME type hint forwarded to <code>PathInfo</code>.</p> <code>'application/x-zarr'</code> <code>capacity</code> <code>int</code> <p>Default frame capacity forwarded to <code>PathInfo</code>.</p> <code>0</code> Source code in <code>src/sunflare/storage/_path.py</code> <pre><code>class StaticPathProvider:\n    \"\"\"Provides [`PathInfo`][sunflare.storage.PathInfo] rooted at a fixed base URI.\n\n    Composes a [`FilenameProvider`][sunflare.storage.FilenameProvider]\n    (for the array key / filename) with a fixed *base_uri* (for the store location).\n\n    Parameters\n    ----------\n    filename_provider : FilenameProvider\n        Callable that returns a filename for each device.\n    base_uri : str\n        Base URI for the store root (e.g. `\"file:///data\"`).\n    mimetype_hint : str\n        MIME type hint forwarded to [`PathInfo`][sunflare.storage.PathInfo].\n    capacity : int\n        Default frame capacity forwarded to [`PathInfo`][sunflare.storage.PathInfo].\n    \"\"\"\n\n    def __init__(\n        self,\n        filename_provider: FilenameProvider,\n        base_uri: str,\n        mimetype_hint: str = \"application/x-zarr\",\n        capacity: int = 0,\n    ) -&gt; None:\n        self._filename_provider = filename_provider\n        self._base_uri = base_uri.rstrip(\"/\")\n        self._mimetype_hint = mimetype_hint\n        self._capacity = capacity\n\n    def __call__(self, device_name: str | None = None) -&gt; PathInfo:\n        \"\"\"Return [`PathInfo`][sunflare.storage.PathInfo] for *device_name*.\"\"\"\n        filename = self._filename_provider(device_name)\n        store_uri = f\"{self._base_uri}/{filename}\"\n        array_key = device_name or filename\n        return PathInfo(\n            store_uri=store_uri,\n            array_key=array_key,\n            capacity=self._capacity,\n            mimetype_hint=self._mimetype_hint,\n        )\n</code></pre>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.storage.UUIDFilenameProvider","level":2,"title":"UUIDFilenameProvider","text":"<p>Returns a fresh UUID4 string on every call.</p> <p>Each call produces a new UUID, so files from different acquisitions are never overwritten.</p> Source code in <code>src/sunflare/storage/_path.py</code> <pre><code>class UUIDFilenameProvider:\n    \"\"\"Returns a fresh UUID4 string on every call.\n\n    Each call produces a new UUID, so files from different acquisitions\n    are never overwritten.\n    \"\"\"\n\n    def __call__(self, device_name: str | None = None) -&gt; str:\n        \"\"\"Return a new UUID4 filename.\"\"\"\n        return str(uuid.uuid4())\n</code></pre>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.storage.StorageDescriptor","level":2,"title":"StorageDescriptor","text":"<p>Descriptor that manages the <code>storage</code> slot on a device.</p> <p>The private attribute name is derived from the descriptor's own name at class-creation time via <code>__set_name__</code> (e.g. a class attribute named <code>storage</code> produces a backing attribute <code>_storage</code>).  Reading and writing go through <code>object.__getattribute__</code> and <code>object.__setattr__</code> rather than <code>__dict__</code> access, so the descriptor works correctly on classes that define <code>__slots__</code> as long as the backing slot is declared.</p> <p>This descriptor is public so users can reference it explicitly in custom device classes:</p> <pre><code>from sunflare.device import Device\nfrom sunflare.storage import StorageDescriptor\n\n\nclass MyDevice(Device):\n    storage = StorageDescriptor()\n</code></pre> Source code in <code>src/sunflare/storage/_proxy.py</code> <pre><code>class StorageDescriptor:\n    \"\"\"Descriptor that manages the `storage` slot on a device.\n\n    The private attribute name is derived from the descriptor's own name\n    at class-creation time via `__set_name__` (e.g. a class attribute\n    named `storage` produces a backing attribute `_storage`).  Reading\n    and writing go through `object.__getattribute__` and\n    `object.__setattr__` rather than `__dict__` access, so the descriptor\n    works correctly on classes that define `__slots__` as long as the\n    backing slot is declared.\n\n    This descriptor is public so users can reference it explicitly in\n    custom device classes:\n\n    ```python\n    from sunflare.device import Device\n    from sunflare.storage import StorageDescriptor\n\n\n    class MyDevice(Device):\n        storage = StorageDescriptor()\n    ```\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        # Fallback name used when the descriptor is instantiated outside a\n        # class body (e.g. in tests) before __set_name__ is called.\n        self._private_name: str = \"_storage\"\n\n    def __set_name__(self, owner: type, name: str) -&gt; None:\n        self._private_name = f\"_{name}\"\n\n    @overload\n    def __get__(self, obj: None, objtype: type) -&gt; StorageDescriptor: ...\n\n    @overload\n    def __get__(self, obj: Any, objtype: type | None) -&gt; StorageProxy | None: ...\n\n    def __get__(\n        self,\n        obj: Any,\n        objtype: type | None = None,\n    ) -&gt; StorageDescriptor | StorageProxy | None:\n        if obj is None:\n            return self\n        try:\n            result: StorageProxy | None = object.__getattribute__(\n                obj, self._private_name\n            )\n        except AttributeError:\n            result = None\n        return result\n\n    def __set__(self, obj: Any, value: StorageProxy | None) -&gt; None:\n        object.__setattr__(obj, self._private_name, value)\n</code></pre>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.storage.StorageProxy","level":2,"title":"StorageProxy","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol that devices use to interact with a storage backend.</p> <p>Both local <code>Writer</code> instances and future remote proxy objects implement this protocol, so device code is identical regardless of where storage lives.</p> <p>Devices access the backend via their <code>storage</code> attribute, which is <code>None</code> when no backend has been configured for the session.</p> <p>Methods:</p> Name Description <code>update_source</code> <p>Register or update a data source on the backend.</p> <code>prepare</code> <p>Prepare the backend for name and return a <code>FrameSink</code>.</p> <code>kickoff</code> <p>Open the storage backend.</p> <code>complete</code> <p>Signal that name has finished writing.</p> <code>get_indices_written</code> <p>Return the number of frames written for name.</p> <code>collect_stream_docs</code> <p>Yield Bluesky stream documents for name.</p> Source code in <code>src/sunflare/storage/_proxy.py</code> <pre><code>@runtime_checkable\nclass StorageProxy(Protocol):\n    \"\"\"Protocol that devices use to interact with a storage backend.\n\n    Both local [`Writer`][sunflare.storage.Writer] instances and future\n    remote proxy objects implement this protocol, so device code is\n    identical regardless of where storage lives.\n\n    Devices access the backend via their `storage` attribute, which is\n    `None` when no backend has been configured for the session.\n    \"\"\"\n\n    def update_source(\n        self,\n        name: str,\n        dtype: np.dtype[np.generic],\n        shape: tuple[int, ...],\n        extra: dict[str, Any] | None = None,\n    ) -&gt; None:\n        \"\"\"Register or update a data source on the backend.\"\"\"\n        ...\n\n    def prepare(self, name: str, capacity: int = 0) -&gt; FrameSink:\n        \"\"\"Prepare the backend for *name* and return a [`FrameSink`][sunflare.storage.FrameSink].\"\"\"\n        ...\n\n    def kickoff(self) -&gt; None:\n        \"\"\"Open the storage backend.\"\"\"\n        ...\n\n    def complete(self, name: str) -&gt; None:\n        \"\"\"Signal that *name* has finished writing.\"\"\"\n        ...\n\n    def get_indices_written(self, name: str | None = None) -&gt; int:\n        \"\"\"Return the number of frames written for *name*.\"\"\"\n        ...\n\n    def collect_stream_docs(\n        self,\n        name: str,\n        indices_written: int,\n    ) -&gt; Iterator[StreamAsset]:\n        \"\"\"Yield Bluesky stream documents for *name*.\"\"\"\n        ...\n</code></pre>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.storage.StorageProxy.update_source","level":3,"title":"update_source","text":"<pre><code>update_source(\n    name: str,\n    dtype: dtype[generic],\n    shape: tuple[int, ...],\n    extra: dict[str, Any] | None = None,\n) -&gt; None\n</code></pre> <p>Register or update a data source on the backend.</p> Source code in <code>src/sunflare/storage/_proxy.py</code> <pre><code>def update_source(\n    self,\n    name: str,\n    dtype: np.dtype[np.generic],\n    shape: tuple[int, ...],\n    extra: dict[str, Any] | None = None,\n) -&gt; None:\n    \"\"\"Register or update a data source on the backend.\"\"\"\n    ...\n</code></pre>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.storage.StorageProxy.prepare","level":3,"title":"prepare","text":"<pre><code>prepare(name: str, capacity: int = 0) -&gt; FrameSink\n</code></pre> <p>Prepare the backend for name and return a <code>FrameSink</code>.</p> Source code in <code>src/sunflare/storage/_proxy.py</code> <pre><code>def prepare(self, name: str, capacity: int = 0) -&gt; FrameSink:\n    \"\"\"Prepare the backend for *name* and return a [`FrameSink`][sunflare.storage.FrameSink].\"\"\"\n    ...\n</code></pre>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.storage.StorageProxy.kickoff","level":3,"title":"kickoff","text":"<pre><code>kickoff() -&gt; None\n</code></pre> <p>Open the storage backend.</p> Source code in <code>src/sunflare/storage/_proxy.py</code> <pre><code>def kickoff(self) -&gt; None:\n    \"\"\"Open the storage backend.\"\"\"\n    ...\n</code></pre>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.storage.StorageProxy.complete","level":3,"title":"complete","text":"<pre><code>complete(name: str) -&gt; None\n</code></pre> <p>Signal that name has finished writing.</p> Source code in <code>src/sunflare/storage/_proxy.py</code> <pre><code>def complete(self, name: str) -&gt; None:\n    \"\"\"Signal that *name* has finished writing.\"\"\"\n    ...\n</code></pre>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.storage.StorageProxy.get_indices_written","level":3,"title":"get_indices_written","text":"<pre><code>get_indices_written(name: str | None = None) -&gt; int\n</code></pre> <p>Return the number of frames written for name.</p> Source code in <code>src/sunflare/storage/_proxy.py</code> <pre><code>def get_indices_written(self, name: str | None = None) -&gt; int:\n    \"\"\"Return the number of frames written for *name*.\"\"\"\n    ...\n</code></pre>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.storage.StorageProxy.collect_stream_docs","level":3,"title":"collect_stream_docs","text":"<pre><code>collect_stream_docs(\n    name: str, indices_written: int\n) -&gt; Iterator[StreamAsset]\n</code></pre> <p>Yield Bluesky stream documents for name.</p> Source code in <code>src/sunflare/storage/_proxy.py</code> <pre><code>def collect_stream_docs(\n    self,\n    name: str,\n    indices_written: int,\n) -&gt; Iterator[StreamAsset]:\n    \"\"\"Yield Bluesky stream documents for *name*.\"\"\"\n    ...\n</code></pre>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.device.Device","level":2,"title":"Device","text":"<p>               Bases: <code>PDevice</code>, <code>ABC</code></p> <p>Base class for devices.</p> <p>Users may subclass from this device and implement their own configuration properties and methods.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the device. Serves as a unique identifier for the object created from it.</p> required <code>kwargs</code> <code>Any</code> <p>Additional keyword arguments for device subclasses.</p> <code>{}</code> <p>Methods:</p> Name Description <code>describe_configuration</code> <p>Provide a description of the device configuration.</p> <code>read_configuration</code> <p>Provide a description of the device configuration.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the device, serving as a unique identifier.</p> <code>parent</code> <code>None</code> <p>Parent of the device. Always returns None for compliance with <code>HasParent</code> protocol.</p> Source code in <code>src/sunflare/device/_base.py</code> <pre><code>class Device(PDevice, abc.ABC):\n    \"\"\"Base class for devices.\n\n    Users may subclass from this device and implement their own\n    configuration properties and methods.\n\n    Parameters\n    ----------\n    name : str\n        Name of the device. Serves as a unique identifier for the object created from it.\n    kwargs : Any, optional\n        Additional keyword arguments for device subclasses.\n    \"\"\"\n\n    @abc.abstractmethod\n    def __init__(self, name: str, /, **kwargs: Any) -&gt; None:\n        self._name = name\n        super().__init__(**kwargs)\n\n    @abc.abstractmethod\n    def describe_configuration(self) -&gt; dict[str, Descriptor]:\n        \"\"\"Provide a description of the device configuration.\n\n        Subclasses should override this method to provide their own\n        configuration description compatible with the Bluesky event model.\n\n        Returns\n        -------\n        dict[str, Descriptor]\n            A dictionary with the description of each field of the device configuration.\n        \"\"\"\n        raise NotImplementedError\n\n    @abc.abstractmethod\n    def read_configuration(self) -&gt; dict[str, Reading[Any]]:\n        \"\"\"Provide a description of the device configuration.\n\n        Subclasses should override this method to provide their own\n        configuration reading compatible with the Bluesky event model.\n\n        Returns\n        -------\n        dict[str, Reading[Any]]\n            A dictionary with the reading of each field of the device configuration.\n        \"\"\"\n        raise NotImplementedError\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"The name of the device, serving as a unique identifier.\"\"\"\n        return self._name\n\n    @property\n    def parent(self) -&gt; None:\n        \"\"\"Parent of the device. Always returns None for compliance with [`HasParent`]() protocol.\"\"\"\n        return None\n</code></pre>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.device.Device.name","level":3,"title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>The name of the device, serving as a unique identifier.</p>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.device.Device.parent","level":3,"title":"parent  <code>property</code>","text":"<pre><code>parent: None\n</code></pre> <p>Parent of the device. Always returns None for compliance with <code>HasParent</code> protocol.</p>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.device.Device.describe_configuration","level":3,"title":"describe_configuration  <code>abstractmethod</code>","text":"<pre><code>describe_configuration() -&gt; dict[str, Descriptor]\n</code></pre> <p>Provide a description of the device configuration.</p> <p>Subclasses should override this method to provide their own configuration description compatible with the Bluesky event model.</p> <p>Returns:</p> Type Description <code>dict[str, Descriptor]</code> <p>A dictionary with the description of each field of the device configuration.</p> Source code in <code>src/sunflare/device/_base.py</code> <pre><code>@abc.abstractmethod\ndef describe_configuration(self) -&gt; dict[str, Descriptor]:\n    \"\"\"Provide a description of the device configuration.\n\n    Subclasses should override this method to provide their own\n    configuration description compatible with the Bluesky event model.\n\n    Returns\n    -------\n    dict[str, Descriptor]\n        A dictionary with the description of each field of the device configuration.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.device.Device.read_configuration","level":3,"title":"read_configuration  <code>abstractmethod</code>","text":"<pre><code>read_configuration() -&gt; dict[str, Reading[Any]]\n</code></pre> <p>Provide a description of the device configuration.</p> <p>Subclasses should override this method to provide their own configuration reading compatible with the Bluesky event model.</p> <p>Returns:</p> Type Description <code>dict[str, Reading[Any]]</code> <p>A dictionary with the reading of each field of the device configuration.</p> Source code in <code>src/sunflare/device/_base.py</code> <pre><code>@abc.abstractmethod\ndef read_configuration(self) -&gt; dict[str, Reading[Any]]:\n    \"\"\"Provide a description of the device configuration.\n\n    Subclasses should override this method to provide their own\n    configuration reading compatible with the Bluesky event model.\n\n    Returns\n    -------\n    dict[str, Reading[Any]]\n        A dictionary with the reading of each field of the device configuration.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.device.PDevice","level":2,"title":"PDevice","text":"<p>               Bases: <code>HasName</code>, <code>HasParent</code>, <code>Configurable[Any]</code>, <code>Protocol</code></p> <p>Minimal required protocol for a recognizable device in Redsun.</p> Source code in <code>src/sunflare/device/_base.py</code> <pre><code>@runtime_checkable\nclass PDevice(HasName, HasParent, Configurable[Any], Protocol):  # pragma: no cover\n    \"\"\"Minimal required protocol for a recognizable device in Redsun.\"\"\"\n</code></pre>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.presenter.PPresenter","level":2,"title":"PPresenter","text":"<p>               Bases: <code>Protocol</code></p> <p>Presenter protocol class.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Identity key of the presenter.</p> <code>devices</code> <code>Mapping[str, Device]</code> <p>Reference to the devices used in the presenter.</p> Notes <p>Access to the virtual container is optional and should be acquired by implementing :class:<code>~sunflare.virtual.IsProvider</code> or :class:<code>~sunflare.virtual.IsInjectable</code>.</p> Source code in <code>src/sunflare/presenter/_base.py</code> <pre><code>@runtime_checkable\nclass PPresenter(Protocol):  # pragma: no cover\n    \"\"\"Presenter protocol class.\n\n    Attributes\n    ----------\n    name : str\n        Identity key of the presenter.\n    devices : Mapping[str, sunflare.device.Device]\n        Reference to the devices used in the presenter.\n\n    Notes\n    -----\n    Access to the virtual container is optional and should be acquired\n    by implementing :class:`~sunflare.virtual.IsProvider` or\n    :class:`~sunflare.virtual.IsInjectable`.\n    \"\"\"\n\n    name: str\n    devices: Mapping[str, Device]\n</code></pre>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.presenter.Presenter","level":2,"title":"Presenter","text":"<p>               Bases: <code>PPresenter</code>, <code>ABC</code></p> <p>Presenter base class.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Identity key of the presenter. Passed as positional-only argument.</p> required <code>devices</code> <code>Mapping[str, Device]</code> <p>Reference to the devices used in the presenter.</p> required <code>kwargs</code> <code>Any</code> <p>Additional keyword arguments for presenter subclasses.</p> <code>{}</code> Source code in <code>src/sunflare/presenter/_base.py</code> <pre><code>class Presenter(PPresenter, ABC):\n    \"\"\"Presenter base class.\n\n    Parameters\n    ----------\n    name : str\n        Identity key of the presenter. Passed as positional-only argument.\n    devices : Mapping[str, sunflare.device.Device]\n        Reference to the devices used in the presenter.\n    kwargs : Any, optional\n        Additional keyword arguments for presenter subclasses.\n    \"\"\"\n\n    @abstractmethod\n    def __init__(\n        self,\n        name: str,\n        devices: Mapping[str, Device],\n        /,\n        **kwargs: Any,\n    ) -&gt; None:\n        self.name = name\n        self.devices = devices\n        super().__init__(**kwargs)\n</code></pre>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.virtual.CallbackType","level":2,"title":"CallbackType  <code>module-attribute</code>","text":"<pre><code>CallbackType: TypeAlias = (\n    Callable[[str, Document], None] | DocumentRouter\n)\n</code></pre> <p>Type alias for document callback functions.</p>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.virtual.SignalCache","level":2,"title":"SignalCache  <code>module-attribute</code>","text":"<pre><code>SignalCache: TypeAlias = dict[str, SignalInstance]\n</code></pre> <p>Cache type for storing signal instances registered from component classes.</p>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.virtual.RedSunConfig","level":2,"title":"RedSunConfig","text":"<p>               Bases: <code>TypedDict</code></p> <p>Base configuration schema for Redsun applications.</p> <p>Parameters:</p> Name Type Description Default <code>schema_version</code> <code>Required[float]</code> <p>An enumeration.</p> required <code>frontend</code> <code>Required[str]</code> <p>An enumeration.</p> required <code>session</code> <code>NotRequired[str]</code> <p>An enumeration.</p> required <code>metadata</code> <code>NotRequired[dict[str, Any]]</code> <p>An enumeration.</p> required <p>Attributes:</p> Name Type Description <code>schema_version</code> <code>Required[float]</code> <p>Plugin schema version.</p> <code>frontend</code> <code>Required[str]</code> <p>Frontend toolkit identifier (e.g. <code>\"pyqt\"</code>, <code>\"pyside\"</code>).</p> <code>session</code> <code>NotRequired[str]</code> <p>Session display name. If not provided, default is <code>\"redsun\"</code>.</p> <code>metadata</code> <code>NotRequired[dict[str, Any]]</code> <p>Additional session-specific metadata to include in the configuration.</p> Source code in <code>src/sunflare/virtual/_config.py</code> <pre><code>class RedSunConfig(TypedDict, total=False):\n    \"\"\"Base configuration schema for Redsun applications.\"\"\"\n\n    schema_version: Required[float]\n    \"\"\"Plugin schema version.\"\"\"\n\n    frontend: Required[str]\n    \"\"\"Frontend toolkit identifier (e.g. `\"pyqt\"`, `\"pyside\"`).\"\"\"\n\n    session: NotRequired[str]\n    \"\"\"Session display name. If not provided, default is `\"redsun\"`.\"\"\"\n\n    metadata: NotRequired[dict[str, Any]]\n    \"\"\"Additional session-specific metadata to include in the configuration.\"\"\"\n</code></pre>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.virtual.RedSunConfig.schema_version","level":3,"title":"schema_version  <code>instance-attribute</code>","text":"<pre><code>schema_version: Required[float]\n</code></pre> <p>Plugin schema version.</p>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.virtual.RedSunConfig.frontend","level":3,"title":"frontend  <code>instance-attribute</code>","text":"<pre><code>frontend: Required[str]\n</code></pre> <p>Frontend toolkit identifier (e.g. <code>\"pyqt\"</code>, <code>\"pyside\"</code>).</p>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.virtual.RedSunConfig.session","level":3,"title":"session  <code>instance-attribute</code>","text":"<pre><code>session: NotRequired[str]\n</code></pre> <p>Session display name. If not provided, default is <code>\"redsun\"</code>.</p>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.virtual.RedSunConfig.metadata","level":3,"title":"metadata  <code>instance-attribute</code>","text":"<pre><code>metadata: NotRequired[dict[str, Any]]\n</code></pre> <p>Additional session-specific metadata to include in the configuration.</p>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.virtual.VirtualContainer","level":2,"title":"VirtualContainer","text":"<p>               Bases: <code>DynamicContainer</code>, <code>Loggable</code></p> <p>Data exchange and dependency injection layer.</p> <p><code>VirtualContainer</code> is a <code>DynamicContainer</code> that also acts as a runtime signal bus and data sharing layer for an application.</p> <p>Methods:</p> Name Description <code>register_signals</code> <p>Register the signals of an object in the virtual container.</p> <code>register_callbacks</code> <p>Register one or more document callbacks in the virtual container.</p> <p>Attributes:</p> Name Type Description <code>schema_version</code> <code>float</code> <p>The plugin schema version specified in the configuration.</p> <code>frontend</code> <code>str</code> <p>The frontend toolkit identifier specified in the configuration.</p> <code>session</code> <code>str</code> <p>The session display name specified in the configuration.</p> <code>metadata</code> <code>dict[str, object]</code> <p>The session metadata specified in the configuration.</p> <code>callbacks</code> <code>dict[str, CallbackType]</code> <p>The currently registered document callbacks.</p> <code>signals</code> <code>dict[str, SignalCache]</code> <p>The currently registered signals.</p> Source code in <code>src/sunflare/virtual/_container.py</code> <pre><code>class VirtualContainer(dic.DynamicContainer, Loggable):\n    \"\"\"Data exchange and dependency injection layer.\n\n    `VirtualContainer` is a [`DynamicContainer`][dependency_injector.containers.DynamicContainer]\n    that also acts as a runtime signal bus and data sharing layer for an application.\n    \"\"\"\n\n    _signals = dip.Factory(dict[str, SignalCache])\n    _callbacks = dip.Factory(dict[str, CallbackType])\n    _config = dip.Singleton(_FrozenConfig)\n\n    @property\n    def schema_version(self) -&gt; float:\n        \"\"\"The plugin schema version specified in the configuration.\"\"\"\n        return self._config().schema_version\n\n    @property\n    def frontend(self) -&gt; str:\n        \"\"\"The frontend toolkit identifier specified in the configuration.\"\"\"\n        return self._config().frontend\n\n    @property\n    def session(self) -&gt; str:\n        \"\"\"The session display name specified in the configuration.\"\"\"\n        return self._config().session\n\n    @property\n    def metadata(self) -&gt; dict[str, object]:\n        \"\"\"The session metadata specified in the configuration.\"\"\"\n        return self._config().metadata\n\n    def _set_configuration(self, config: RedSunConfig) -&gt; None:\n        \"\"\"Set the application configuration.\n\n        Private for use by the application layer at build time.\n\n        Parameters\n        ----------\n        config : RedSunConfig\n            The application configuration to set.\n        \"\"\"\n        self._config.set_kwargs(\n            schema_version=config[\"schema_version\"],\n            frontend=config[\"frontend\"],\n            session=config.get(\"session\", \"redsun\"),\n            metadata=config.get(\"metadata\", {}),\n        )\n\n    def register_signals(\n        self, owner: HasName, name: str | None = None, only: Iterable[str] | None = None\n    ) -&gt; None:\n        \"\"\"Register the signals of an object in the virtual container.\n\n        Parameters\n        ----------\n        owner : HasName\n            The instance whose class's signals are to be cached.\n            Must provide a `name` attribute.\n        name : str | None\n            An optional name to use as the key for caching the signals.\n            If not provided, the `name` of `owner` will be used.\n        only : Iterable[str], optional\n            A list of signal names to cache. If not provided, all\n            signals in the class will be cached automatically by inspecting\n            the class attributes.\n\n        Notes\n        -----\n        This method inspects the attributes of the owner's class to find\n        [`psygnal.Signal`][psygnal.Signal] descriptors. For each such descriptor, it\n        retrieves the [`psygnal.SignalInstance`][psygnal.SignalInstance] from the owner using\n        the descriptor protocol and stores it in the registry.\n        \"\"\"\n        owner_class = type(owner)\n        if name is not None:\n            cache_entry = name\n        else:\n            cache_entry = owner.name\n\n        if only is None:\n            only = [\n                name\n                for name in dir(owner_class)\n                if isinstance(getattr(owner_class, name, None), Signal)\n            ]\n\n        batch: dict[str, SignalInstance] = {}\n        for name in only:\n            signal_descriptor = getattr(owner_class, name, None)\n            if isinstance(signal_descriptor, Signal):\n                signal_instance = getattr(owner, name)\n                batch[name] = signal_instance\n        if batch:\n            self._signals.add_kwargs(**{cache_entry: batch})\n\n    @staticmethod\n    def _validate_callback(callback: object) -&gt; CallbackType:\n        \"\"\"Validate that *callback* is an acceptable ``CallbackType``.\n\n        Parameters\n        ----------\n        callback :\n            The object to validate.\n\n        Returns\n        -------\n        CallbackType\n            The validated callback, unchanged.\n\n        Raises\n        ------\n        TypeError\n            If *callback* is not callable, or if it is a callable but\n            its call signature is not compatible with ``(str, Document)``.\n        \"\"\"\n        if isinstance(callback, DocumentRouter):\n            return callback\n\n        if not callable(callback):\n            raise TypeError(\n                f\"{callback!r} is not callable. \"\n                \"A callback must be a DocumentRouter subclass instance or a \"\n                \"callable accepting (str, Document) arguments.\"\n            )\n\n        try:\n            inspect.signature(callback.__call__).bind(None, None)\n        except TypeError as e:\n            raise TypeError(\n                f\"{callback!r} is callable but its signature is not compatible \"\n                \"with the expected (str, Document) callback interface.\"\n            ) from e\n\n        return callback\n\n    def register_callbacks(\n        self,\n        owner: HasName,\n        name: str | None = None,\n        callback_map: dict[str, CallbackType] | None = None,\n    ) -&gt; None:\n        \"\"\"Register one or more document callbacks in the virtual container.\n\n        Accepts any object that is a valid ``CallbackType`` and exposes a\n        ``name`` attribute used as the registry key.  Two forms are supported:\n\n        * A [DocumentRouter][event_model.DocumentRouter] subclass instance;\n        * Any other object that implements ``__call__(self, name, doc)`` with\n          the correct two-parameter signature.\n\n        When *callback_map* is provided the owner itself is not registered;\n        instead each entry in the mapping is validated and registered\n        independently under its own key, allowing a single owner to expose\n        multiple callbacks.\n\n        Parameters\n        ----------\n        owner : HasName\n            The component registering callbacks.  Must expose a ``name``\n            attribute.  When *callback_map* is ``None``, *owner* itself is\n            registered as the callback.\n        name : str | None\n            Override for the registry key used when registering *owner*\n            directly.  Ignored when *callback_map* is provided.\n            Defaults to ``owner.name``.\n        callback_map : dict[str, CallbackType] | None\n            Optional mapping of registry key to callback object.  When\n            supplied, each value is validated and registered under its\n            corresponding key; *name* is ignored.\n\n        Raises\n        ------\n        TypeError\n            If a callback is not callable or its signature is incompatible\n            with ``(str, Document)``.\n        \"\"\"\n        if callback_map is not None:\n            for key, callback in callback_map.items():\n                self._callbacks.add_kwargs(**{key: self._validate_callback(callback)})\n            return\n\n        cache_entry = name if name is not None else owner.name\n        self._callbacks.add_kwargs(**{cache_entry: self._validate_callback(owner)})\n\n    @property\n    def callbacks(self) -&gt; dict[str, CallbackType]:\n        \"\"\"The currently registered document callbacks.\"\"\"\n        return self._callbacks()\n\n    @property\n    def signals(self) -&gt; dict[str, SignalCache]:\n        \"\"\"The currently registered signals.\"\"\"\n        return self._signals()\n</code></pre>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.virtual.VirtualContainer.schema_version","level":3,"title":"schema_version  <code>property</code>","text":"<pre><code>schema_version: float\n</code></pre> <p>The plugin schema version specified in the configuration.</p>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.virtual.VirtualContainer.frontend","level":3,"title":"frontend  <code>property</code>","text":"<pre><code>frontend: str\n</code></pre> <p>The frontend toolkit identifier specified in the configuration.</p>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.virtual.VirtualContainer.session","level":3,"title":"session  <code>property</code>","text":"<pre><code>session: str\n</code></pre> <p>The session display name specified in the configuration.</p>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.virtual.VirtualContainer.metadata","level":3,"title":"metadata  <code>property</code>","text":"<pre><code>metadata: dict[str, object]\n</code></pre> <p>The session metadata specified in the configuration.</p>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.virtual.VirtualContainer.callbacks","level":3,"title":"callbacks  <code>property</code>","text":"<pre><code>callbacks: dict[str, CallbackType]\n</code></pre> <p>The currently registered document callbacks.</p>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.virtual.VirtualContainer.signals","level":3,"title":"signals  <code>property</code>","text":"<pre><code>signals: dict[str, SignalCache]\n</code></pre> <p>The currently registered signals.</p>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.virtual.VirtualContainer.register_signals","level":3,"title":"register_signals","text":"<pre><code>register_signals(\n    owner: HasName,\n    name: str | None = None,\n    only: Iterable[str] | None = None,\n) -&gt; None\n</code></pre> <p>Register the signals of an object in the virtual container.</p> <p>Parameters:</p> Name Type Description Default <code>owner</code> <code>HasName</code> <p>The instance whose class's signals are to be cached. Must provide a <code>name</code> attribute.</p> required <code>name</code> <code>str | None</code> <p>An optional name to use as the key for caching the signals. If not provided, the <code>name</code> of <code>owner</code> will be used.</p> <code>None</code> <code>only</code> <code>Iterable[str]</code> <p>A list of signal names to cache. If not provided, all signals in the class will be cached automatically by inspecting the class attributes.</p> <code>None</code> Notes <p>This method inspects the attributes of the owner's class to find <code>psygnal.Signal</code> descriptors. For each such descriptor, it retrieves the <code>psygnal.SignalInstance</code> from the owner using the descriptor protocol and stores it in the registry.</p> Source code in <code>src/sunflare/virtual/_container.py</code> <pre><code>def register_signals(\n    self, owner: HasName, name: str | None = None, only: Iterable[str] | None = None\n) -&gt; None:\n    \"\"\"Register the signals of an object in the virtual container.\n\n    Parameters\n    ----------\n    owner : HasName\n        The instance whose class's signals are to be cached.\n        Must provide a `name` attribute.\n    name : str | None\n        An optional name to use as the key for caching the signals.\n        If not provided, the `name` of `owner` will be used.\n    only : Iterable[str], optional\n        A list of signal names to cache. If not provided, all\n        signals in the class will be cached automatically by inspecting\n        the class attributes.\n\n    Notes\n    -----\n    This method inspects the attributes of the owner's class to find\n    [`psygnal.Signal`][psygnal.Signal] descriptors. For each such descriptor, it\n    retrieves the [`psygnal.SignalInstance`][psygnal.SignalInstance] from the owner using\n    the descriptor protocol and stores it in the registry.\n    \"\"\"\n    owner_class = type(owner)\n    if name is not None:\n        cache_entry = name\n    else:\n        cache_entry = owner.name\n\n    if only is None:\n        only = [\n            name\n            for name in dir(owner_class)\n            if isinstance(getattr(owner_class, name, None), Signal)\n        ]\n\n    batch: dict[str, SignalInstance] = {}\n    for name in only:\n        signal_descriptor = getattr(owner_class, name, None)\n        if isinstance(signal_descriptor, Signal):\n            signal_instance = getattr(owner, name)\n            batch[name] = signal_instance\n    if batch:\n        self._signals.add_kwargs(**{cache_entry: batch})\n</code></pre>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.virtual.VirtualContainer.register_callbacks","level":3,"title":"register_callbacks","text":"<pre><code>register_callbacks(\n    owner: HasName,\n    name: str | None = None,\n    callback_map: dict[str, CallbackType] | None = None,\n) -&gt; None\n</code></pre> <p>Register one or more document callbacks in the virtual container.</p> <p>Accepts any object that is a valid <code>CallbackType</code> and exposes a <code>name</code> attribute used as the registry key.  Two forms are supported:</p> <ul> <li>A DocumentRouter subclass instance;</li> <li>Any other object that implements <code>__call__(self, name, doc)</code> with   the correct two-parameter signature.</li> </ul> <p>When callback_map is provided the owner itself is not registered; instead each entry in the mapping is validated and registered independently under its own key, allowing a single owner to expose multiple callbacks.</p> <p>Parameters:</p> Name Type Description Default <code>owner</code> <code>HasName</code> <p>The component registering callbacks.  Must expose a <code>name</code> attribute.  When callback_map is <code>None</code>, owner itself is registered as the callback.</p> required <code>name</code> <code>str | None</code> <p>Override for the registry key used when registering owner directly.  Ignored when callback_map is provided. Defaults to <code>owner.name</code>.</p> <code>None</code> <code>callback_map</code> <code>dict[str, CallbackType] | None</code> <p>Optional mapping of registry key to callback object.  When supplied, each value is validated and registered under its corresponding key; name is ignored.</p> <code>None</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>If a callback is not callable or its signature is incompatible with <code>(str, Document)</code>.</p> Source code in <code>src/sunflare/virtual/_container.py</code> <pre><code>def register_callbacks(\n    self,\n    owner: HasName,\n    name: str | None = None,\n    callback_map: dict[str, CallbackType] | None = None,\n) -&gt; None:\n    \"\"\"Register one or more document callbacks in the virtual container.\n\n    Accepts any object that is a valid ``CallbackType`` and exposes a\n    ``name`` attribute used as the registry key.  Two forms are supported:\n\n    * A [DocumentRouter][event_model.DocumentRouter] subclass instance;\n    * Any other object that implements ``__call__(self, name, doc)`` with\n      the correct two-parameter signature.\n\n    When *callback_map* is provided the owner itself is not registered;\n    instead each entry in the mapping is validated and registered\n    independently under its own key, allowing a single owner to expose\n    multiple callbacks.\n\n    Parameters\n    ----------\n    owner : HasName\n        The component registering callbacks.  Must expose a ``name``\n        attribute.  When *callback_map* is ``None``, *owner* itself is\n        registered as the callback.\n    name : str | None\n        Override for the registry key used when registering *owner*\n        directly.  Ignored when *callback_map* is provided.\n        Defaults to ``owner.name``.\n    callback_map : dict[str, CallbackType] | None\n        Optional mapping of registry key to callback object.  When\n        supplied, each value is validated and registered under its\n        corresponding key; *name* is ignored.\n\n    Raises\n    ------\n    TypeError\n        If a callback is not callable or its signature is incompatible\n        with ``(str, Document)``.\n    \"\"\"\n    if callback_map is not None:\n        for key, callback in callback_map.items():\n            self._callbacks.add_kwargs(**{key: self._validate_callback(callback)})\n        return\n\n    cache_entry = name if name is not None else owner.name\n    self._callbacks.add_kwargs(**{cache_entry: self._validate_callback(owner)})\n</code></pre>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.virtual.HasShutdown","level":2,"title":"HasShutdown","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol marking your class as capable of shutting down.</p> <p>Methods:</p> Name Description <code>shutdown</code> <p>Shutdown an object. Performs cleanup operations.</p> Source code in <code>src/sunflare/virtual/_protocols.py</code> <pre><code>@runtime_checkable\nclass HasShutdown(Protocol):  # pragma: no cover\n    \"\"\"Protocol marking your class as capable of shutting down.\"\"\"\n\n    @abstractmethod\n    def shutdown(self) -&gt; None:\n        \"\"\"Shutdown an object. Performs cleanup operations.\"\"\"\n        ...\n</code></pre>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.virtual.HasShutdown.shutdown","level":3,"title":"shutdown  <code>abstractmethod</code>","text":"<pre><code>shutdown() -&gt; None\n</code></pre> <p>Shutdown an object. Performs cleanup operations.</p> Source code in <code>src/sunflare/virtual/_protocols.py</code> <pre><code>@abstractmethod\ndef shutdown(self) -&gt; None:\n    \"\"\"Shutdown an object. Performs cleanup operations.\"\"\"\n    ...\n</code></pre>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.virtual.IsInjectable","level":2,"title":"IsInjectable","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol marking a class as injectable with dependencies from the container.</p> <p>Methods:</p> Name Description <code>inject_dependencies</code> <p>Inject dependencies from the container.</p> Source code in <code>src/sunflare/virtual/_protocols.py</code> <pre><code>@runtime_checkable\nclass IsInjectable(Protocol):  # pragma: no cover\n    \"\"\"Protocol marking a class as injectable with dependencies from the container.\"\"\"\n\n    @abstractmethod\n    def inject_dependencies(self, container: VirtualContainer) -&gt; None:\n        \"\"\"Inject dependencies from the container.\"\"\"\n        ...\n</code></pre>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.virtual.IsInjectable.inject_dependencies","level":3,"title":"inject_dependencies  <code>abstractmethod</code>","text":"<pre><code>inject_dependencies(container: VirtualContainer) -&gt; None\n</code></pre> <p>Inject dependencies from the container.</p> Source code in <code>src/sunflare/virtual/_protocols.py</code> <pre><code>@abstractmethod\ndef inject_dependencies(self, container: VirtualContainer) -&gt; None:\n    \"\"\"Inject dependencies from the container.\"\"\"\n    ...\n</code></pre>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.virtual.IsProvider","level":2,"title":"IsProvider","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol marking a class as a provider of dependencies.</p> <p>Methods:</p> Name Description <code>register_providers</code> <p>Register providers in the virtual container.</p> Source code in <code>src/sunflare/virtual/_protocols.py</code> <pre><code>@runtime_checkable\nclass IsProvider(Protocol):  # pragma: no cover\n    \"\"\"Protocol marking a class as a provider of dependencies.\"\"\"\n\n    @abstractmethod\n    def register_providers(self, container: VirtualContainer) -&gt; None:\n        \"\"\"Register providers in the virtual container.\"\"\"\n        ...\n</code></pre>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.virtual.IsProvider.register_providers","level":3,"title":"register_providers  <code>abstractmethod</code>","text":"<pre><code>register_providers(container: VirtualContainer) -&gt; None\n</code></pre> <p>Register providers in the virtual container.</p> Source code in <code>src/sunflare/virtual/_protocols.py</code> <pre><code>@abstractmethod\ndef register_providers(self, container: VirtualContainer) -&gt; None:\n    \"\"\"Register providers in the virtual container.\"\"\"\n    ...\n</code></pre>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.view.PView","level":2,"title":"PView","text":"<p>               Bases: <code>Protocol</code></p> <p>Minimal protocol a view component should implement.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Identity key of the view.</p> Notes <p>Access to the virtual container is optional and should be acquired by implementing :class:<code>~sunflare.virtual.IsInjectable</code>.</p> Source code in <code>src/sunflare/view/_base.py</code> <pre><code>@runtime_checkable\nclass PView(Protocol):\n    \"\"\"Minimal protocol a view component should implement.\n\n    Attributes\n    ----------\n    name : str\n        Identity key of the view.\n\n    Notes\n    -----\n    Access to the virtual container is optional and should be acquired\n    by implementing :class:`~sunflare.virtual.IsInjectable`.\n    \"\"\"\n\n    name: str\n\n    @property\n    @abstractmethod\n    def view_position(self) -&gt; ViewPosition:\n        \"\"\"Position of the view component in the main view of the UI.\"\"\"\n</code></pre>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.view.PView.view_position","level":3,"title":"view_position  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>view_position: ViewPosition\n</code></pre> <p>Position of the view component in the main view of the UI.</p>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.view.View","level":2,"title":"View","text":"<p>               Bases: <code>PView</code>, <code>ABC</code></p> <p>Base view class.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Identity key of the view. Passed as positional-only argument.</p> required <code>kwargs</code> <code>``Any``</code> <p>Additional keyword arguments for view subclasses.</p> <code>{}</code> <p>Attributes:</p> Name Type Description <code>view_position</code> <code>ViewPosition</code> <p>Position of the view component in the main view of the UI.</p> Source code in <code>src/sunflare/view/_base.py</code> <pre><code>class View(PView, ABC):\n    \"\"\"Base view class.\n\n    Parameters\n    ----------\n    name : str\n        Identity key of the view. Passed as positional-only argument.\n    kwargs : ``Any``, optional\n        Additional keyword arguments for view subclasses.\n    \"\"\"\n\n    @abstractmethod\n    def __init__(\n        self,\n        name: str,\n        /,\n        **kwargs: Any,\n    ) -&gt; None:\n        self.name = name\n        super().__init__(**kwargs)\n\n    @property\n    @abstractmethod\n    def view_position(self) -&gt; ViewPosition:\n        \"\"\"Position of the view component in the main view of the UI.\"\"\"\n</code></pre>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.view.View.view_position","level":3,"title":"view_position  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>view_position: ViewPosition\n</code></pre> <p>Position of the view component in the main view of the UI.</p>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.view.ViewPosition","level":2,"title":"ViewPosition","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Supported view positions.</p> <p>Used to define the position of a view component in the main view of the UI.</p> <p>Warning</p> <p>These values are based on how Qt manages dock widgets. They may change in the future.</p> <p>Attributes:</p> Name Type Description <code>CENTER</code> <code>str</code> <p>Center view position.</p> <code>LEFT</code> <code>str</code> <p>Left view position.</p> <code>RIGHT</code> <code>str</code> <p>Right view position.</p> <code>TOP</code> <code>str</code> <p>Top view position.</p> <code>BOTTOM</code> <code>str</code> <p>Bottom view position.</p> Source code in <code>src/sunflare/view/__init__.py</code> <pre><code>@unique\nclass ViewPosition(str, Enum):\n    \"\"\"Supported view positions.\n\n    Used to define the position of a view component in the main view of the UI.\n\n    !!! warning\n        These values are based on how Qt manages dock widgets.\n        They may change in the future.\n\n    Attributes\n    ----------\n    CENTER : str\n        Center view position.\n    LEFT : str\n        Left view position.\n    RIGHT : str\n        Right view position.\n    TOP : str\n        Top view position.\n    BOTTOM : str\n        Bottom view position.\n    \"\"\"\n\n    CENTER = \"center\"\n    LEFT = \"left\"\n    RIGHT = \"right\"\n    TOP = \"top\"\n    BOTTOM = \"bottom\"\n</code></pre>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.log.Loggable","level":2,"title":"Loggable","text":"<p>Mixin class that adds a logger to a class instance with extra contextual information.</p> <p>Attributes:</p> Name Type Description <code>logger</code> <code>_LoggerAdapter</code> <p>Logger instance with contextual information.</p> Source code in <code>src/sunflare/log.py</code> <pre><code>class Loggable:\n    \"\"\"Mixin class that adds a logger to a class instance with extra contextual information.\"\"\"\n\n    @cached_property\n    def logger(self) -&gt; _LoggerAdapter:\n        \"\"\"Logger instance with contextual information.\"\"\"\n        return ContextualAdapter(logging.getLogger(\"redsun\"), self)\n</code></pre>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.log.Loggable.logger","level":3,"title":"logger  <code>cached</code> <code>property</code>","text":"<pre><code>logger: _LoggerAdapter\n</code></pre> <p>Logger instance with contextual information.</p>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.engine.Status","level":2,"title":"Status","text":"<p>               Bases: <code>Status</code></p> <p>Track the status of a potentially-lengthy action like moving or triggering.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>float | None</code> <p>The amount of time to wait before marking the Status as failed.  If <code>None</code> (default) wait forever. It is strongly encouraged to set a finite timeout.  If settle_time below is set, that time is added to the effective timeout.</p> <code>None</code> <code>settle_time</code> <code>float | None</code> <p>The amount of time to wait between the caller specifying that the status has completed to running callbacks. Default is 0.</p> <code>0</code> Notes <p>Theory of operation:</p> <p>This employs two <code>threading.Event</code> objects, one thread that runs for (timeout + settle_time) seconds, and one thread that runs for settle_time seconds (if settle_time is nonzero).</p> <p>At init time, a timeout and settle_time are specified. A thread is started, on which user callbacks, registered after init time via <code>add_callback</code>, will eventually be run. The thread waits on an Event be set or (timeout + settle_time) seconds to pass, whichever happens first.</p> <p>If (timeout + settle_time) expires and the Event has not been set, an internal Exception is set to <code>StatusTimeoutError</code>, and a second Event is set, marking the Status as done and failed. The callbacks are run.</p> <p>If a callback is registered after the Status is done, it will be run immediately.</p> <p>If the first Event is set before (timeout + settle_time) expires, then the second Event is set and no internal Exception is set, marking the Status as done and successful. The callbacks are run.</p> <p>There are two methods that directly set the first Event. One, <code>set_exception</code>, sets it directly after setting the internal Exception.  The other, <code>set_finished</code>, starts a <code>threading.Timer</code> that will set it after a delay (the settle_time). One of these methods may be called, and at most once. If one is called twice or if both are called, <code>InvalidState</code> is raised. If they are called too late to prevent a <code>StatusTimeoutError</code>, they are ignored but one call is still allowed. Thus, an external callback, e.g. pyepics, may reports success or failure after the Status object has expired, but to no effect because the callbacks have already been called and the program has moved on.</p> <p>Methods:</p> Name Description <code>set_exception</code> <p>Mark as finished but failed with the given Exception.</p> <code>set_finished</code> <p>Mark as finished successfully.</p> <code>exception</code> <p>Return the exception raised by the action.</p> <code>wait</code> <p>Block until the action completes.</p> <code>add_callback</code> <p>Register a callback to be called once when the Status finishes.</p> <p>Attributes:</p> Name Type Description <code>timeout</code> <code>float | None</code> <p>The timeout for this action.</p> <code>settle_time</code> <code>float</code> <p>A delay between when <code>set_finished</code> is when the Status is done.</p> <code>done</code> <code>bool</code> <p>Boolean indicating whether associated operation has completed.</p> <code>success</code> <code>bool</code> <p>Boolean indicating whether associated operation has completed.</p> <code>callbacks</code> <code>deque[Callable[[Status], None]]</code> <p>Callbacks to be run when the status is marked as finished.</p> Source code in <code>src/sunflare/engine/_status.py</code> <pre><code>class Status(PStatus):\n    \"\"\"\n    Track the status of a potentially-lengthy action like moving or triggering.\n\n    Parameters\n    ----------\n    timeout: float, optional\n        The amount of time to wait before marking the Status as failed.  If\n        ``None`` (default) wait forever. It is strongly encouraged to set a\n        finite timeout.  If settle_time below is set, that time is added to the\n        effective timeout.\n    settle_time: float, optional\n        The amount of time to wait between the caller specifying that the\n        status has completed to running callbacks. Default is 0.\n\n    Notes\n    -----\n    Theory of operation:\n\n    This employs two ``threading.Event`` objects, one thread that runs for\n    (timeout + settle_time) seconds, and one thread that runs for\n    settle_time seconds (if settle_time is nonzero).\n\n    At __init__ time, a *timeout* and *settle_time* are specified. A thread\n    is started, on which user callbacks, registered after __init__ time via\n    [`add_callback`](), will eventually be run. The thread waits on an\n    Event be set or (timeout + settle_time) seconds to pass, whichever\n    happens first.\n\n    If (timeout + settle_time) expires and the Event has not\n    been set, an internal Exception is set to ``StatusTimeoutError``, and a\n    second Event is set, marking the Status as done and failed. The\n    callbacks are run.\n\n    If a callback is registered after the Status is done, it will be run\n    immediately.\n\n    If the first Event is set before (timeout + settle_time) expires,\n    then the second Event is set and no internal Exception is set, marking\n    the Status as done and successful. The callbacks are run.\n\n    There are two methods that directly set the first Event. One,\n    [`set_exception`](), sets it directly after setting the internal\n    Exception.  The other, [`set_finished`](), starts a\n    ``threading.Timer`` that will set it after a delay (the settle_time).\n    One of these methods may be called, and at most once. If one is called\n    twice or if both are called, ``InvalidState`` is raised. If they are\n    called too late to prevent a ``StatusTimeoutError``, they are ignored\n    but one call is still allowed. Thus, an external callback, e.g. pyepics,\n    may reports success or failure after the Status object has expired, but\n    to no effect because the callbacks have already been called and the\n    program has moved on.\n    \"\"\"\n\n    def __init__(self, *, timeout: float | None = None, settle_time: float | None = 0):\n        super().__init__()\n        self._logger = logging.getLogger(\"redsun\")\n        self._tname = None\n        self._lock = threading.RLock()\n        self._event = threading.Event()  # state associated with done-ness\n        self._settled_event = threading.Event()\n        # \"Externally initiated\" means set_finished() or set_exception(exc) was\n        # called, as opposed to completion via an internal timeout.\n        self._externally_initiated_completion_lock = threading.Lock()\n        self._externally_initiated_completion = False\n        self._callbacks: deque[Callable[[Status], None]] = deque()\n        self._exception: BaseException | None = None\n\n        if settle_time is None:\n            settle_time = 0.0\n\n        self._settle_time = float(settle_time)\n\n        if timeout is not None:\n            timeout = float(timeout)\n        self._timeout = timeout\n\n        self._callback_thread = threading.Thread(\n            target=self._run_callbacks, daemon=True, name=self._tname\n        )\n        self._callback_thread.start()\n\n    @property\n    def timeout(self) -&gt; float | None:\n        \"\"\"The timeout for this action.\n\n        This is set when the Status is created, and it cannot be changed.\n        \"\"\"\n        return self._timeout\n\n    @property\n    def settle_time(self) -&gt; float:\n        \"\"\"A delay between when [`set_finished`]() is when the Status is done.\n\n        This is set when the Status is created, and it cannot be changed.\n        \"\"\"\n        return self._settle_time\n\n    @property\n    def done(self) -&gt; bool:\n        \"\"\"Boolean indicating whether associated operation has completed.\n\n        This is set to True at __init__ time or by calling\n        [`set_finished`](), [`set_exception`]().\n        Once True, it can never become False.\n        \"\"\"\n        return self._event.is_set()\n\n    @property\n    def success(self) -&gt; bool:\n        \"\"\"Boolean indicating whether associated operation has completed.\n\n        This is set to True at __init__ time or by calling\n        [`set_finished`](), [`set_exception`]()\n        . Once True, it can never become False.\n        \"\"\"\n        return self.done and self._exception is None\n\n    def _handle_failure(self) -&gt; None:\n        \"\"\"Do something if an exception occurred during the action.\"\"\"\n        # TODO: implement this; maybe ophyd has a good example\n        pass\n\n    def _settled(self) -&gt; None:\n        \"\"\"Connect to this this when status has completed and settled.\"\"\"\n        # TODO: implement this; maybe ophyd has a good example\n        pass\n\n    def _run_callbacks(self) -&gt; None:\n        \"\"\"Set the Event and run the callbacks.\"\"\"\n        if self.timeout is None:\n            timeout = None\n        else:\n            timeout = self.timeout + self.settle_time\n        if not self._settled_event.wait(timeout):\n            # We have timed out. It's possible that set_finished() has already\n            # been called but we got here before the settle_time timer expired.\n            # And it's possible that in this space be between the above\n            # statement timing out grabbing the lock just below,\n            # set_exception(exc) has been called. Both of these possibilties\n            # are accounted for.\n            self._logger.warning(\"%r has timed out\", self)\n            with self._externally_initiated_completion_lock:\n                # Set the exception and mark the Status as done, unless\n                # set_exception(exc) was called externally before we grabbed\n                # the lock.\n                if self._exception is None:\n                    exc = StatusTimeoutError(\n                        f\"Status {self!r} failed to complete in specified timeout.\"\n                    )\n                    self._exception = exc\n        # Mark this as \"settled\".\n        try:\n            self._settled()\n        except Exception:\n            # No alternative but to log this. We can't supersede set_exception,\n            # and we have to continue and run the callbacks.\n            self._logger.exception(\"%r encountered error during _settled()\", self)\n        # Now we know whether or not we have succeed or failed, either by\n        # timeout above or by set_exception(exc), so we can set the Event that\n        # will mark this Status as done.\n        with self._lock:\n            self._event.set()\n        if self._exception is not None:\n            try:\n                self._handle_failure()\n            except Exception:\n                self._logger.exception(\n                    \"%r encountered an error during _handle_failure()\", self\n                )\n        # The callbacks have access to self, from which they can distinguish\n        # success or failure.\n        for cb in self._callbacks:\n            try:\n                cb(self)\n            except Exception:\n                self._logger.exception(\n                    \"An error was raised on a background thread while \"\n                    \"running the callback %r(%r).\",\n                    cb,\n                    self,\n                )\n        self._callbacks.clear()\n\n    def set_exception(self, exc: BaseException) -&gt; None:\n        \"\"\"Mark as finished but failed with the given Exception.\n\n        This method should generally not be called by the *recipient* of this\n        Status object, but only by the object that created and returned it.\n\n        Parameters\n        ----------\n        exc: BaseException\n            The exception that caused the failure.\n        \"\"\"\n        # Since we rely on this being raise-able later, check proactively to\n        # avoid potentially very confusing failures.\n        if not (isinstance(exc, BaseException)):\n            # Note that Python allows `raise Exception` or raise Exception()`\n            # so we allow a class or an instance here too.\n            raise ValueError(f\"Expected an Exception, got {exc!r}\")\n\n        # Ban certain Timeout subclasses that have special significance. This\n        # would probably never come up except due to some rare user error, but\n        # if it did it could be very confusing indeed!\n        for exc_class in (StatusTimeoutError, WaitTimeoutError):\n            if isinstance(exc, exc_class):\n                raise ValueError(\n                    f\"{exc_class} has special significance and cannot be set \"\n                    \"as the exception. Use a plain TimeoutError or some other \"\n                    \"subclass thereof.\"\n                )\n\n        with self._externally_initiated_completion_lock:\n            if self._externally_initiated_completion:\n                raise InvalidState(\n                    \"Either set_finished() or set_exception() has \"\n                    f\"already been called on {self!r}\"\n                )\n            self._externally_initiated_completion = True\n            if isinstance(self._exception, StatusTimeoutError):\n                # We have already timed out.\n                return\n            self._exception = exc\n            self._settled_event.set()\n\n    def set_finished(self) -&gt; None:\n        \"\"\"Mark as finished successfully.\n\n        This method should generally not be called by the *recipient* of this\n        Status object, but only by the object that created and returned it.\n        \"\"\"\n        with self._externally_initiated_completion_lock:\n            if self._externally_initiated_completion:\n                raise InvalidState(\n                    \"Either set_finished() or set_exception() has \"\n                    f\"already been called on {self!r}\"\n                )\n            self._externally_initiated_completion = True\n        # Note that in either case, the callbacks themselves are run from the\n        # same thread. This just sets an Event, either from this thread (the\n        # one calling set_finished) or the thread created below.\n        if self.settle_time &gt; 0:\n            threading.Timer(self.settle_time, self._settled_event.set).start()\n        else:\n            self._settled_event.set()\n\n    def exception(self, timeout: float | None = None) -&gt; BaseException | None:\n        \"\"\"Return the exception raised by the action.\n\n        If the action has completed successfully, return ``None``. If it has\n        finished in error, return the exception.\n\n        Parameters\n        ----------\n        timeout: float | None, optional\n            If None (default) wait indefinitely until the status finishes.\n\n        Returns\n        -------\n        Exception:\n            The exception raised by the action. If the action has completed\n            successfully, return ``None``.\n\n        Raises\n        ------\n        WaitTimeoutError\n            If the status has not completed within ``timeout`` (starting from\n            when this method was called, not from the beginning of the action).\n        \"\"\"\n        if not self._event.wait(timeout=timeout):\n            raise WaitTimeoutError(\"Status has not completed yet.\")\n        return self._exception\n\n    def wait(self, timeout: float | None = None) -&gt; None:\n        \"\"\"Block until the action completes.\n\n        When the action has finished succesfully, return ``None``. If the\n        action has failed, raise the exception.\n\n        Parameters\n        ----------\n        timeout: ``float``, optional\n            If ``None`` (default) wait indefinitely until the status finishes.\n\n        Raises\n        ------\n        WaitTimeoutError\n            If the status has not completed within ``timeout`` (starting from\n            when this method was called, not from the beginning of the action).\n        StatusTimeoutError\n            If the status has failed because the *timeout* that it was\n            initialized with has expired.\n        Exception\n            This is ``status.exception()``, raised if the status has finished\n            with an error.  This may include ``TimeoutError``, which\n            indicates that the action itself raised ``TimeoutError``, distinct\n            from ``WaitTimeoutError`` above.\n        \"\"\"\n        if not self._event.wait(timeout=timeout):\n            raise WaitTimeoutError(\"Status has not completed yet.\")\n        if self._exception is not None:\n            raise self._exception\n\n    @property\n    def callbacks(self) -&gt; deque[Callable[[Status], None]]:\n        \"\"\"Callbacks to be run when the status is marked as finished.\"\"\"\n        return self._callbacks\n\n    def add_callback(self, callback: Callable[[Status], None]) -&gt; None:\n        \"\"\"Register a callback to be called once when the Status finishes.\n\n        The callback will be called exactly once. If the Status is finished\n        before a callback is added, it will be called immediately. This is\n        threadsafe.\n        The callback will be called regardless of success of failure. The\n        callback has access to this status object, so it can distinguish success\n        or failure by inspecting the object.\n\n        Parameters\n        ----------\n        callback: ``Callable[[Status], None]``\n            The callback to be called when the status is marked as finished.\n\n            ```python\n            def callback(status: Status) -&gt; None:\n                # Do something with the status object\n                ...\n            ```\n        \"\"\"\n        with self._lock:\n            if self.done:\n                # Call it once and do not hold a reference to it.\n                callback(self)\n            else:\n                # Hold a strong reference to this. In other contexts we tend to\n                # hold weak references to callbacks, but this is a single-shot\n                # callback, so we will hold a strong reference until we call it,\n                # and then clear this cache to drop the reference(s).\n                self._callbacks.append(callback)\n</code></pre>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.engine.Status.timeout","level":3,"title":"timeout  <code>property</code>","text":"<pre><code>timeout: float | None\n</code></pre> <p>The timeout for this action.</p> <p>This is set when the Status is created, and it cannot be changed.</p>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.engine.Status.settle_time","level":3,"title":"settle_time  <code>property</code>","text":"<pre><code>settle_time: float\n</code></pre> <p>A delay between when <code>set_finished</code> is when the Status is done.</p> <p>This is set when the Status is created, and it cannot be changed.</p>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.engine.Status.done","level":3,"title":"done  <code>property</code>","text":"<pre><code>done: bool\n</code></pre> <p>Boolean indicating whether associated operation has completed.</p> <p>This is set to True at init time or by calling <code>set_finished</code>, <code>set_exception</code>. Once True, it can never become False.</p>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.engine.Status.success","level":3,"title":"success  <code>property</code>","text":"<pre><code>success: bool\n</code></pre> <p>Boolean indicating whether associated operation has completed.</p> <p>This is set to True at init time or by calling <code>set_finished</code>, <code>set_exception</code> . Once True, it can never become False.</p>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.engine.Status.callbacks","level":3,"title":"callbacks  <code>property</code>","text":"<pre><code>callbacks: deque[Callable[[Status], None]]\n</code></pre> <p>Callbacks to be run when the status is marked as finished.</p>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.engine.Status.set_exception","level":3,"title":"set_exception","text":"<pre><code>set_exception(exc: BaseException) -&gt; None\n</code></pre> <p>Mark as finished but failed with the given Exception.</p> <p>This method should generally not be called by the recipient of this Status object, but only by the object that created and returned it.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>BaseException</code> <p>The exception that caused the failure.</p> required Source code in <code>src/sunflare/engine/_status.py</code> <pre><code>def set_exception(self, exc: BaseException) -&gt; None:\n    \"\"\"Mark as finished but failed with the given Exception.\n\n    This method should generally not be called by the *recipient* of this\n    Status object, but only by the object that created and returned it.\n\n    Parameters\n    ----------\n    exc: BaseException\n        The exception that caused the failure.\n    \"\"\"\n    # Since we rely on this being raise-able later, check proactively to\n    # avoid potentially very confusing failures.\n    if not (isinstance(exc, BaseException)):\n        # Note that Python allows `raise Exception` or raise Exception()`\n        # so we allow a class or an instance here too.\n        raise ValueError(f\"Expected an Exception, got {exc!r}\")\n\n    # Ban certain Timeout subclasses that have special significance. This\n    # would probably never come up except due to some rare user error, but\n    # if it did it could be very confusing indeed!\n    for exc_class in (StatusTimeoutError, WaitTimeoutError):\n        if isinstance(exc, exc_class):\n            raise ValueError(\n                f\"{exc_class} has special significance and cannot be set \"\n                \"as the exception. Use a plain TimeoutError or some other \"\n                \"subclass thereof.\"\n            )\n\n    with self._externally_initiated_completion_lock:\n        if self._externally_initiated_completion:\n            raise InvalidState(\n                \"Either set_finished() or set_exception() has \"\n                f\"already been called on {self!r}\"\n            )\n        self._externally_initiated_completion = True\n        if isinstance(self._exception, StatusTimeoutError):\n            # We have already timed out.\n            return\n        self._exception = exc\n        self._settled_event.set()\n</code></pre>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.engine.Status.set_finished","level":3,"title":"set_finished","text":"<pre><code>set_finished() -&gt; None\n</code></pre> <p>Mark as finished successfully.</p> <p>This method should generally not be called by the recipient of this Status object, but only by the object that created and returned it.</p> Source code in <code>src/sunflare/engine/_status.py</code> <pre><code>def set_finished(self) -&gt; None:\n    \"\"\"Mark as finished successfully.\n\n    This method should generally not be called by the *recipient* of this\n    Status object, but only by the object that created and returned it.\n    \"\"\"\n    with self._externally_initiated_completion_lock:\n        if self._externally_initiated_completion:\n            raise InvalidState(\n                \"Either set_finished() or set_exception() has \"\n                f\"already been called on {self!r}\"\n            )\n        self._externally_initiated_completion = True\n    # Note that in either case, the callbacks themselves are run from the\n    # same thread. This just sets an Event, either from this thread (the\n    # one calling set_finished) or the thread created below.\n    if self.settle_time &gt; 0:\n        threading.Timer(self.settle_time, self._settled_event.set).start()\n    else:\n        self._settled_event.set()\n</code></pre>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.engine.Status.exception","level":3,"title":"exception","text":"<pre><code>exception(\n    timeout: float | None = None,\n) -&gt; BaseException | None\n</code></pre> <p>Return the exception raised by the action.</p> <p>If the action has completed successfully, return <code>None</code>. If it has finished in error, return the exception.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>float | None</code> <p>If None (default) wait indefinitely until the status finishes.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Exception</code> <code>BaseException | None</code> <p>The exception raised by the action. If the action has completed successfully, return <code>None</code>.</p> <p>Raises:</p> Type Description <code>WaitTimeoutError</code> <p>If the status has not completed within <code>timeout</code> (starting from when this method was called, not from the beginning of the action).</p> Source code in <code>src/sunflare/engine/_status.py</code> <pre><code>def exception(self, timeout: float | None = None) -&gt; BaseException | None:\n    \"\"\"Return the exception raised by the action.\n\n    If the action has completed successfully, return ``None``. If it has\n    finished in error, return the exception.\n\n    Parameters\n    ----------\n    timeout: float | None, optional\n        If None (default) wait indefinitely until the status finishes.\n\n    Returns\n    -------\n    Exception:\n        The exception raised by the action. If the action has completed\n        successfully, return ``None``.\n\n    Raises\n    ------\n    WaitTimeoutError\n        If the status has not completed within ``timeout`` (starting from\n        when this method was called, not from the beginning of the action).\n    \"\"\"\n    if not self._event.wait(timeout=timeout):\n        raise WaitTimeoutError(\"Status has not completed yet.\")\n    return self._exception\n</code></pre>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.engine.Status.wait","level":3,"title":"wait","text":"<pre><code>wait(timeout: float | None = None) -&gt; None\n</code></pre> <p>Block until the action completes.</p> <p>When the action has finished succesfully, return <code>None</code>. If the action has failed, raise the exception.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>float | None</code> <p>If <code>None</code> (default) wait indefinitely until the status finishes.</p> <code>None</code> <p>Raises:</p> Type Description <code>WaitTimeoutError</code> <p>If the status has not completed within <code>timeout</code> (starting from when this method was called, not from the beginning of the action).</p> <code>StatusTimeoutError</code> <p>If the status has failed because the timeout that it was initialized with has expired.</p> <code>Exception</code> <p>This is <code>status.exception()</code>, raised if the status has finished with an error.  This may include <code>TimeoutError</code>, which indicates that the action itself raised <code>TimeoutError</code>, distinct from <code>WaitTimeoutError</code> above.</p> Source code in <code>src/sunflare/engine/_status.py</code> <pre><code>def wait(self, timeout: float | None = None) -&gt; None:\n    \"\"\"Block until the action completes.\n\n    When the action has finished succesfully, return ``None``. If the\n    action has failed, raise the exception.\n\n    Parameters\n    ----------\n    timeout: ``float``, optional\n        If ``None`` (default) wait indefinitely until the status finishes.\n\n    Raises\n    ------\n    WaitTimeoutError\n        If the status has not completed within ``timeout`` (starting from\n        when this method was called, not from the beginning of the action).\n    StatusTimeoutError\n        If the status has failed because the *timeout* that it was\n        initialized with has expired.\n    Exception\n        This is ``status.exception()``, raised if the status has finished\n        with an error.  This may include ``TimeoutError``, which\n        indicates that the action itself raised ``TimeoutError``, distinct\n        from ``WaitTimeoutError`` above.\n    \"\"\"\n    if not self._event.wait(timeout=timeout):\n        raise WaitTimeoutError(\"Status has not completed yet.\")\n    if self._exception is not None:\n        raise self._exception\n</code></pre>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.engine.Status.add_callback","level":3,"title":"add_callback","text":"<pre><code>add_callback(callback: Callable[[Status], None]) -&gt; None\n</code></pre> <p>Register a callback to be called once when the Status finishes.</p> <p>The callback will be called exactly once. If the Status is finished before a callback is added, it will be called immediately. This is threadsafe. The callback will be called regardless of success of failure. The callback has access to this status object, so it can distinguish success or failure by inspecting the object.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[Status], None]</code> <p>The callback to be called when the status is marked as finished.</p> <pre><code>def callback(status: Status) -&gt; None:\n    # Do something with the status object\n    ...\n</code></pre> required Source code in <code>src/sunflare/engine/_status.py</code> <pre><code>def add_callback(self, callback: Callable[[Status], None]) -&gt; None:\n    \"\"\"Register a callback to be called once when the Status finishes.\n\n    The callback will be called exactly once. If the Status is finished\n    before a callback is added, it will be called immediately. This is\n    threadsafe.\n    The callback will be called regardless of success of failure. The\n    callback has access to this status object, so it can distinguish success\n    or failure by inspecting the object.\n\n    Parameters\n    ----------\n    callback: ``Callable[[Status], None]``\n        The callback to be called when the status is marked as finished.\n\n        ```python\n        def callback(status: Status) -&gt; None:\n            # Do something with the status object\n            ...\n        ```\n    \"\"\"\n    with self._lock:\n        if self.done:\n            # Call it once and do not hold a reference to it.\n            callback(self)\n        else:\n            # Hold a strong reference to this. In other contexts we tend to\n            # hold weak references to callbacks, but this is a single-shot\n            # callback, so we will hold a strong reference until we call it,\n            # and then clear this cache to drop the reference(s).\n            self._callbacks.append(callback)\n</code></pre>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.engine.RunEngine","level":2,"title":"RunEngine","text":"<p>               Bases: <code>RunEngine</code></p> <p>The Run Engine execute messages and emits Documents.</p> <p>This is a wrapper for the <code>bluesky.run_engine.RunEngine</code> class that allows execution without blocking the main thread. The main difference is that the <code>__call__</code> method is executed in a separate thread, and it returns a concurrent.futures.Future object representing the result of the plan execution.</p> <p>Parameters:</p> Name Type Description Default <code>md</code> <code>dict[str, Any]</code> <p>The default is a standard Python dictionary, but fancier objects can be used to store long-term history and persist it between sessions. The standard configuration instantiates a Run Engine with historydict.HistoryDict, a simple interface to a sqlite file. Any object supporting <code>__getitem__</code>, <code>__setitem__</code>, and <code>clear</code> will work.</p> <code>None</code> <code>loop</code> <code>AbstractEventLoop | None</code> <p>An asyncio event loop to be used for executing plans. If not provided, the RunEngine will create a new event loop using <code>asyncio.new_event_loop()</code>; e.g., <code>asyncio.get_event_loop()</code> or <code>asyncio.new_event_loop()</code></p> <code>None</code> <code>preprocessors</code> <code>list</code> <p>Generator functions that take in a plan (generator instance) and modify its messages on the way out. Suitable examples include the functions in the module <code>bluesky.plans</code> with names ending in 'wrapper'.  Functions are composed in order: the preprocessors <code>[f, g]</code> are applied like <code>f(g(plan))</code>.</p> <code>None</code> <code>md_validator</code> <code>Callable[dict[str, Any], None]</code> <p>a function that raises and prevents starting a run if it deems the metadata to be invalid or incomplete Function should raise if md is invalid. What that means is completely up to the user. The function's return value is ignored.</p> <code>None</code> <code>md_normalizer</code> <code>Callable[dict[str, Any], dict[str, Any]]</code> <p>a function that, similar to md_validator, raises and prevents starting a run if it deems the metadata to be invalid or incomplete. If it succeeds, it returns the normalized/transformed version of the original metadata. Function should raise if md is invalid. What that means is completely up to the user. Expected return: normalized metadata</p> <code>None</code> <code>scan_id_source</code> <code>Callable[dict[str, Any], int | Awaitable[int]]</code> <p>a (possibly async) function that will be used to calculate scan_id. Default is to increment scan_id by 1 each time. However you could pass in a customized function to get a scan_id from any source. Expected return: updated scan_id value</p> <code>default_scan_id_source</code> <code>call_returns_result</code> <code>bool</code> <p>A flag that controls the return value of <code>__call__</code>. If <code>True</code>, the <code>RunEngine</code> will return a :class:<code>RunEngineResult</code> object that contains information about the plan that was run. If <code>False</code>, the <code>RunEngine</code> will return a tuple of uids. The potential return value is encapsulated in the returned Future object, accessible via <code>future.result()</code>. Defaults to <code>True</code>.</p> <code>True</code> <p>Attributes:</p> Name Type Description <code>md</code> <p>Direct access to the dict-like persistent storage described above</p> <code>record_interruptions</code> <p>False by default. Set to True to generate an extra event stream that records any interruptions (pauses, suspensions).</p> <code>state</code> <p>{'idle', 'running', 'paused'}</p> <code>suspenders</code> <p>Read-only collection of <code>bluesky.suspenders.SuspenderBase</code> objects which can suspend and resume execution; see related methods.</p> <code>preprocessors</code> <code>list</code> <p>Generator functions that take in a plan (generator instance) and modify its messages on the way out. Suitable examples include the functions in the module <code>bluesky.plans</code> with names ending in 'wrapper'.  Functions are composed in order: the preprocessors <code>[f, g]</code> are applied like <code>f(g(plan))</code>.</p> <code>msg_hook</code> <p>Callable that receives all messages before they are processed (useful for logging or other development purposes); expected signature is <code>f(msg)</code> where <code>msg</code> is a <code>bluesky.Msg</code>, a kind of namedtuple; default is None.</p> <code>state_hook</code> <p>Callable with signature <code>f(new_state, old_state)</code> that will be called whenever the RunEngine's state attribute is updated; default is None</p> <code>waiting_hook</code> <p>Callable with signature <code>f(status_object)</code> that will be called whenever the RunEngine is waiting for long-running commands (trigger, set, kickoff, complete) to complete. This hook is useful to incorporate a progress bar.</p> <code>ignore_callback_exceptions</code> <p>Boolean, False by default.</p> <code>call_returns_result</code> <p>Boolean, False by default. If False, RunEngine will return uuid list after running a plan. If True, RunEngine will return a RunEngineResult object that contains the plan result, error status, and uuid list.</p> <code>loop</code> <code>asyncio event loop</code> <p>e.g., <code>asyncio.get_event_loop()</code> or <code>asyncio.new_event_loop()</code></p> <code>max_depth</code> <p>Maximum stack depth; set this to prevent users from calling the RunEngine inside a function (which can result in unexpected behavior and breaks introspection tools). Default is None. For built-in Python interpreter, set to 2. For IPython, set to 11 (tested on IPython 5.1.0; other versions may vary).</p> <code>pause_msg</code> <code>str</code> <p>The message printed when a run is interrupted. This message includes instructions of changing the state of the RunEngine. It is set to <code>bluesky.run_engine.PAUSE_MSG</code> by default and can be modified based on needs.</p> <code>commands</code> <p>The list of commands available to Msg.</p> <p>Methods:</p> Name Description <code>resume</code> <p>Resume the paused plan in a separate thread.</p> Source code in <code>src/sunflare/engine/_wrapper.py</code> <pre><code>class RunEngine(BlueskyRunEngine):\n    \"\"\"The Run Engine execute messages and emits Documents.\n\n    This is a wrapper for the `bluesky.run_engine.RunEngine` class that\n    allows execution without blocking the main thread.\n    The main difference is that the ``__call__`` method\n    is executed in a separate thread,\n    and it returns a concurrent.futures.Future object\n    representing the result of the plan execution.\n\n    Parameters\n    ----------\n    md : dict[str, Any], optional\n        The default is a standard Python dictionary, but fancier\n        objects can be used to store long-term history and persist\n        it between sessions. The standard configuration\n        instantiates a Run Engine with historydict.HistoryDict, a\n        simple interface to a sqlite file. Any object supporting\n        `__getitem__`, `__setitem__`, and `clear` will work.\n\n    loop: asyncio.AbstractEventLoop, optional\n        An asyncio event loop to be used for executing plans. If not provided,\n        the RunEngine will create a new event loop using ``asyncio.new_event_loop()``;\n        e.g., ``asyncio.get_event_loop()`` or ``asyncio.new_event_loop()``\n\n    preprocessors : list, optional\n        Generator functions that take in a plan (generator instance) and\n        modify its messages on the way out. Suitable examples include\n        the functions in the module ``bluesky.plans`` with names ending in\n        'wrapper'.  Functions are composed in order: the preprocessors\n        ``[f, g]`` are applied like ``f(g(plan))``.\n\n    md_validator : Callable[dict[str, Any], None], optional\n        a function that raises and prevents starting a run if it deems\n        the metadata to be invalid or incomplete\n        Function should raise if md is invalid. What that means is\n        completely up to the user. The function's return value is\n        ignored.\n\n    md_normalizer : Callable[dict[str, Any], dict[str, Any]], optional\n        a function that, similar to md_validator, raises and prevents starting\n        a run if it deems the metadata to be invalid or incomplete.\n        If it succeeds, it returns the normalized/transformed version of\n        the original metadata.\n        Function should raise if md is invalid. What that means is\n        completely up to the user.\n        Expected return: normalized metadata\n\n    scan_id_source : Callable[dict[str, Any], int | Awaitable[int]], optional\n        a (possibly async) function that will be used to calculate scan_id.\n        Default is to increment scan_id by 1 each time. However you could pass\n        in a customized function to get a scan_id from any source.\n        Expected return: updated scan_id value\n\n    call_returns_result : bool, default True\n        A flag that controls the return value of ``__call__``.\n        If ``True``, the ``RunEngine`` will return a :class:``RunEngineResult``\n        object that contains information about the plan that was run.\n        If ``False``, the ``RunEngine`` will return a tuple of uids.\n        The potential return value is encapsulated in the returned Future object,\n        accessible via ``future.result()``.\n        Defaults to ``True``.\n\n\n    Attributes\n    ----------\n    md\n        Direct access to the dict-like persistent storage described above\n\n    record_interruptions\n        False by default. Set to True to generate an extra event stream\n        that records any interruptions (pauses, suspensions).\n\n    state\n        {'idle', 'running', 'paused'}\n\n    suspenders\n        Read-only collection of `bluesky.suspenders.SuspenderBase` objects\n        which can suspend and resume execution; see related methods.\n\n    preprocessors : list\n        Generator functions that take in a plan (generator instance) and\n        modify its messages on the way out. Suitable examples include\n        the functions in the module ``bluesky.plans`` with names ending in\n        'wrapper'.  Functions are composed in order: the preprocessors\n        ``[f, g]`` are applied like ``f(g(plan))``.\n\n    msg_hook\n        Callable that receives all messages before they are processed\n        (useful for logging or other development purposes); expected\n        signature is ``f(msg)`` where ``msg`` is a ``bluesky.Msg``, a\n        kind of namedtuple; default is None.\n\n    state_hook\n        Callable with signature ``f(new_state, old_state)`` that will be\n        called whenever the RunEngine's state attribute is updated; default\n        is None\n\n    waiting_hook\n        Callable with signature ``f(status_object)`` that will be called\n        whenever the RunEngine is waiting for long-running commands\n        (trigger, set, kickoff, complete) to complete. This hook is useful to\n        incorporate a progress bar.\n\n    ignore_callback_exceptions\n        Boolean, False by default.\n\n    call_returns_result\n        Boolean, False by default. If False, RunEngine will return uuid list\n        after running a plan. If True, RunEngine will return a RunEngineResult\n        object that contains the plan result, error status, and uuid list.\n\n    loop : asyncio event loop\n        e.g., ``asyncio.get_event_loop()`` or ``asyncio.new_event_loop()``\n\n    max_depth\n        Maximum stack depth; set this to prevent users from calling the\n        RunEngine inside a function (which can result in unexpected\n        behavior and breaks introspection tools). Default is None.\n        For built-in Python interpreter, set to 2. For IPython, set to 11\n        (tested on IPython 5.1.0; other versions may vary).\n\n    pause_msg : str\n        The message printed when a run is interrupted. This message\n        includes instructions of changing the state of the RunEngine.\n        It is set to ``bluesky.run_engine.PAUSE_MSG`` by default and\n        can be modified based on needs.\n\n    commands:\n        The list of commands available to Msg.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        md: dict[str, Any] | None = None,\n        *,\n        loop: asyncio.AbstractEventLoop | None = None,\n        preprocessors: list[Preprocessor] | None = None,\n        md_validator: MDValidator | None = None,\n        md_normalizer: MDNormalizer | None = None,\n        scan_id_source: MDScanIDSource | None = default_scan_id_source,\n        call_returns_result: bool = True,\n    ):\n        # force the context_managers to be empty,\n        # otherwise the RunEngine will try to use the\n        # SignalHandler context manager\n        self._executor = ThreadPoolExecutor(max_workers=1)\n\n        super().__init__(\n            md=md,\n            loop=loop,\n            preprocessors=preprocessors,\n            md_validator=md_validator,\n            md_normalizer=md_normalizer,\n            scan_id_source=scan_id_source,  # type: ignore[arg-type]\n            call_returns_result=call_returns_result,\n            context_managers=[],\n        )\n\n        # override pause message to be an empty string\n        self.pause_msg = \"\"\n\n    def __call__(  # type: ignore[override]\n        self,\n        plan: Iterable[Msg],\n        subs: Subscribers | None = None,\n        /,\n        **metadata_kw: Any,\n    ) -&gt; Future[RunEngineResult | tuple[str, ...]]:\n        \"\"\"Execute a plan.\n\n        Any keyword arguments will be interpreted as metadata and recorded with\n        any run(s) created by executing the plan. Notice that the plan\n        (required) and extra subscriptions (optional) must be given as\n        positional arguments.\n\n        Parameters\n        ----------\n        plan : typing.Iterable[`bluesky.utils.Msg`]\n            A generator or that yields ``Msg`` objects (or an iterable that\n            returns such a generator).\n        subs : `bluesky.utils.Subscribers`, optional (positional only)\n            Temporary subscriptions (a.k.a. callbacks) to be used on this run.\n            For convenience, any of the following are accepted:\n\n            * a callable, which will be subscribed to 'all'\n            * a list of callables, which again will be subscribed to 'all'\n            * a dictionary, mapping specific subscriptions to callables or\n              lists of callables; valid keys are {'all', 'start', 'stop',\n              'event', 'descriptor'}\n\n        Returns\n        -------\n        Future[RunEngineResult | tuple[str, ...]]\n            Future object representing the result of the plan execution.\n\n        The result contained in the future is either:\n        uids : tuple\n            list of uids (i.e. RunStart Document uids) of run(s)\n            if :attr:`RunEngine._call_returns_result` is ``False``\n        result : :class:`RunEngineResult`\n            if :attr:`RunEngine._call_returns_result` is ``True``\n        \"\"\"\n        return self._executor.submit(\n            super().__call__,\n            plan,\n            subs,\n            **metadata_kw,\n        )\n\n    def resume(self) -&gt; Future[RunEngineResult | tuple[str, ...]]:\n        \"\"\"Resume the paused plan in a separate thread.\n\n        If the plan has been paused, the initial\n        future returned by ``__call__`` will be set as completed.\n\n        With this method, the plan is resumed in a separate thread,\n        and a new future is returned.\n\n        Returns\n        -------\n        ``Future[RunEngineResult | tuple[str, ...]]``\n            Future object representing the result of the resumed plan.\n        \"\"\"\n        return self._executor.submit(super().resume)\n</code></pre>","path":["Reference","API reference"],"tags":[]},{"location":"reference/api/#sunflare.engine.RunEngine.resume","level":3,"title":"resume","text":"<pre><code>resume() -&gt; Future[RunEngineResult | tuple[str, ...]]\n</code></pre> <p>Resume the paused plan in a separate thread.</p> <p>If the plan has been paused, the initial future returned by <code>__call__</code> will be set as completed.</p> <p>With this method, the plan is resumed in a separate thread, and a new future is returned.</p> <p>Returns:</p> Type Description <code>``Future[RunEngineResult | tuple[str, ...]]``</code> <p>Future object representing the result of the resumed plan.</p> Source code in <code>src/sunflare/engine/_wrapper.py</code> <pre><code>def resume(self) -&gt; Future[RunEngineResult | tuple[str, ...]]:\n    \"\"\"Resume the paused plan in a separate thread.\n\n    If the plan has been paused, the initial\n    future returned by ``__call__`` will be set as completed.\n\n    With this method, the plan is resumed in a separate thread,\n    and a new future is returned.\n\n    Returns\n    -------\n    ``Future[RunEngineResult | tuple[str, ...]]``\n        Future object representing the result of the resumed plan.\n    \"\"\"\n    return self._executor.submit(super().resume)\n</code></pre>","path":["Reference","API reference"],"tags":[]},{"location":"reference/changelog/","level":1,"title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p> <p>Dates are specified in the format <code>DD-MM-YYYY</code>.</p>","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#0101-20-02-2026","level":2,"title":"0.10.1 - 20-02-2026","text":"","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#fixed","level":3,"title":"Fixed","text":"<ul> <li><code>VirtualContainer.register_signals</code> now collects all signals into a single batch before calling <code>add_kwargs</code>, preventing each per-signal call from overwriting the previous one in the <code>Factory</code> kwargs store.</li> </ul>","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#changed","level":3,"title":"Changed","text":"<ul> <li><code>VirtualContainer.register_callbacks</code> now mirrors the <code>register_signals</code> API: accepts an <code>owner</code> object whose <code>name</code> attribute is used as the registry key, with an optional <code>name</code> override parameter. Both <code>DocumentRouter</code> subclass instances and any callable with a compatible <code>(str, Document)</code> signature are accepted. Non-callable or wrong-signature owners raise <code>TypeError</code>. An optional <code>callback_map</code> parameter allows a single owner to register multiple independent callbacks in one call.</li> </ul>","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#0100-20-02-2026","level":2,"title":"0.10.0 - 20-02-2026","text":"","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#changed_1","level":3,"title":"Changed","text":"<ul> <li>Replaced <code>VirtualBus</code> with <code>VirtualContainer</code> for more flexible injection mechanism</li> <li><code>VirtualContainer</code> the functionalities <code>VirtualBus</code> but additionally allows to exchange any kind of object via <code>python-dependency-injector</code></li> <li><code>RedSunConfig</code> moved from <code>redsun</code> to <code>sunflare</code> to be used as component-level metadata storage from the application layer</li> </ul>","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#091-19-02-2026","level":2,"title":"0.9.1 - 19-02-2026","text":"","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#changed_2","level":3,"title":"Changed","text":"<ul> <li>Moved <code>ViewPositionTypes</code> (renamed to <code>ViewPosition</code>) from app layer to <code>sunflare.view</code></li> </ul>","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#added","level":3,"title":"Added","text":"<ul> <li>Added smoke tests for view layer</li> </ul>","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#fixed_1","level":3,"title":"Fixed","text":"<ul> <li>Updated changelog format with missing fields of Keep a Changelog</li> </ul>","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#090-16-02-2026","level":2,"title":"0.9.0 - 16-02-2026","text":"","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#changed_3","level":3,"title":"Changed","text":"<ul> <li>Fully reworked the package to remove the need of <code>config.py</code></li> <li>Renamed <code>Model</code> to <code>Device</code> for more idiomatic representation of said layer</li> <li>All objects of all layers are now meant to be created using keyword-arguments parameters</li> <li>Exception to these are the <code>name</code> and <code>virtual_bus</code> keyword<ul> <li><code>name</code> is used to uniquely identify each device</li> <li><code>virtual_bus</code> is provided to the <code>Presenter</code> and <code>View</code> layers when a container is built</li> </ul> </li> <li>Switch documentation to use <code>zensical</code></li> </ul>","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#080-21-12-2025","level":2,"title":"0.8.0 - 21-12-2025","text":"","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#removed","level":3,"title":"Removed","text":"<ul> <li>Removed the overall dependency on <code>pyzmq</code> and <code>msgspec</code>:</li> <li>The original idea was to create a local network of document dispatch via the <code>inproc</code> protocol.</li> <li>This idea is now discarded and will be reworked in favor of a more consistent approach using multiple processes     controlled centrally by the application.</li> </ul>","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#changed_4","level":3,"title":"Changed","text":"<ul> <li>Expose signals registered to the <code>VirtualBus</code> through the <code>signals</code> property.</li> </ul>","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#added_1","level":3,"title":"Added","text":"<ul> <li>Add the ability to register callbacks in the <code>VirtualBus</code> for other components to retrieve (primarely other run engines).</li> <li>Expose callbacks via the <code>callbacks</code> property.</li> </ul>","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#070-15-12-2025","level":2,"title":"0.7.0 - 15-12-2025","text":"","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#changed_5","level":3,"title":"Changed","text":"<ul> <li>Remove <code>__init__</code> from common protocols</li> <li>Make parameters of <code>__init__</code> as read-write protocol attributes</li> <li>Rename all protocols to make them shorter</li> <li>Remove the socket implementation from the RunEngine</li> <li>Unused and not accurate feature</li> </ul>","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#063-14-12-2025","level":2,"title":"0.6.3 - 14-12-2025","text":"","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#added_2","level":3,"title":"Added","text":"<ul> <li>Add appropriate <code>resume</code> method to the <code>RunEngine</code> wrapper</li> <li>Ensure that it does not block the main thread</li> <li>Requires better documentation</li> </ul>","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#062-06-10-2025","level":2,"title":"0.6.2 - 06-10-2025","text":"","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#changed_6","level":3,"title":"Changed","text":"<ul> <li>Synchronize all dependencies correctly via <code>uv</code></li> <li>Bump <code>bluesky</code> version to <code>1.14.5</code></li> <li>Fix type hints accordingly</li> <li>Trigger CI for docs deployment and PyPI publishing from GitHub release page</li> <li>Previously new tag had to be manually pushed from CLI</li> <li>Add support for Python 3.13</li> <li>Add <code>noxfile.py</code> to run tests via <code>nox</code> for multiple Python versions locally</li> </ul>","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#061-04-07-2025","level":2,"title":"0.6.1 - 04-07-2025","text":"","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#fixed_2","level":3,"title":"Fixed","text":"<ul> <li>Inject <code>ViewInfoProtocol</code> and not the base class in the view base classes</li> </ul>","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#060-04-07-2025","level":2,"title":"0.6.0 - 04-07-2025","text":"","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#added_3","level":3,"title":"Added","text":"<ul> <li>Added <code>sunflare.containers</code> module for dynamically registering protocols and plans</li> <li>Provided 4 functions<ul> <li><code>register/get_plans</code></li> <li><code>register/get_protocols</code></li> </ul> </li> <li>Plan signatures are unwrapped within <code>PlanSignature</code> dataclass object<ul> <li>The signatures can be retrieved via <code>get_signatures</code></li> </ul> </li> <li>Registered plans must be type annotated to be correctly registered and used by other plugins</li> <li>Added initial testing</li> </ul>","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#changed_7","level":3,"title":"Changed","text":"<ul> <li>Dropped support for 3.9</li> <li>Removed usage of <code>Optional</code> and <code>Union</code></li> <li>Replaced with built-in <code>|</code> instead</li> <li>Switch to <code>uv</code> for dependency management</li> <li>Added <code>uv.lock</code> file</li> <li>Removed <code>engine</code> field from <code>RedsunSessionInfo</code></li> <li>Not really meaningful, was part of old concept</li> <li>Renamed <code>Widget</code> components to <code>View</code></li> <li>Ex-<code>Widget</code> classes are now injected with <code>ViewInfo</code> in initializer rather than <code>RedSunSessionInfo</code></li> </ul>","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#055-02-04-2025","level":2,"title":"0.5.5 - 02-04-2025","text":"","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#fixed_3","level":3,"title":"Fixed","text":"<ul> <li>catch exception when <code>RunEngine.stop()</code> is called from main thread</li> </ul>","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#054-31-03-2025","level":2,"title":"0.5.4 - 31-03-2025","text":"","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#fixed_4","level":3,"title":"Fixed","text":"<ul> <li>fixed <code>msgspec</code> decoding hook</li> <li>now returns the object when it's not of type <code>np.ndarray</code></li> <li>fixed <code>RunEngine</code> document emission</li> <li><code>emit</code> was failing to parse the document name</li> </ul>","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#053-25-03-2025","level":2,"title":"0.5.3 - 25-03-2025","text":"","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#changed_8","level":3,"title":"Changed","text":"<ul> <li>Reworked <code>log.py</code></li> <li>When calling <code>obj.debug</code>, the line where the call was emitted redirected to <code>Loggable</code></li> <li>using a <code>logging.LoggerAdapter</code> prevents this</li> <li>it also make the usage of <code>Loggable</code> more consistent by simply returning a <code>cached_property</code>, which now enforces usage of <code>obj.logger.debug</code> which is less confusing</li> </ul>","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#052-13-03-2025","level":2,"title":"0.5.2 - 13-03-2025","text":"","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#changed_9","level":3,"title":"Changed","text":"<ul> <li>Enhanced <code>sunflare.log</code> in order to separate log calls between two handlers.</li> </ul>","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#051-06-03-2025","level":2,"title":"0.5.1 - 06-03-2025","text":"","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#changed_10","level":3,"title":"Changed","text":"<ul> <li>Dropped upper bound limit for <code>numpy</code> dependency</li> </ul>","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#050-03-03-2025","level":2,"title":"0.5.0 - 03-03-2025","text":"","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#changed_11","level":3,"title":"Changed","text":"<ul> <li>Rearranged the structure of virtual-related classes</li> <li>Everything related to creating connections with the virtual bus have been brought to the <code>sunflare.virtual</code> module</li> <li>Set the default log level to <code>INFO</code> (was <code>DEBUG</code> before)</li> <li>Reworked <code>sunflare.config</code> to accomodate for new plugin system</li> </ul>","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#added_4","level":3,"title":"Added","text":"<ul> <li>Added a <code>Model</code> base class for quicker development.</li> </ul>","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#removed_1","level":3,"title":"Removed","text":"<ul> <li><code>configure</code> protocol is not part of the <code>ModelProtocol</code> anymore; see this PR</li> </ul>","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#042-24-02-2025","level":2,"title":"0.4.2 - 24-02-2025","text":"","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#changed_12","level":3,"title":"Changed","text":"<ul> <li>Changed <code>ModelProtocol.configure</code> signature</li> <li>Previous signature was not consistent with the command issued by the <code>RunEngine</code></li> </ul>","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#041-23-02-2025","level":2,"title":"0.4.1 - 23-02-2025","text":"","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#added_5","level":3,"title":"Added","text":"<ul> <li>Added support for <code>Mapping</code> types (i.e. <code>dict</code>) in <code>ModelInfo</code> methods (<code>read/describe_configuration</code>)</li> <li>Added optional parameters for <code>read/describe_configuration</code></li> <li><code>read_configuration</code>: <code>timestamp</code> (i.e. use <code>time.time()</code> for a timestamp of the last reading time)</li> <li><code>describe_configuration</code>: <code>source</code>, to specify the source of the configuration parameter</li> </ul>","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#040-22-02-2025","level":2,"title":"0.4.0 - 22-02-2025","text":"","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#added_6","level":3,"title":"Added","text":"<ul> <li>Implemented support for ZMQ messaging via <code>pyzmq</code></li> <li>Added initial support for <code>msgspec</code></li> <li>Added mixin classes for creating publisher/subscribers</li> <li>Added mixin classes for <code>Signal</code>-enabled controllers</li> <li>Added more documentation for the virtual module</li> <li>Reorganized code in different modules to avoid circular imports</li> <li>Split controller in different protocols</li> <li>Added <code>ModelInfoProtocol</code> to deploy models from packages that don't have a strict dependency with Sunflare</li> <li>Added more tests, both for existing and new code</li> </ul>","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#035-11-02-2025","level":2,"title":"0.3.5 - 11-02-2025","text":"","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#added_7","level":3,"title":"Added","text":"<ul> <li>Added protocol equivalent for <code>ModelInfo</code></li> <li>Currently untested</li> <li>This can be used in combination with <code>ModelProtocol</code> to define a Model interface from an external package without direct dependency to the <code>sunflare</code> package.</li> <li>Added documentation for <code>Controller</code></li> <li>Added tests for <code>RunEngine</code> wrapper</li> </ul>","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#changed_13","level":3,"title":"Changed","text":"<ul> <li>Minor docstring and renaming fixes</li> <li><code>engine</code> and <code>frontend</code> fields of <code>RedSunSessionInfo</code> are not optional anymore</li> </ul>","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#fixed_5","level":3,"title":"Fixed","text":"<ul> <li><code>RunEngine.__call__</code> fails in Python 3.9 unless explictly setting the event loop in the executor</li> </ul>","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#034-05-02-2025","level":2,"title":"0.3.4 - 05-02-2025","text":"","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#fixed_6","level":3,"title":"Fixed","text":"<ul> <li>Fixed bug in <code>RedSunSessionInfo.store_yaml</code> which was not correctly parsing <code>Enum</code> and <code>tuple</code> types</li> </ul>","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#033-04-02-2025","level":2,"title":"0.3.3 - 04-02-2025","text":"","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#changed_14","level":3,"title":"Changed","text":"<ul> <li>Minor renaming</li> <li>RedSun -&gt; Redsun</li> <li>SunFlare -&gt; Sunflare</li> </ul>","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#added_8","level":3,"title":"Added","text":"<ul> <li>Added documentation</li> <li>Notions of O.O.P.</li> <li>Minimal model doc</li> <li>Added test for VirtualBus connection mechanism</li> <li>Added <code>WidgetInfo</code> class</li> <li>Provides information for widgets</li> <li>Redsun uses it to correctly allocate dock widgets in the main view</li> <li>Currently adapted to be used with <code>PyQt</code> and <code>PySide</code><ul> <li>For web-based frameworks may require adjustments somehow</li> </ul> </li> <li>Added <code>RedSunSessionInfo.store_yaml</code> to save the configuration file elsewhere</li> <li>We could think of supporting dynamic plugin loading; this would mean changing the content of <code>RedSunSessionInfo</code> on the fly.</li> </ul>","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#032-29-01-2025","level":2,"title":"0.3.2 - 29-01-2025","text":"","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#added_9","level":3,"title":"Added","text":"<ul> <li><code>session</code> field in <code>RedSunSessionInfo</code></li> <li>used as main window title and as bluesky metadata</li> <li>added <code>**kwargs</code> to <code>configure</code> method</li> <li>need investigation on how to actually use it</li> <li>added optional <code>shutdown</code> method in <code>ModelProtocol</code></li> <li>it still must be implemented although not mandatory</li> </ul>","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#removed_2","level":3,"title":"Removed","text":"<ul> <li>removed built-in protocols <code>Detector</code> and <code>Motor</code></li> <li>each plugin should take care of deciding what they are</li> </ul>","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#changed_15","level":3,"title":"Changed","text":"<ul> <li>fixed metaclass error in <code>BaseQtWidget</code></li> </ul>","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#031-27-01-2025","level":2,"title":"0.3.1 - 27-01-2025","text":"","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#added_10","level":3,"title":"Added","text":"<ul> <li>Added parts of <code>Configurable</code> protocol in <code>ModelInfo</code> for easier handling</li> </ul>","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#030-27-01-2025","level":2,"title":"0.3.0 - 27-01-2025","text":"","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#changed_16","level":3,"title":"Changed","text":"<ul> <li>Refactor: simplify <code>virtual</code> module and remove <code>EngineHandler</code></li> <li>Use <code>typing_extensions.Protocol</code> in case of <code>Python &lt; 3.11</code></li> </ul>","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#added_11","level":3,"title":"Added","text":"<ul> <li>Added a wrapper of <code>RunEngine</code> which leaves the main thread unblocked</li> </ul>","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#022-02-01-2025","level":2,"title":"0.2.2 - 02-01-2025","text":"","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#changed_17","level":3,"title":"Changed","text":"<ul> <li>Correct engine handler API.</li> <li>Update CI action versions.</li> </ul>","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#021-02-01-2025","level":2,"title":"0.2.1 - 02-01-2025","text":"","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#changed_18","level":3,"title":"Changed","text":"<ul> <li>Engine handler now stores plans as dictionary of dictionaries.</li> <li>The key of the main dictionary is the controller name which holds the plans;</li> <li>The values are dictionaries:<ul> <li>Keys are the plan names;</li> <li>Values are plans built with <code>functools.partial</code></li> </ul> </li> </ul>","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#020-31-12-2024","level":2,"title":"0.2.0 - 31-12-2024","text":"","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#added_12","level":3,"title":"Added","text":"<ul> <li>Change configuration classes to use attrs in https://github.com/redsun-acquisition/sunflare/pull/8</li> <li>Model API rework in https://github.com/redsun-acquisition/sunflare/pull/9</li> </ul>","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#011-26-12-2024","level":2,"title":"0.1.1 - 26-12-2024","text":"<ul> <li>Same changes as [v0.1.1a1]</li> <li>Some typo adjustments</li> </ul>","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#011a1-25-12-2024","level":2,"title":"0.1.1a1 - 25-12-2024","text":"<p>(Only available on TestPyPI)</p>","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#added_13","level":3,"title":"Added","text":"<ul> <li>Rework handler by @jacopoabramo in #6</li> <li>Reworked a lot of logic</li> <li>Models are now subclassed in Models for easier type hinting management</li> <li>Using RedSunInstanceInfo in handler</li> <li>RedSunInstance info now holds logic to load and check yaml file as static method</li> </ul>","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#010-23-12-2024","level":2,"title":"0.1.0 - 23-12-2024","text":"","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#added_14","level":3,"title":"Added","text":"<ul> <li>First release on PyPI;</li> <li>Reached above 90% coverage;</li> </ul>","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#010a1-22-12-2024","level":2,"title":"0.1.0a1 - 22-12-2024","text":"<p>(Only available on TestPyPI)</p>","path":["Reference","Changelog"],"tags":[]},{"location":"reference/changelog/#added_15","level":3,"title":"Added","text":"<ul> <li>Alpha release;</li> <li>Basic project infrastructure;</li> </ul>","path":["Reference","Changelog"],"tags":[]},{"location":"tutorials/","level":1,"title":"Tutorials","text":"<p>Warning</p> <p>This section is a work-in-progress. We appreciate your patience!</p>","path":["Tutorials"],"tags":[]}]}
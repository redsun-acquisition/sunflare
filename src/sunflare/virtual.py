r"""
Sunflare virtual module.

This module implements the communication mechanism between the controller layer and the view layer.

It achieves this by using the `psygnal <https://psygnal.readthedocs.io/en/stable/>`_ library.

The module exposes the following:

- the ``psygnal.Signal`` class;
- the ``VirtualBus`` class;
- the ``slot`` decorator.

``psygnal.Signal`` is the main communication mechanism between controllers and the view layer.

It provides a syntax similar to the Qt signal/slot mechanism, i.e.

.. code-block:: python

    class MyController:
        sigMySignal = Signal()


    def a_slot():
        print("My signal was emitted!")


    ctrl = MyController()
    ctrl.sigMySignal.connect(my_slot)

- The ``VirtualBus`` class is a signal router for data exchange between the backend and frontend. Plugins can expose signals to other plugins or different Redsun modules, as well as connect to built-in signals or signals provided from other system components.

- The ``slot`` decorator is used to mark a function as a slot. In practice, it provides no benefit at runtime; it's used to facilitate code readability.

.. code-block:: python

    # slot will mark the function as a slot
    @slot
    def my_slot():
        print("My slot was called!")
"""

from __future__ import annotations

import threading
import weakref
from types import MappingProxyType
from typing import Callable, Iterable, Optional, TypeVar, Union, overload, ClassVar

import zmq
from event_model.documents import Event, EventDescriptor, RunStart, RunStop
from psygnal import Signal, SignalInstance

from sunflare.log import Loggable

__all__ = ["Signal", "VirtualBus", "slot"]


F = TypeVar("F", bound=Callable[..., object])

_INPROC_PUB = "inproc://virtual_xpub"
_INPROC_SUB = "inproc://virtual_xsub"


@overload
def slot(func: F) -> F: ...


@overload
def slot(*, private: bool) -> Callable[[F], F]: ...


def slot(
    func: Optional[F] = None, *, private: bool = False
) -> Union[F, Callable[[F], F]]:
    """Decorate a function as a slot.

    Parameters
    ----------
    func : ``F``, optional
        The function to decorate. If not provided, the decorator must be applied with arguments.
    private : ``bool``, optional
        Mark the slot as private. Default is ``False``.

    Returns
    -------
    ``Union[F, Callable[[F], F]]``
        Either the decorated function or a callable decorator.
    """

    def decorator(actual_func: F) -> F:
        setattr(actual_func, "__isslot__", True)
        setattr(actual_func, "__isprivate__", private)
        return actual_func

    if func is None:
        return decorator  # Return the decorator function
    else:
        return decorator(func)  # Directly apply the decorator


class VirtualBus(Loggable):
    """``VirtualBus``: signal router for data exchange.

    Supports logging via :class:`~sunflare.log.Loggable`.

    The ``VirtualBus`` is a mechanism to exchange
    data between different parts of the system. Communication
    can happen between plugins on the same layer as
    well as between different layers of the system.

    It can be used to emit notifications, as well as carry information
    to other plugins and/or different Redsun modules.

    ``VirtualBus``' signals are implemented using the ``psygnal`` library;
    they can be dynamically registered as class attributes,
    and accessed as a read-only dictionary.

    Documents generated by the ``RunEngine`` can be forwarded
    from single controllers to the frontend via appropriate built-in signals.
    Each controller must provide the document source (the controller class name)
    and the document itself; i.e.

    .. code-block:: python

        class MyController:
            ...

            def emit_new_run_start(self, run_start: RunStart):
                self.sigNewRunStart.emit(self.__class__.__name__, run_start)

    This allows to cherry-pick which documents to forward to the frontend.

    Attributes
    ----------
    sigNewRunStart : ``Signal(str, RunStart)``
        Signal to forward ``RunStart`` documents to the frontend.
    sigNewEvent : ``Signal(str, Event)``
        Signal to forward ``Event`` documents to the frontend.
    sigNewDescriptor : ``Signal(str, EventDescriptor)``
        Signal to forward ``EventDescriptor`` documents to the frontend.
    sigNewRunStop : ``Signal(str, RunStop)``
        Signal to forward ``RunStop`` documents to the frontend.
    contetx: ``zmq.SyncContext``
        The ZMQ context of the virtual bus.
    """

    sigNewRunStart = Signal(str, RunStart)
    sigNewEvent = Signal(str, Event)
    sigNewDescriptor = Signal(str, EventDescriptor)
    sigNewRunStop = Signal(str, RunStop)

    _INPROC_MAP: ClassVar[dict[int, str]] = {
        zmq.SUB: _INPROC_PUB,
        zmq.PUB: _INPROC_PUB,
    }

    _SOCKET_MAP: weakref.WeakValueDictionary[str, zmq.SyncSocket] = (
        weakref.WeakValueDictionary()
    )

    _POLLER_MAP: weakref.WeakValueDictionary[str, zmq.Poller] = (
        weakref.WeakValueDictionary()
    )

    def __init__(self) -> None:
        self._cache: dict[str, dict[str, SignalInstance]] = {}

        # this should be configurable
        # from RedSunSessionInfo...
        self._ctx = zmq.Context()
        self._xsub = zmq.Socket(self._ctx, zmq.XSUB)
        self._xsub.bind(_INPROC_SUB)
        self._xpub = zmq.Socket(self._ctx, zmq.XPUB)
        self._xpub.bind(_INPROC_PUB)
        self._poller = zmq.Poller()
        self._poller.register(self._xsub, zmq.POLLIN)
        self._poller.register(self._xpub, zmq.POLLIN)

        self._proxy_thread = threading.Thread(target=self._run_proxy, daemon=True)
        self._proxy_thread.start()

    def shutdown(self) -> None:
        """Shutdown the virtual bus.

        Closes the ZMQ context and terminates the streamer queue.
        """
        for owner, poller in self._POLLER_MAP.items():
            poller.unregister(self._SOCKET_MAP[owner])
        for socket in self._SOCKET_MAP.values():
            socket.close()
        self._ctx.term()

    def register_signals(
        self, owner: object, only: Optional[Iterable[str]] = None
    ) -> None:
        """
        Register the signals of an object in the virtual bus.

        Parameters
        ----------
        owner : ``object``
            The instance whose class's signals are to be cached.
        only : ``Iterable[str]``, optional
            A list of signal names to cache. If not provided, all
            signals in the class will be cached automatically by inspecting
            the class attributes.

        Notes
        -----
        This method inspects the attributes of the owner's class to find
        ``psygnal.Signal`` descriptors. For each such descriptor, it retrieves
        the ``SignalInstance`` from the owner using the descriptor protocol and
        stores it in the registry.
        """
        owner_class = type(owner)  # Get the class of the object
        class_name = owner_class.__name__  # Name of the class

        if only is None:
            # Automatically detect all attributes of the class that are psygnal.Signal descriptors
            only = [
                name
                for name in dir(owner_class)
                if isinstance(getattr(owner_class, name, None), Signal)
            ]

        # Initialize the registry for this class if not already present
        if class_name not in self._cache:
            self._cache[class_name] = {}

        # Iterate over the specified signal names and cache their instances
        for name in only:
            signal_descriptor = getattr(owner_class, name, None)
            if isinstance(signal_descriptor, Signal):
                # Retrieve the SignalInstance using the descriptor protocol
                signal_instance = getattr(owner, name)
                self._cache[class_name][name] = signal_instance

    def __getitem__(self, class_name: str) -> MappingProxyType[str, SignalInstance]:
        """
        Access the registry for a specific class.

        Parameters
        ----------
        class_name: str
            The name of the class whose signals are to be accessed.

        Returns
        -------
        MappingProxyType[str, SignalInstance]
            A read-only dictionary mapping signal names to their `SignalInstance` objects.
            If the class is not found in the registry, an empty dictionary is returned.
        """
        try:
            return MappingProxyType(self._cache[class_name])
        except KeyError:
            self.error(f"Class {class_name} not found in the registry.")
            return MappingProxyType({})

    def __contains__(self, class_name: str) -> bool:
        """
        Check if a class is in the registry.

        Parameters
        ----------
        class_name : str
            The name of the class to check.

        Returns
        -------
        bool
            True if the class is in the registry, False otherwise.
        """
        return class_name in self._cache

    def _run_proxy(self) -> None:
        """Run the proxy in a daemon thread.

        Messages are forwarded from the XSUB socket to the XPUB socket,
        where are then forwarded to multiple SUB sockets.
        """
        try:
            while True:
                try:
                    events = dict(self._poller.poll())
                    if self._xsub in events:
                        msg = self._xsub.recv()
                        self._xsub.send(msg)
                    if self._xpub in events:
                        msg = self._xpub.recv()
                        self._xpub.send(msg)
                except zmq.error.ContextTerminated:
                    break
        finally:
            self._poller.unregister(self._xsub)
            self._poller.unregister(self._xpub)
            self._xpub.close()
            self._xsub.close()

    def connect(
        self, owner: object, socket_type: int
    ) -> Union[Optional[zmq.SyncSocket], Optional[tuple[zmq.SyncSocket, zmq.Poller]]]:
        """Return a new socket connected to the virtual bus context.

        Class instances may use this method to
        create a new socket which will be automatically
        connected to the virtual bus.

        Parameters
        ----------
        owner: ``object``
            The object that will own the socket.
            Used to retrieve the class name as a string.
            Typical usage:

            .. code-block:: python

                    class MyClass:
                        def __init__(self, bus: VirtualBus):
                            # create a new publisher socket
                            self.socket = bus.socket(self, zmq.PUB)

        socket_type : ``int | zmq.SocketType``
            The type of the socket to create.
            Accepted values are:

            - ``1`` / ``zmq.PUB``: Publisher socket.
            - ``2`` / ``zmq.SUB``: Subscriber socket.

        Returns
        -------
        ``zmq.Socket | None``
            A new socket for the virtual bus.
            If the socket type is invalid,
            logs the error returns ``None``.
        """
        owner_name = owner.__class__.__name__
        if socket_type not in [zmq.PUB, zmq.SUB]:
            self.error(
                f"Invalid socket type: {zmq.SocketType(socket_type)}. Aborting connection."
            )
            return None
        socket = self._ctx.socket(socket_type)
        socket.connect(self._INPROC_MAP[socket_type])
        self._SOCKET_MAP[owner_name] = socket

        if socket_type == zmq.SUB:
            poller = zmq.Poller()
            poller.register(socket, zmq.POLLIN)
            self._POLLER_MAP[owner_name] = poller
            return socket, poller
        else:
            return socket

    @property
    def context(self) -> zmq.SyncContext:
        """The ZMQ context of the virtual bus."""
        return self._ctx

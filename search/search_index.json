{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Sunflare","text":"<p>Toolkit for Redsun development</p> <p>Warning</p> <p>This project is currently under active development and it may (and most likely will) receive breaking changes. Use at your own risk.</p> <p>Sunflare is a Software Development Kit (SDK) which provides common, reusable components for building plugins which can interact with Redsun.</p> <p>The aim is to provide reusable patterns in developing software applications for scientific device orchestration leveraging the Bluesky hardware interface and data model.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>New to Sunflare? Start here:</p> <ul> <li> <p>Tutorials</p> <p>Learn Sunflare from the ground up with step-by-step lessons</p> <p>Start learning </p> </li> <li> <p>How-to Guides</p> <p>Practical guides for common tasks and problems</p> <p>Browse guides </p> </li> <li> <p>Reference</p> <p>Technical documentation and API reference</p> <p>View reference </p> </li> <li> <p>Explanation</p> <p>Understand the concepts and design behind Sunflare</p> <p>Read explanations </p> </li> </ul>"},{"location":"#quick-links","title":"Quick Links","text":"<ul> <li>Installation Guide - Get Sunflare up and running</li> <li>Statement of Need - Learn why Sunflare exists</li> <li>API Reference - Explore the complete API</li> <li>Changelog - See what's new</li> </ul>"},{"location":"#about-the-documentation","title":"About the Documentation","text":"<p>This documentation follows the Di\u00e1taxis framework, organizing content into four distinct categories based on your needs:</p> <ul> <li>Tutorials are learning-oriented lessons</li> <li>How-to Guides are task-oriented recipes</li> <li>Reference is information-oriented technical descriptions</li> <li>Explanation is understanding-oriented discussions</li> </ul>"},{"location":"#project-links","title":"Project Links","text":"<ul> <li>GitHub Repository</li> <li>PyPI Package</li> <li>Redsun Framework</li> </ul>"},{"location":"explanation/","title":"Explanation","text":"<p>Welcome to the Sunflare explanation section! Here you'll find background information, design rationale, and conceptual discussions.</p>"},{"location":"explanation/#what-youll-find-here","title":"What you'll find here","text":"<p>Explanations are understanding-oriented discussions that clarify and illuminate a topic. They provide context, discuss alternatives, and explain the \"why\" behind design decisions.</p>"},{"location":"explanation/#available-explanations","title":"Available Explanations","text":""},{"location":"explanation/#project-context","title":"Project Context","text":"<ul> <li>Statement of Need - Why Sunflare exists and its role in the Redsun ecosystem</li> </ul>"},{"location":"explanation/#architecture-design","title":"Architecture &amp; Design","text":"<ul> <li>Architecture Overview - Understanding Sunflare's architectural patterns</li> <li>Models - The model layer and data abstractions</li> <li>Presenters &amp; Controllers - Business logic components</li> <li>Virtual Bus - Event-driven communication system</li> <li>In-Process Model - In-process communication patterns</li> </ul>"},{"location":"explanation/#deepen-your-understanding","title":"Deepen Your Understanding","text":"<ul> <li>For hands-on learning, try the Tutorials</li> <li>For practical tasks, see the How-to Guides</li> <li>For technical details, check the API Reference</li> </ul>"},{"location":"explanation/statement/","title":"Statement of need","text":"<p>The goal of Sunflare is to provide shared and recognizable programming patterns accross the entire Redsun ecosystem. As Redsun heavily leverages the concept of plugins, there is a need to provide a clear representation and a shared communication channel between the plugins that in the end build the desired application.</p> <pre><code>:config: { \"theme\": \"neutral\" }\n:align: center\n    graph TD\n        Sunflare --&gt;|builds| Plugins\n        Sunflare --&gt;|builds| Redsun\n        Plugins --&gt;|used in| Redsun</code></pre> <p>The diagram shows the relationship between Redsun, Sunflare and the custom plugins. Effectively, Redsun is nothing more than \"glue\" code that constructs your custom application. What it does is:</p> <ul> <li>retrieve the user plugins via Python entry points;</li> <li>build said plugins and catch any possible exception throw by them;</li> <li>build the final application and connecting all the plugins together.</li> </ul> <p>This approach ensures that Sunflare can be reused as a standalone package to provide reusable code to create custom control interfaces for your device, which fit the Bluesky message protocol and data model.</p> <p>Furthermore, if you have an existing package for hardware control, Sunflare can be used to create a wrapper for your classes which can then \"talk\" the Bluesky language.</p>"},{"location":"explanation/architecture/","title":"Overview","text":"<p>This section illustrates the contents of the package, how to use the provided components for each layer and how these components fit in the Bluesky ecosystem.</p>"},{"location":"explanation/architecture/in-process-model/","title":"In-process models","text":"<p>in-process models provide interaction with the device API in the same process:   - by importing the API as a Python package and use it as a local object: API via aggregation;   - by inheriting from an existing class that encapsulates the commands of your device: API via inheritance.</p>"},{"location":"explanation/architecture/in-process-model/#api-via-aggregation","title":"API via aggregation","text":"<p>\"Aggregation\" means when an object is constructed inside a class.</p> <p>In this usage, a standard model is simply a wrapper around the actual device interface you want to control.</p> <p>The wrapped interface is often referred to as <code>handler</code>, although it varies depending on implementation details. The external application should not interact directly with the <code>handler</code> object; instead, the Model wrapping it should take care of calling the appropriate methods of the <code>handler</code> to perform the required tasks.</p> <p>Tip</p> <p>It is good practice to mark your handler object via a double underscore <code>__</code>, i.e. <code>__handler</code>, symbolizing that this is a private attribute (meaning that only your Model object can use it internally and it is not accessible from the outside). In truth, Python does not really enforce private attributes - meaning that there are ways to circumvent the privacy - but it is considered standard practice to annotate them in this manner.</p> UMLPython <pre><code>classDiagram\n    class DeviceModel {\n        -DeviceHandler __handler\n        +DeviceInfo model_info\n        +str name\n        +None parent\n        configure() None\n        read_configuration() dict[str, Reading]\n        describe_configuration() dict[str, DataKey]\n    }\n    class DeviceHandler {\n        +int param1\n        +float param2\n        device_method() void\n    }\n    class ModelInfo {\n    }\n    class DeviceInfo {\n        +int param1\n        +float param2\n    }\n\n    DeviceModel *-- DeviceHandler\n    ModelInfo &lt;|-- DeviceInfo : inherits from\n    DeviceModel o-- DeviceInfo : is aggregated in</code></pre> my_plugin/config.py<pre><code>from attrs import define\nfrom sunflare.config import ModelInfo\n\n@define\nclass DeviceInfo(ModelInfo):\n    param1: int\n    param2: float\n</code></pre> my_plugin/model.py<pre><code>from my_plugin.config import DeviceInfo\nfrom device_package import DeviceHandler\nfrom bluesky.protocols import Reading\nfrom event_model import DataKey\n\nclass DeviceModel:\n    def __init__(self, name: str, model_info: DeviceInfo) -&gt; None:\n        self._name = name\n        self._model_info = model_info\n\n        # unpack the parameters you need\n        # to initialize DeviceHandler,\n        # or provide them hard-coded\n        param1 = model_info.param1\n        param2 = model_info.param2\n        self.__handler = DeviceHandler(int_param=param1, float_param=param2, bool_param=True)\n\n    def configure(self) -&gt; None:\n        # here goes your implementation;\n        self.__handler.configure()\n\n    def read_configuration(self) -&gt; dict[str, Reading]:\n        # here goes your implementation;\n        return self.__handler.read_configuration()\n\n    def describe_configuration(self) -&gt; dict[str, DataKey]:\n        # here goes your implementation;\n        return self.__handler.describe_configuration()\n\n    @property\n    def name(self) -&gt; str:\n        return self._name\n\n    @property\n    def parent(self) -&gt; None:\n        return None\n\n    @property\n    def model_info(self) -&gt; DeviceInfo:\n       return self._model_info\n</code></pre> <p>Furthermore, a single Model can encapsulate multiple handlers, each of them with different functionalities. Keep in mind that it is your responsability (as developer) to associate the execution of Bluesky messages with the appropriate device handler.</p> <p>```python title= my_plugin/config.py from attrs import define from sunflare.config import ModelInfo from typing import Any</p> <p>@define class MyModelInfo(ModelInfo):     camera_parameters: dict[str, Any]     motor_parameters: dict[str, Any] <pre><code>```python title= my_plugin/model.py\n\n# a dummy representation of a plugin package that encapsulates\n# a Model wrapping controls for a camera and a motor\nfrom device_package import CameraHandler, MotorHandler\nfrom my_plugin.config import MyModelInfo\n\nclass MyModel:\n    def __init__(self, name: str, model_info: MyModelInfo) -&gt; None:\n        self._name = name\n        self._model_info = model_info\n\n        self.__motor_handler = MotorHandler(**model_info.motor_parameters)\n        self.__camera_handler = CameraHandler(**model_info.camera_parameters)\n</code></pre></p>"},{"location":"explanation/architecture/in-process-model/#api-via-inheritance","title":"API via inheritance","text":"<p>Using aggregation to control your device interface may be impractical if <code>DeviceHandler</code> already leverages a lot of internal code. Inheriting your Model from a pre-existing class gives the benefit of reusing it without having to rewrite any of the internals.</p> UML <pre><code>:config: { \"theme\": \"neutral\", \"fontFamily\": \"Courier New\" }\n:align: center\n\n    classDiagram\n        class DeviceModel {\n            +DeviceInfo model_info\n            +str name\n            +None parent\n            configure() None\n            read_configuration() dict[str, Reading]\n            describe_configuration() dict[str, DataKey]\n        }\n        class DeviceHandler {\n            device_method() void\n        }\n        class ModelInfo {\n        }\n        class DeviceInfo {\n            +int param1\n            +float param2\n        }\n\n        DeviceModel &lt;|-- DeviceHandler\n        ModelInfo &lt;|-- DeviceInfo : inherits from\n        DeviceModel o-- DeviceInfo : is aggregated in\n    ```\n\n=== \"Python\"\n\n    ```python title=\"my_plugin/config.py\"\n    from attrs import define\nfrom sunflare.config import ModelInfo\n\n@define\nclass DeviceInfo(ModelInfo):\n    param1: int\n    param2: float\n    ```\n\n    ```python title=\"my_plugin/model.py\"\nfrom my_plugin.config import DeviceInfo\nfrom device_package import DeviceHandler\nfrom bluesky.protocols import Reading\nfrom event_model import DataKey\n\nclass DeviceModel(DeviceHandler):\n    def __init__(self, name: str, model_info: DeviceInfo) -&gt; None:\n        self._name = name\n        self._model_info = model_info\n\n        # DeviceInfo can provide\n        # any initialization parameters\n        # required by DeviceHandler.__init__\n        super().__init__(int_param=param1, float_param=param2, bool_param=True)\n\n    def configure(self) -&gt; None:\n        # here goes your implementation;\n        super().configure()\n\n    def read_configuration(self) -&gt; dict[str, Reading]:\n        # here goes your implementation;\n        return super().read_configuration()\n\n    def describe_configuration(self) -&gt; dict[str, DataKey]:\n        # here goes your implementation;\n        return super().describe_configuration()\n\n    @property\n    def name(self) -&gt; str:\n        return self._name\n\n    @property\n    def parent(self) -&gt; None:\n        return None\n\n    @property\n    def model_info(self) -&gt; DeviceInfo:\n       return self._model_info\n    ```\n\nJust like in the aggregated API, your model can also inherit from multiple classes. Again, it is your responsibility (as developer) to ensure that the appropriate Bluesky protocols are invoked on the correct device.\n\n```python title= my_plugin/config.py\nfrom attrs import define\nfrom sunflare.config import ModelInfo\nfrom typing import Any\n\n@define\nclass MyModelInfo(ModelInfo):\n    camera_parameters: dict[str, Any]\n    motor_parameters: dict[str, Any]</code></pre> <p>```python title= my_plugin/model.py</p>"},{"location":"explanation/architecture/in-process-model/#a-dummy-representation-of-a-plugin-package-that-encapsulates","title":"a dummy representation of a plugin package that encapsulates","text":""},{"location":"explanation/architecture/in-process-model/#a-model-wrapping-controls-for-a-camera-and-a-motor","title":"a Model wrapping controls for a camera and a motor","text":"<p>from device_package import CameraHandler, MotorHandler from my_plugin.config import MyModelInfo</p> <p>class MyModel(CameraHandler, MotorHandler):     def init(self, name: str, model_info: MyModelInfo) -&gt; None:         self._name = name         self._model_info = model_info</p> <pre><code>    super(MotorHandler, self).__init__(**model_info.motor_parameters)\n    super(CameraHandler, self).__init__(**model_info.camera_parameters)\n</code></pre> <p>```</p>"},{"location":"explanation/architecture/in-process-model/#key-differences","title":"Key differences","text":"<p>Although they may initially look similar, there are key differences and advantages in each approach.</p> <p>Aggregation is useful... - ... when you want to have a more fine-grained control over your device; - ... when your device interface doesn't have an actual class encapsulating methods and parameters but instead uses a different programming paradigm; - ... when you don't want to expose certain behaviors of your device to the end-user (a.k.a. inhibiting the possibility to call public methods); - ... when your device interface is built using another language (C++, Rust, ...) and you want to keep a minimal level of abstraction between the model and the handler; - ... when your handler actually controls the interaction with multiple devices topology and you want to expose only a sub-set of those functionalities.</p> <p>An example candidate for aggregation is the [<code>pymmcore-plus</code>] package, which wraps the controls of multiple Micro-Manager devices behind the [<code>CMMCorePlus</code>] interface and provides additional functionalities (such as the [<code>MDAEngine</code>]).</p> <p>Inheritance is useful... - ... when your device has a lot of code and you want to quickly wrap it to be Bluesky-compatible; - ... when it provides extra functionalities that allow to work with remote devices by default; - ... when it is already a Bluesky-compatible device and you just want to make it as a plugin for Redsun.</p> <p>Example candidates for inheritance are the [<code>microscope</code>] and [<code>openwfs</code>] packages, as they provide pre-configured interfaces that can be extended with additional Bluesky methods.</p>"},{"location":"explanation/architecture/models/","title":"Models","text":"<p>The <code>Model</code> represents an interface with a device.</p> <p>The definition of a model is quite fluid, as there are many ways that it can interact with the hardware depending on your needs.</p> <p>Models can be developed with two approaches:</p> <ul> <li>by implementing the <code>PModel</code> with all the required methods and properties;</li> <li>inheriting from <code>Model</code>, which implements the above protocol with pre-configured implementation.</li> </ul> <p>Additional parameters can be passed to the <code>PModel</code> via the <code>ModelInfo</code> configuration class, by subclassing the latter to provide additional configuration informations.</p>"},{"location":"explanation/architecture/models/#see-also","title":"See Also","text":"<ul> <li>In-Process Model - Detailed guide on implementing models</li> </ul>"},{"location":"explanation/architecture/presenters/","title":"Presenters","text":"<p><code>Presenters</code> represent the execution logic of your system.</p> <p>Where <code>Models</code> are \"workers\" (as they instruct your device to perform a certain task), <code>Presenters</code> can be \"orchestrators\", in the sense that they define the sequence of actions that workers must perform through Bluesky plans.</p> <p>We highlight \"can be\" because <code>Presenters</code> are not limited to that:</p> <ul> <li>they can consume Bluesky documents for on-the-fly processing, intermediate storage or redirection to a GUI (i.e. computing the FFT of an image and sending it to the GUI for display);</li> <li>they can provide manual control for device task execution and/or configuration;</li> <li>in comparison to plans (which represents an experimental procedure), one may wish to - for example - manually move a motor stage from the GUI, or change the exposure time of a camera; the <code>Presenter</code> in this case acts as a middle-man between the GUI and the device, directly calling Bluesky methods and bypassing the <code>RunEngine</code>;</li> <li>they can act as communication points with external applications to trigger actions via a custom communication protocol (or wait for possible commands incoming by said applications).</li> </ul> <p><code>Presenters</code> are meant to communicate between each other via the <code>VirtualBus</code>, which takes care of redirecting information (commands and/or documents) to the appropriate destination (whether it is another <code>Presenter</code> or a <code>View</code>).</p> <p>All controllers must implement the <code>PPresenter</code> interface to be recognized by Redsun.</p> <p>The <code>PPresenter</code> requires three things in its initialization:</p> <ul> <li>a reference to a subclass of <code>PresenterInfo</code>, to provide additional parameters;</li> <li>a <code>Mapping[str, PModel]</code> of the allocated models in the session;</li> <li>a reference to the <code>VirtualBus</code> in order to provide a communication point with other controllers and widgets.</li> </ul>"},{"location":"explanation/architecture/virtual/","title":"Virtual bus","text":"<p>The <code>VirtualBus</code> is a class encapsulating different communication mechanism to allow different controllers and widget to exchange controls and/or data streams. It provides a \"Qt-like\" mechanism of signal connection through the <code>psygnal</code> package, where objects can dinamically register signals and connect to remote slots for communication in the main thread.</p>"},{"location":"explanation/architecture/virtual/#signal-connection","title":"Signal connection","text":"<p>The <code>VirtualBus</code> allows to create a connection between objects living in different plugins.</p> <p>Suppose you have the following example:</p> emitter_plugin.py<pre><code>class Emitter:\n    sigSender = Signal(int)\n</code></pre> receiver_plugin.py<pre><code>class Receiver:\n\n    def receiver_slot(param: int) -&gt; None:\n        print(\"I received\", param)\n</code></pre> <p>In a normal scenario where you have access to the codebase of both <code>Emitter</code> and <code>Receiver</code>, you would simply do the following:</p> <pre><code>emitter = Emitter()\nreceiver = Receiver()\n\nemitter.sigSender.connect(receiver.receiver_slot)\nemitter.sigSender.emit(10)\n\n# prints \"I received 10\"\n</code></pre> <p>Redsun operates by dinamically loading plugins, which means that <code>Emitter</code> and <code>Receiver</code> may come from different packages.</p> <p>The <code>VirtualBus</code> takes care of giving a common exposure and retrieval point between different plugins. The catch is that to be able to share a connection, <code>Emitter</code> and <code>Receiver</code> must be adapted to talk to the bus:</p> emitter_plugin.py<pre><code>from sunflare.virtual import VirtualBus\n\nclass Emitter:\n    sigSender = Signal(int)\n\n    def __init__(self, virtual_bus: VirtualBus) -&gt; None:\n        self.virtual_bus = virtual_bus\n\n    def registration_phase(self) -&gt; None:\n        self.virtual_bus.register_signals(self)\n</code></pre> receiver_plugin.py<pre><code>from sunflare.virtual import VirtualBus\n\nclass Receiver:\n\n    def __init__(self, virtual_bus: VirtualBus):\n        self.virtual_bus = virtual_bus\n\n    def receiver_slot(param: int) -&gt; None:\n        print(\"I received\", param)\n\n    def connection_phase(self) -&gt; None:\n        self.virtual_bus[\"Emitter\"][\"sigSender\"].connect(self.receiver_slot)\n</code></pre> <p>With this modifications, <code>Emitter</code> has informed the <code>VirtualBus</code> of the existence of <code>sigSender</code>, and <code>Receiver</code> can retrieve <code>sigSender</code> from <code>Emitter</code> to connect the signal to its slot <code>receiver_slot</code>.</p> <p>This enforces a specific call order: all <code>Emitter</code>-like object must call the <code>registration_phase</code> method before any <code>Receiver</code>-like\u00b4object can call the <code>connection_phase</code> method, otherwise there will be a mismatch.</p> <p>Note</p> <p>If a <code>Receiver</code>-like object tries to connect to a non-defined signal, your application will not crash, but there will be simply no connection enstablished with your slots.</p> <p>As a user, you only need to provide these two methods to ensure a safe connection. When Redsun is launched, it takes care of calling <code>registration_phase</code> and <code>connection_phase</code> in the correct order to ensure a safe connection.</p> <p>Using Sunflare without Redsun</p> <p>If you're using Sunflare in a non-Redsun application, you'll have to:</p> <ul> <li>create an instance of <code>VirtualBus</code>;</li> <li>ensure <code>Emitter</code> objects call their <code>registration_phase</code> method before <code>Receiver</code> objects call their <code>connection_phase</code> method.</li> </ul> <pre><code>from sunflare.virtual import VirtualBus\n\nbus = VirtualBus()\n\nemitter = Emitter(bus)\nreceiver = Receiver(bus)\n\n# Register signals first\nemitter.registration_phase()\n\n# Then connect to them\nreceiver.connection_phase()\n\n# ... run your application\n</code></pre>"},{"location":"how-to/","title":"How-to Guides","text":"<p>Welcome to the Sunflare how-to guides! These task-oriented guides provide practical solutions to common problems and tasks.</p>"},{"location":"how-to/#what-youll-find-here","title":"What you'll find here","text":"<p>How-to guides are task-oriented recipes that guide you through the steps to solve a specific problem or accomplish a specific task. They assume you have some basic knowledge of Sunflare.</p>"},{"location":"how-to/#available-guides","title":"Available Guides","text":""},{"location":"how-to/#getting-started","title":"Getting Started","text":"<ul> <li>Installation - How to install Sunflare in different environments</li> <li>Build Documentation - How to build the documentation locally</li> <li>Run Tests - How to run the test suite and generate coverage reports</li> </ul>"},{"location":"how-to/#need-help","title":"Need Help?","text":"<ul> <li>If you're new to Sunflare, start with the Tutorials</li> <li>For conceptual understanding, see the Explanation section</li> <li>For detailed technical information, check the API Reference</li> </ul>"},{"location":"how-to/build-docs/","title":"Build Documentation","text":"<p>This guide shows you how to build the Sunflare documentation locally.</p>"},{"location":"how-to/build-docs/#prerequisites","title":"Prerequisites","text":"<p>Make sure you have installed Sunflare with development dependencies.</p>"},{"location":"how-to/build-docs/#build-with-material-for-mkdocs","title":"Build with Material for MkDocs","text":"<p>You can build the documentation by running the following command from the project root:</p> <pre><code>uv run mkdocs build\n</code></pre> <p>The built documentation will be in the <code>site/</code> directory. Open <code>site/index.html</code> in your browser to view it.</p>"},{"location":"how-to/build-docs/#serve-documentation-locally","title":"Serve Documentation Locally","text":"<p>For development, you can serve the documentation with live reload:</p> <pre><code>uv run mkdocs serve\n</code></pre> <p>This will start a local server at <code>http://localhost:8000</code> and automatically rebuild the documentation when you make changes.</p>"},{"location":"how-to/build-docs/#deploy-versioned-documentation","title":"Deploy Versioned Documentation","text":"<p>Sunflare uses mike for multi-version documentation. To deploy a new version:</p> <pre><code># Deploy version 0.8.0 and tag it as 'latest'\nuv run mike deploy 0.8.0 latest --update-aliases\n\n# Set the default version\nuv run mike set-default latest\n\n# List all deployed versions\nuv run mike list\n\n# Serve all versions locally\nuv run mike serve\n</code></pre> <p>The versioned documentation is deployed to the <code>gh-pages</code> branch and hosted on GitHub Pages.</p>"},{"location":"how-to/build-docs/#troubleshooting","title":"Troubleshooting","text":""},{"location":"how-to/build-docs/#missing-dependencies","title":"Missing Dependencies","text":"<p>If you get errors about missing dependencies, make sure you've installed the development dependencies:</p> <pre><code>uv sync\n</code></pre>"},{"location":"how-to/build-docs/#port-already-in-use","title":"Port Already in Use","text":"<p>If port 8000 is already in use, you can specify a different port:</p> <pre><code>uv run mkdocs serve --dev-addr localhost:8080\n</code></pre>"},{"location":"how-to/build-docs/#cross-reference-warnings","title":"Cross-Reference Warnings","text":"<p>If you see warnings about missing cross-reference targets during build, verify that:</p> <ol> <li>The Python module/class/function exists in the codebase</li> <li>The docstring format is correct (NumPy style)</li> <li>The mkdocstrings configuration in <code>mkdocs.yml</code> is correct</li> </ol>"},{"location":"how-to/build-docs/#next-steps","title":"Next Steps","text":"<ul> <li>Learn how to run tests</li> <li>Read about Sunflare's architecture</li> </ul>"},{"location":"how-to/installation/","title":"Installation","text":"<p>This guide shows you how to install Sunflare in different environments.</p>"},{"location":"how-to/installation/#create-a-virtual-environment","title":"Create a Virtual Environment","text":"<p>It is recommended to install the package in a virtual environment.</p> uv (recommended)venvcondamamba <pre><code>uv venv --python 3.10\n\n# For Linux/macOS\nsource .venv/bin/activate\n\n# For Windows Command Prompt\n.venv\\Scripts\\activate.bat\n\n# For Windows PowerShell\n.venv\\Scripts\\Activate.ps1\n</code></pre> <pre><code># Python version depends on the globally installed Python\npython -m venv sunflare-env\n\n# For Linux/macOS\nsource sunflare-env/bin/activate\n\n# For Windows Command Prompt\nsunflare-env\\Scripts\\activate.bat\n\n# For Windows PowerShell\nsunflare-env\\Scripts\\Activate.ps1\n</code></pre> <pre><code>conda create -n sunflare-env python=3.10\nconda activate sunflare-env\n</code></pre> <pre><code>mamba create -n sunflare-env python=3.10\nmamba activate sunflare-env\n</code></pre>"},{"location":"how-to/installation/#install-sunflare","title":"Install Sunflare","text":"<p>You can install the package from PyPI or directly from the GitHub repository.</p> PyPIGitHub (Development) <pre><code>pip install -U sunflare\n\n# Or if you're using uv\nuv pip install sunflare\n</code></pre> <pre><code>git clone https://github.com/redsun-acquisition/sunflare.git\ncd sunflare\npip install -e .\n</code></pre>"},{"location":"how-to/installation/#install-development-dependencies","title":"Install Development Dependencies","text":"<p>If you're contributing to Sunflare or want to run tests locally, install the development dependencies via PEP-735 dependency groups.</p> uv (recommended)pip <pre><code># Dev dependencies are automatically synchronized\nuv sync\n</code></pre> <pre><code>pip install -e .[dev]\n</code></pre>"},{"location":"how-to/installation/#next-steps","title":"Next Steps","text":"<ul> <li>Learn how to build the documentation</li> <li>Learn how to run tests</li> <li>Check out the tutorials to get started with Sunflare</li> </ul>"},{"location":"how-to/run-tests/","title":"Run Tests","text":"<p>This guide shows you how to run the Sunflare test suite and generate coverage reports.</p>"},{"location":"how-to/run-tests/#prerequisites","title":"Prerequisites","text":"<p>Make sure you have installed Sunflare with development dependencies.</p>"},{"location":"how-to/run-tests/#run-all-tests","title":"Run All Tests","text":"<p>You can run the tests by running the following command from the project root:</p> <pre><code>pytest\n</code></pre>"},{"location":"how-to/run-tests/#generate-coverage-report","title":"Generate Coverage Report","text":"<p>You can obtain a test coverage report by running:</p> <pre><code>pytest --cov=sunflare --cov-report=html\n</code></pre> <p>This will generate an <code>htmlcov/</code> directory with the test coverage report. Open <code>htmlcov/index.html</code> in your browser to view it.</p>"},{"location":"how-to/run-tests/#run-tests-on-multiple-python-versions","title":"Run Tests on Multiple Python Versions","text":"<p>Sunflare provides a <code>noxfile.py</code> to run tests with <code>nox</code> on all supported Python versions.</p> <p>If you use <code>uv</code>, you can run tests as follows:</p> <pre><code># Install nox globally\nuv tool install nox\n\n# Run tests on all Python versions\nnox -s tests\n</code></pre> <p>This will test against all supported Python versions (3.10, 3.11, 3.12, 3.13).</p>"},{"location":"how-to/run-tests/#run-specific-tests","title":"Run Specific Tests","text":"<p>To run specific test files or test functions:</p> <pre><code># Run a specific test file\npytest tests/test_config.py\n\n# Run a specific test function\npytest tests/test_config.py::test_function_name\n\n# Run tests matching a pattern\npytest -k \"test_model\"\n</code></pre>"},{"location":"how-to/run-tests/#verbose-output","title":"Verbose Output","text":"<p>For more detailed output, use the <code>-v</code> flag:</p> <pre><code>pytest -v\n</code></pre>"},{"location":"how-to/run-tests/#stop-on-first-failure","title":"Stop on First Failure","text":"<p>To stop at the first failing test:</p> <pre><code>pytest -x\n</code></pre>"},{"location":"how-to/run-tests/#next-steps","title":"Next Steps","text":"<ul> <li>Learn how to build the documentation</li> <li>Understand Sunflare's architecture</li> <li>Check the API reference</li> </ul>"},{"location":"reference/","title":"Reference","text":"<p>Welcome to the Sunflare reference documentation! This section contains technical descriptions of the APIs, configuration options, and other reference material.</p>"},{"location":"reference/#what-youll-find-here","title":"What you'll find here","text":"<p>Reference guides are information-oriented technical descriptions. They provide detailed, accurate information about Sunflare's APIs, classes, and functions in a dry, factual manner.</p>"},{"location":"reference/#api-documentation","title":"API Documentation","text":"<ul> <li>Configuration - Configuration classes and options</li> <li>Engine - Core engine components</li> <li>Model - Model layer abstractions</li> <li>Controller - Controller/presenter components</li> <li>Virtual Bus - Event bus system</li> <li>Logging - Logging utilities</li> </ul>"},{"location":"reference/#version-history","title":"Version History","text":"<ul> <li>Changelog - Version history and release notes</li> </ul>"},{"location":"reference/#need-context","title":"Need Context?","text":"<ul> <li>For conceptual understanding of these components, see the Explanation section</li> <li>For practical usage examples, check the How-to Guides</li> <li>To learn the basics, start with the Tutorials</li> </ul>"},{"location":"reference/changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p> <p>Dates are specified in the format <code>DD-MM-YYYY</code>.</p>"},{"location":"reference/changelog/#080-21-12-2025","title":"0.8.0 - 21-12-2025","text":""},{"location":"reference/changelog/#removed","title":"Removed","text":"<ul> <li>Removed the overall dependency on <code>pyzmq</code> and <code>msgspec</code>:</li> <li>The original idea was to create a local network of document dispatch via the <code>inproc</code> protocol.</li> <li>This idea is now discarded and will be reworked in favor of a more consistent approach using multiple processes     controlled centrally by the application.</li> </ul>"},{"location":"reference/changelog/#changed","title":"Changed","text":"<ul> <li>Expose signals registered to the <code>VirtualBus</code> through the <code>signals</code> property.</li> </ul>"},{"location":"reference/changelog/#added","title":"Added","text":"<ul> <li>Add the ability to register callbacks in the <code>VirtualBus</code> for other components to retrieve (primarely other run engines).</li> <li>Expose callbacks via the <code>callbacks</code> property.</li> </ul>"},{"location":"reference/changelog/#070-15-12-2025","title":"0.7.0 - 15-12-2025","text":""},{"location":"reference/changelog/#changed_1","title":"Changed","text":"<ul> <li>Remove <code>__init__</code> from common protocols</li> <li>Make parameters of <code>__init__</code> as read-write protocol attributes</li> <li>Rename all protocols to make them shorter</li> <li>Remove the socket implementation from the RunEngine</li> <li>Unused and not accurate feature</li> </ul>"},{"location":"reference/changelog/#063-14-12-2025","title":"0.6.3 - 14-12-2025","text":""},{"location":"reference/changelog/#added_1","title":"Added","text":"<ul> <li>Add appropriate <code>resume</code> method to the <code>RunEngine</code> wrapper</li> <li>Ensure that it does not block the main thread</li> <li>Requires better documentation</li> </ul>"},{"location":"reference/changelog/#062-06-10-2025","title":"0.6.2 - 06-10-2025","text":""},{"location":"reference/changelog/#changed_2","title":"Changed","text":"<ul> <li>Synchronize all dependencies correctly via <code>uv</code></li> <li>Bump <code>bluesky</code> version to <code>1.14.5</code></li> <li>Fix type hints accordingly</li> <li>Trigger CI for docs deployment and PyPI publishing from GitHub release page</li> <li>Previously new tag had to be manually pushed from CLI</li> <li>Add support for Python 3.13</li> <li>Add <code>noxfile.py</code> to run tests via <code>nox</code> for multiple Python versions locally</li> </ul>"},{"location":"reference/changelog/#061-04-07-2025","title":"0.6.1 - 04-07-2025","text":""},{"location":"reference/changelog/#fixed","title":"Fixed","text":"<ul> <li>Inject <code>ViewInfoProtocol</code> and not the base class in the view base classes</li> </ul>"},{"location":"reference/changelog/#060-04-07-2025","title":"0.6.0 - 04-07-2025","text":""},{"location":"reference/changelog/#added_2","title":"Added","text":"<ul> <li>Added <code>sunflare.containers</code> module for dynamically registering protocols and plans</li> <li>Provided 4 functions<ul> <li><code>register/get_plans</code></li> <li><code>register/get_protocols</code></li> </ul> </li> <li>Plan signatures are unwrapped within <code>PlanSignature</code> dataclass object<ul> <li>The signatures can be retrieved via <code>get_signatures</code></li> </ul> </li> <li>Registered plans must be type annotated to be correctly registered and used by other plugins</li> <li>Added initial testing</li> </ul>"},{"location":"reference/changelog/#changed_3","title":"Changed","text":"<ul> <li>Dropped support for 3.9</li> <li>Removed usage of <code>Optional</code> and <code>Union</code></li> <li>Replaced with built-in <code>|</code> instead</li> <li>Switch to <code>uv</code> for dependency management</li> <li>Added <code>uv.lock</code> file</li> <li>Removed <code>engine</code> field from <code>RedsunSessionInfo</code></li> <li>Not really meaningful, was part of old concept</li> <li>Renamed <code>Widget</code> components to <code>View</code></li> <li>Ex-<code>Widget</code> classes are now injected with <code>ViewInfo</code> in initializer rather than <code>RedSunSessionInfo</code></li> </ul>"},{"location":"reference/changelog/#055-02-04-2025","title":"0.5.5 - 02-04-2025","text":""},{"location":"reference/changelog/#fixed_1","title":"Fixed","text":"<ul> <li>catch exception when <code>RunEngine.stop()</code> is called from main thread</li> </ul>"},{"location":"reference/changelog/#054-31-03-2025","title":"0.5.4 - 31-03-2025","text":""},{"location":"reference/changelog/#fixed_2","title":"Fixed","text":"<ul> <li>fixed <code>msgspec</code> decoding hook</li> <li>now returns the object when it's not of type <code>np.ndarray</code></li> <li>fixed <code>RunEngine</code> document emission</li> <li><code>emit</code> was failing to parse the document name</li> </ul>"},{"location":"reference/changelog/#053-25-03-2025","title":"0.5.3 - 25-03-2025","text":""},{"location":"reference/changelog/#changed_4","title":"Changed","text":"<ul> <li>Reworked <code>log.py</code></li> <li>When calling <code>obj.debug</code>, the line where the call was emitted redirected to <code>Loggable</code></li> <li>using a <code>logging.LoggerAdapter</code> prevents this</li> <li>it also make the usage of <code>Loggable</code> more consistent by simply returning a <code>cached_property</code>, which now enforces usage of <code>obj.logger.debug</code> which is less confusing</li> </ul>"},{"location":"reference/changelog/#052-13-03-2025","title":"0.5.2 - 13-03-2025","text":""},{"location":"reference/changelog/#changed_5","title":"Changed","text":"<ul> <li>Enhanced <code>sunflare.log</code> in order to separate log calls between two handlers.</li> </ul>"},{"location":"reference/changelog/#051-06-03-2025","title":"0.5.1 - 06-03-2025","text":""},{"location":"reference/changelog/#changed_6","title":"Changed","text":"<ul> <li>Dropped upper bound limit for <code>numpy</code> dependency</li> </ul>"},{"location":"reference/changelog/#050-03-03-2025","title":"0.5.0 - 03-03-2025","text":""},{"location":"reference/changelog/#changed_7","title":"Changed","text":"<ul> <li>Rearranged the structure of virtual-related classes</li> <li>Everything related to creating connections with the virtual bus have been brought to the <code>sunflare.virtual</code> module</li> <li>Set the default log level to <code>INFO</code> (was <code>DEBUG</code> before)</li> <li>Reworked <code>sunflare.config</code> to accomodate for new plugin system</li> </ul>"},{"location":"reference/changelog/#added_3","title":"Added","text":"<ul> <li>Added a <code>Model</code> base class for quicker development.</li> </ul>"},{"location":"reference/changelog/#removed_1","title":"Removed","text":"<ul> <li><code>configure</code> protocol is not part of the <code>ModelProtocol</code> anymore; see this PR</li> </ul>"},{"location":"reference/changelog/#042-24-02-2025","title":"0.4.2 - 24-02-2025","text":""},{"location":"reference/changelog/#changed_8","title":"Changed","text":"<ul> <li>Changed <code>ModelProtocol.configure</code> signature</li> <li>Previous signature was not consistent with the command issued by the <code>RunEngine</code></li> </ul>"},{"location":"reference/changelog/#041-23-02-2025","title":"0.4.1 - 23-02-2025","text":""},{"location":"reference/changelog/#added_4","title":"Added","text":"<ul> <li>Added support for <code>Mapping</code> types (i.e. <code>dict</code>) in <code>ModelInfo</code> methods (<code>read/describe_configuration</code>)</li> <li>Added optional parameters for <code>read/describe_configuration</code></li> <li><code>read_configuration</code>: <code>timestamp</code> (i.e. use <code>time.time()</code> for a timestamp of the last reading time)</li> <li><code>describe_configuration</code>: <code>source</code>, to specify the source of the configuration parameter</li> </ul>"},{"location":"reference/changelog/#040-22-02-2025","title":"0.4.0 - 22-02-2025","text":""},{"location":"reference/changelog/#added_5","title":"Added","text":"<ul> <li>Implemented support for ZMQ messaging via <code>pyzmq</code></li> <li>Added initial support for <code>msgspec</code></li> <li>Added mixin classes for creating publisher/subscribers</li> <li>Added mixin classes for <code>Signal</code>-enabled controllers</li> <li>Added more documentation for the virtual module</li> <li>Reorganized code in different modules to avoid circular imports</li> <li>Split controller in different protocols</li> <li>Added <code>ModelInfoProtocol</code> to deploy models from packages that don't have a strict dependency with Sunflare</li> <li>Added more tests, both for existing and new code</li> </ul>"},{"location":"reference/changelog/#035-11-02-2025","title":"0.3.5 - 11-02-2025","text":""},{"location":"reference/changelog/#added_6","title":"Added","text":"<ul> <li>Added protocol equivalent for <code>ModelInfo</code></li> <li>Currently untested</li> <li>This can be used in combination with <code>ModelProtocol</code> to define a Model interface from an external package without direct dependency to the <code>sunflare</code> package.</li> <li>Added documentation for <code>Controller</code></li> <li>Added tests for <code>RunEngine</code> wrapper</li> </ul>"},{"location":"reference/changelog/#changed_9","title":"Changed","text":"<ul> <li>Minor docstring and renaming fixes</li> <li><code>engine</code> and <code>frontend</code> fields of <code>RedSunSessionInfo</code> are not optional anymore</li> </ul>"},{"location":"reference/changelog/#fixed_3","title":"Fixed","text":"<ul> <li><code>RunEngine.__call__</code> fails in Python 3.9 unless explictly setting the event loop in the executor</li> </ul>"},{"location":"reference/changelog/#034-05-02-2025","title":"0.3.4 - 05-02-2025","text":""},{"location":"reference/changelog/#fixed_4","title":"Fixed","text":"<ul> <li>Fixed bug in <code>RedSunSessionInfo.store_yaml</code> which was not correctly parsing <code>Enum</code> and <code>tuple</code> types</li> </ul>"},{"location":"reference/changelog/#033-04-02-2025","title":"0.3.3 - 04-02-2025","text":""},{"location":"reference/changelog/#changed_10","title":"Changed","text":"<ul> <li>Minor renaming</li> <li>RedSun -&gt; Redsun</li> <li>SunFlare -&gt; Sunflare</li> </ul>"},{"location":"reference/changelog/#added_7","title":"Added","text":"<ul> <li>Added documentation</li> <li>Notions of O.O.P.</li> <li>Minimal model doc</li> <li>Added test for VirtualBus connection mechanism</li> <li>Added <code>WidgetInfo</code> class</li> <li>Provides information for widgets</li> <li>Redsun uses it to correctly allocate dock widgets in the main view</li> <li>Currently adapted to be used with <code>PyQt</code> and <code>PySide</code><ul> <li>For web-based frameworks may require adjustments somehow</li> </ul> </li> <li>Added <code>RedSunSessionInfo.store_yaml</code> to save the configuration file elsewhere</li> <li>We could think of supporting dynamic plugin loading; this would mean changing the content of <code>RedSunSessionInfo</code> on the fly.</li> </ul>"},{"location":"reference/changelog/#032-29-01-2025","title":"0.3.2 - 29-01-2025","text":""},{"location":"reference/changelog/#added_8","title":"Added","text":"<ul> <li><code>session</code> field in <code>RedSunSessionInfo</code></li> <li>used as main window title and as bluesky metadata</li> <li>added <code>**kwargs</code> to <code>configure</code> method</li> <li>need investigation on how to actually use it</li> <li>added optional <code>shutdown</code> method in <code>ModelProtocol</code></li> <li>it still must be implemented although not mandatory</li> </ul>"},{"location":"reference/changelog/#removed_2","title":"Removed","text":"<ul> <li>removed built-in protocols <code>Detector</code> and <code>Motor</code></li> <li>each plugin should take care of deciding what they are</li> </ul>"},{"location":"reference/changelog/#changed_11","title":"Changed","text":"<ul> <li>fixed metaclass error in <code>BaseQtWidget</code></li> </ul>"},{"location":"reference/changelog/#031-27-01-2025","title":"0.3.1 - 27-01-2025","text":""},{"location":"reference/changelog/#added_9","title":"Added","text":"<ul> <li>Added parts of <code>Configurable</code> protocol in <code>ModelInfo</code> for easier handling</li> </ul>"},{"location":"reference/changelog/#030-27-01-2025","title":"0.3.0 - 27-01-2025","text":""},{"location":"reference/changelog/#changed_12","title":"Changed","text":"<ul> <li>Refactor: simplify <code>virtual</code> module and remove <code>EngineHandler</code></li> <li>Use <code>typing_extensions.Protocol</code> in case of <code>Python &lt; 3.11</code></li> </ul>"},{"location":"reference/changelog/#added_10","title":"Added","text":"<ul> <li>Added a wrapper of <code>RunEngine</code> which leaves the main thread unblocked</li> </ul>"},{"location":"reference/changelog/#022-02-01-2025","title":"0.2.2 - 02-01-2025","text":""},{"location":"reference/changelog/#changed_13","title":"Changed","text":"<ul> <li>Correct engine handler API.</li> <li>Update CI action versions.</li> </ul>"},{"location":"reference/changelog/#021-02-01-2025","title":"0.2.1 - 02-01-2025","text":""},{"location":"reference/changelog/#changed_14","title":"Changed","text":"<ul> <li>Engine handler now stores plans as dictionary of dictionaries.</li> <li>The key of the main dictionary is the controller name which holds the plans;</li> <li>The values are dictionaries:<ul> <li>Keys are the plan names;</li> <li>Values are plans built with <code>functools.partial</code></li> </ul> </li> </ul>"},{"location":"reference/changelog/#020-31-12-2024","title":"0.2.0 - 31-12-2024","text":""},{"location":"reference/changelog/#added_11","title":"Added","text":"<ul> <li>Change configuration classes to use attrs in https://github.com/redsun-acquisition/sunflare/pull/8</li> <li>Model API rework in https://github.com/redsun-acquisition/sunflare/pull/9</li> </ul>"},{"location":"reference/changelog/#011-26-12-2024","title":"0.1.1 - 26-12-2024","text":"<ul> <li>Same changes as [v0.1.1a1]</li> <li>Some typo adjustments</li> </ul>"},{"location":"reference/changelog/#011a1-25-12-2024","title":"0.1.1a1 - 25-12-2024","text":"<p>(Only available on TestPyPI)</p>"},{"location":"reference/changelog/#added_12","title":"Added","text":"<ul> <li>Rework handler by @jacopoabramo in #6</li> <li>Reworked a lot of logic</li> <li>Models are now subclassed in Models for easier type hinting management</li> <li>Using RedSunInstanceInfo in handler</li> <li>RedSunInstance info now holds logic to load and check yaml file as static method</li> </ul>"},{"location":"reference/changelog/#010-23-12-2024","title":"0.1.0 - 23-12-2024","text":""},{"location":"reference/changelog/#added_13","title":"Added","text":"<ul> <li>First release on PyPI;</li> <li>Reached above 90% coverage;</li> </ul>"},{"location":"reference/changelog/#010a1-22-12-2024","title":"0.1.0a1 - 22-12-2024","text":"<p>(Only available on TestPyPI)</p>"},{"location":"reference/changelog/#added_14","title":"Added","text":"<ul> <li>Alpha release;</li> <li>Basic project infrastructure;</li> </ul>"},{"location":"reference/api/config/","title":"sunflare.config","text":""},{"location":"reference/api/config/#sunflare.config","title":"<code>config</code>","text":""},{"location":"reference/api/config/#sunflare.config.FrontendTypes","title":"<code>FrontendTypes</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Supported frontend types.</p> <p>Frontends are the supported GUI frameworks that are used to interact with the user.</p> <p>Attributes:</p> Name Type Description <code>PYQT</code> <p>PyQt6 frontend.</p> <code>PYSIDE</code> <p>PySide6 frontend.</p> Source code in <code>src/sunflare/config.py</code> <pre><code>@unique\nclass FrontendTypes(str, Enum):\n    \"\"\"Supported frontend types.\n\n    Frontends are the supported GUI frameworks that are used to interact with the user.\n\n    Attributes\n    ----------\n    PYQT\n        PyQt6 frontend.\n    PYSIDE\n        PySide6 frontend.\n    \"\"\"\n\n    PYQT = \"pyqt\"\n    PYSIDE = \"pyside\"\n</code></pre>"},{"location":"reference/api/config/#sunflare.config.WidgetPositionTypes","title":"<code>WidgetPositionTypes</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Supported widget position types.</p> <p>This enum is used to to define the position of a widget in the main view of the GUI.</p> <p>.. warning::</p> <pre><code>This enumerator refers to the usage of `QtWidget.DockWidget`;\nit may be changed in the future to support other GUI frameworks.\n</code></pre> <p>Attributes:</p> Name Type Description <code>LEFT</code> <p>Left widget position.</p> <code>RIGHT</code> <p>Right widget position.</p> <code>TOP</code> <p>Top widget position.</p> <code>BOTTOM</code> <p>Bottom widget position.</p> Source code in <code>src/sunflare/config.py</code> <pre><code>@unique\nclass WidgetPositionTypes(str, Enum):\n    \"\"\"Supported widget position types.\n\n    This enum is used to to define the\n    position of a widget in the main view of the GUI.\n\n    .. warning::\n\n        This enumerator refers to the usage of `QtWidget.DockWidget`;\n        it may be changed in the future to support other GUI frameworks.\n\n    Attributes\n    ----------\n    LEFT\n        Left widget position.\n    RIGHT\n        Right widget position.\n    TOP\n        Top widget position.\n    BOTTOM\n        Bottom widget position.\n    \"\"\"\n\n    CENTER = \"center\"\n    LEFT = \"left\"\n    RIGHT = \"right\"\n    TOP = \"top\"\n    BOTTOM = \"bottom\"\n</code></pre>"},{"location":"reference/api/config/#sunflare.config.PModelInfo","title":"<code>PModelInfo</code>","text":"<p>               Bases: <code>AttrsInstance</code>, <code>Protocol</code></p> <p>Protocol equivalent to <code>sunflare.config.ModelInfo</code>.</p> <p>This protocol allows to implement the <code>ModelInfo</code> class in packages that do not depend on <code>sunflare</code> directly.</p> <p>The only required dependency is <code>attrs</code>_.</p> <p>_attrs: https://www.attrs.org/en/stable/</p> Source code in <code>src/sunflare/config.py</code> <pre><code>@runtime_checkable\nclass PModelInfo(AttrsInstance, Protocol):\n    \"\"\"Protocol equivalent to `sunflare.config.ModelInfo`.\n\n    This protocol allows to implement the ``ModelInfo`` class\n    in packages that do not depend on ``sunflare`` directly.\n\n    The only required dependency is `attrs`_.\n\n    _attrs: https://www.attrs.org/en/stable/\n    \"\"\"\n\n    plugin_name: str\n    plugin_id: str\n\n    def read_configuration(self, timestamp: float) -&gt; dict[str, Any]:\n        \"\"\"See [`sunflare.config.ModelInfo.read_configuration`]().\"\"\"\n        ...\n\n    def describe_configuration(self, source: str) -&gt; dict[str, Any]:\n        \"\"\"See [`sunflare.config.ModelInfo.describe_configuration`]().\"\"\"\n        ...\n</code></pre>"},{"location":"reference/api/config/#sunflare.config.PModelInfo.read_configuration","title":"<code>read_configuration(timestamp)</code>","text":"<p>See <code>sunflare.config.ModelInfo.read_configuration</code>.</p> Source code in <code>src/sunflare/config.py</code> <pre><code>def read_configuration(self, timestamp: float) -&gt; dict[str, Any]:\n    \"\"\"See [`sunflare.config.ModelInfo.read_configuration`]().\"\"\"\n    ...\n</code></pre>"},{"location":"reference/api/config/#sunflare.config.PModelInfo.describe_configuration","title":"<code>describe_configuration(source)</code>","text":"<p>See <code>sunflare.config.ModelInfo.describe_configuration</code>.</p> Source code in <code>src/sunflare/config.py</code> <pre><code>def describe_configuration(self, source: str) -&gt; dict[str, Any]:\n    \"\"\"See [`sunflare.config.ModelInfo.describe_configuration`]().\"\"\"\n    ...\n</code></pre>"},{"location":"reference/api/config/#sunflare.config.PPresenterInfo","title":"<code>PPresenterInfo</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol equivalent to <code>sunflare.config.PresenterInfo</code>.</p> <p>Note</p> <p>This protocol is currently used only for type checking purposes within the Redsun application. In the future we might be able to expose this for usage in external packages.</p> Source code in <code>src/sunflare/config.py</code> <pre><code>@runtime_checkable\nclass PPresenterInfo(Protocol):\n    \"\"\"Protocol equivalent to `sunflare.config.PresenterInfo`.\n\n    !!! note\n        This protocol is currently used only for type checking purposes\n        within the Redsun application. In the future\n        we might be able to expose this for usage in\n        external packages.\n    \"\"\"\n\n    plugin_name: str\n    plugin_id: str\n</code></pre>"},{"location":"reference/api/config/#sunflare.config.PViewInfo","title":"<code>PViewInfo</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol equivalent to <code>sunflare.config.ViewInfo</code>.</p> <p>Note</p> <p>This protocol is currently used only for type checking purposes within the Redsun application. In the future we might be able to expose this for usage in external packages.</p> Source code in <code>src/sunflare/config.py</code> <pre><code>@runtime_checkable\nclass PViewInfo(Protocol):\n    \"\"\"Protocol equivalent to `sunflare.config.ViewInfo`.\n\n    !!! note\n        This protocol is currently used only for type checking purposes\n        within the Redsun application. In the future\n        we might be able to expose this for usage in\n        external packages.\n    \"\"\"\n\n    plugin_name: str\n    plugin_id: str\n    position: WidgetPositionTypes\n</code></pre>"},{"location":"reference/api/config/#sunflare.config.ViewInfo","title":"<code>ViewInfo</code>","text":"<p>               Bases: <code>PViewInfo</code></p> <p>View information model.</p> <p>All view information models inherit from this class.</p> <p>Attributes:</p> Name Type Description <code>plugin_name</code> <code>str</code> <p>Widget plugin name. Equivalent to the name of the PyPI/Conda package.</p> <code>plugin_id</code> <code>str</code> <p>Widget plugin ID. Associated with the exposed entry point in the plugin manifest.</p> <code>repository</code> <code>``str``, optional</code> <p>Widget repository URL. Defaults to <code>N/A</code>.</p> <code>position</code> <code>WidgetPositionTypes</code> <p>Widget position in the main view of the GUI.</p> Source code in <code>src/sunflare/config.py</code> <pre><code>@define(kw_only=True)\nclass ViewInfo(PViewInfo):\n    \"\"\"View information model.\n\n    All view information models inherit from this class.\n\n    Attributes\n    ----------\n    plugin_name : ``str``, optional\n        Widget plugin name.\n        Equivalent to the name of the PyPI/Conda package.\n    plugin_id : ``str``, optional\n        Widget plugin ID.\n        Associated with the exposed entry\n        point in the plugin manifest.\n    repository : ``str``, optional\n        Widget repository URL. Defaults to ``N/A``.\n    position : ``WidgetPositionTypes``\n        Widget position in the main view of the GUI.\n    \"\"\"\n\n    plugin_name: str = field(\n        validator=validators.instance_of(str), on_setattr=setters.frozen\n    )\n    plugin_id: str = field(\n        validator=validators.instance_of(str), on_setattr=setters.frozen\n    )\n    position: WidgetPositionTypes = field(\n        converter=_convert_widget_position_type,\n        validator=validators.in_(WidgetPositionTypes),\n        on_setattr=setters.frozen,\n    )\n</code></pre>"},{"location":"reference/api/config/#sunflare.config.PresenterInfo","title":"<code>PresenterInfo</code>","text":"<p>               Bases: <code>PPresenterInfo</code></p> <p>Presenter information model.</p> <p>All controller information models inherit from this class.</p> <p>Attributes:</p> Name Type Description <code>plugin_name</code> <code>str</code> <p>Presenter plugin name. Equivalent to the name of the PyPI/Conda package.</p> <code>plugin_id</code> <code>str</code> <p>Presenter plugin ID. Associated with the exposed entry point in the plugin manifest.</p> Source code in <code>src/sunflare/config.py</code> <pre><code>@define(kw_only=True)\nclass PresenterInfo(PPresenterInfo):\n    \"\"\"Presenter information model.\n\n    All controller information models inherit from this class.\n\n    Attributes\n    ----------\n    plugin_name : ``str``, optional\n        Presenter plugin name.\n        Equivalent to the name of the PyPI/Conda package.\n    plugin_id : ``str``, optional\n        Presenter plugin ID.\n        Associated with the exposed entry point\n        in the plugin manifest.\n    \"\"\"\n\n    plugin_name: str = field(\n        validator=validators.instance_of(str), on_setattr=setters.frozen\n    )\n    plugin_id: str = field(\n        validator=validators.instance_of(str), on_setattr=setters.frozen\n    )\n</code></pre>"},{"location":"reference/api/config/#sunflare.config.ModelInfo","title":"<code>ModelInfo</code>","text":"<p>               Bases: <code>PModelInfo</code></p> <p>Base model for device information.</p> <p>All device information models inherit from this class.</p> <p>Attributes:</p> Name Type Description <code>plugin_name</code> <code>str</code> <p>Model plugin name. Equivalent to the name of the PyPI/Conda package.</p> <code>plugin_id</code> <code>str</code> <p>Model plugin ID. Associated with the exposed entry point in the plugin manifest.</p> <code>vendor</code> <code>str</code> <p>Device vendor. Defaults to <code>N/A</code>.</p> <code>family</code> <code>str</code> <p>Device family (if applicable). Defaults to <code>N/A</code>.</p> <code>serial_number</code> <code>str</code> <p>Device serial number. Defaults to <code>N/A</code>.</p> Source code in <code>src/sunflare/config.py</code> <pre><code>@define(kw_only=True)\nclass ModelInfo(PModelInfo):\n    \"\"\"Base model for device information.\n\n    All device information models inherit from this class.\n\n    Attributes\n    ----------\n    plugin_name : ``str``, optional\n        Model plugin name.\n        Equivalent to the name of the PyPI/Conda package.\n    plugin_id : ``str``, optional\n        Model plugin ID.\n        Associated with the exposed entry point\n        in the plugin manifest.\n    vendor : ``str``, optional\n        Device vendor.\n        Defaults to ``N/A``.\n    family : ``str``, optional\n        Device family (if applicable).\n        Defaults to ``N/A``.\n    serial_number : ``str``, optional\n        Device serial number.\n        Defaults to ``N/A``.\n    \"\"\"\n\n    plugin_name: str = field(\n        validator=validators.instance_of(str), on_setattr=setters.frozen\n    )\n    plugin_id: str = field(\n        validator=validators.instance_of(str), on_setattr=setters.frozen\n    )\n    vendor: str = field(default=\"N/A\", validator=validators.instance_of(str))\n    family: str = field(\n        default=\"N/A\",\n        validator=validators.instance_of(str),\n    )\n    serial_number: str = field(\n        default=\"N/A\",\n        validator=validators.instance_of(str),\n    )\n\n    @cached_property\n    def _type_map(self) -&gt; dict[type, Dtype]:\n        \"\"\"Return the type map for the model information.\"\"\"\n        return {\n            str: \"string\",\n            float: \"number\",\n            int: \"integer\",\n            bool: \"boolean\",\n            list: \"array\",\n            tuple: \"array\",\n            dict: \"array\",\n            np.ndarray: \"array\",\n            Mapping: \"array\",\n        }\n\n    def __get_shape(self, value: Any) -&gt; list[int]:\n        if isinstance(value, Sized) and not isinstance(value, str):\n            if hasattr(value, \"shape\"):\n                return list(getattr(value, \"shape\"))\n            else:\n                return [len(value)]\n        return []\n\n    def __get_type(self, value: T) -&gt; Dtype:\n        return self._type_map[type(value)]\n\n    def read_configuration(self, timestamp: float = 0) -&gt; dict[str, Reading[Any]]:\n        \"\"\"Read the model information as a Bluesky configuration dictionary.\n\n        Parameters\n        ----------\n        timestamp : ``float``, optional\n            Timestamp of the configuration.\n            Use time.time() to get the current timestamp.\n            Defaults to 0.\n\n        Returns\n        -------\n        ``dict[str, Reading[Any]]``\n            A dictionary containing the model information,\n            compatible with Bluesky configuration representation.\n\n        Notes\n        -----\n        See the `Configurable`_ protocol.\n\n        .. _Configurable: https://blueskyproject.io/bluesky/main/hardware.html#bluesky.protocols.Configurable\n        \"\"\"\n        return {\n            **{\n                key: {\"value\": value, \"timestamp\": timestamp}\n                for key, value in asdict(self).items()\n                if key not in [\"plugin_name\", \"plugin_id\"]\n            }\n        }\n\n    def describe_configuration(\n        self, source: str = \"model_info\"\n    ) -&gt; dict[str, Descriptor]:\n        \"\"\"Describe the model information as a Bluesky configuration dictionary.\n\n        Parameters\n        ----------\n        source : ``str``, optional\n            Source of the configuration.\n            Defaults to ``model_info``.\n\n        Returns\n        -------\n        ``dict[str, Descriptor]``\n            A dictionary containing the model information description,\n            compatible with Bluesky configuration representation.\n\n        Notes\n        -----\n        See the `Configurable`_ protocol.\n\n        .. _Configurable: https://blueskyproject.io/bluesky/main/hardware.html#bluesky.protocols.Configurable\n        \"\"\"\n        return {\n            **{\n                key: {\n                    \"source\": source,\n                    \"dtype\": self.__get_type(value),\n                    \"shape\": self.__get_shape(value),  # type: ignore[typeddict-item]\n                }\n                for key, value in asdict(self).items()\n                if key not in [\"plugin_name\", \"plugin_id\"]\n            }\n        }\n</code></pre>"},{"location":"reference/api/config/#sunflare.config.ModelInfo.read_configuration","title":"<code>read_configuration(timestamp=0)</code>","text":"<p>Read the model information as a Bluesky configuration dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>``float``</code> <p>Timestamp of the configuration. Use time.time() to get the current timestamp. Defaults to 0.</p> <code>0</code> <p>Returns:</p> Type Description <code>``dict[str, Reading[Any]]``</code> <p>A dictionary containing the model information, compatible with Bluesky configuration representation.</p> Notes <p>See the <code>Configurable</code>_ protocol.</p> <p>.. _Configurable: https://blueskyproject.io/bluesky/main/hardware.html#bluesky.protocols.Configurable</p> Source code in <code>src/sunflare/config.py</code> <pre><code>def read_configuration(self, timestamp: float = 0) -&gt; dict[str, Reading[Any]]:\n    \"\"\"Read the model information as a Bluesky configuration dictionary.\n\n    Parameters\n    ----------\n    timestamp : ``float``, optional\n        Timestamp of the configuration.\n        Use time.time() to get the current timestamp.\n        Defaults to 0.\n\n    Returns\n    -------\n    ``dict[str, Reading[Any]]``\n        A dictionary containing the model information,\n        compatible with Bluesky configuration representation.\n\n    Notes\n    -----\n    See the `Configurable`_ protocol.\n\n    .. _Configurable: https://blueskyproject.io/bluesky/main/hardware.html#bluesky.protocols.Configurable\n    \"\"\"\n    return {\n        **{\n            key: {\"value\": value, \"timestamp\": timestamp}\n            for key, value in asdict(self).items()\n            if key not in [\"plugin_name\", \"plugin_id\"]\n        }\n    }\n</code></pre>"},{"location":"reference/api/config/#sunflare.config.ModelInfo.describe_configuration","title":"<code>describe_configuration(source='model_info')</code>","text":"<p>Describe the model information as a Bluesky configuration dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>``str``</code> <p>Source of the configuration. Defaults to <code>model_info</code>.</p> <code>'model_info'</code> <p>Returns:</p> Type Description <code>``dict[str, Descriptor]``</code> <p>A dictionary containing the model information description, compatible with Bluesky configuration representation.</p> Notes <p>See the <code>Configurable</code>_ protocol.</p> <p>.. _Configurable: https://blueskyproject.io/bluesky/main/hardware.html#bluesky.protocols.Configurable</p> Source code in <code>src/sunflare/config.py</code> <pre><code>def describe_configuration(\n    self, source: str = \"model_info\"\n) -&gt; dict[str, Descriptor]:\n    \"\"\"Describe the model information as a Bluesky configuration dictionary.\n\n    Parameters\n    ----------\n    source : ``str``, optional\n        Source of the configuration.\n        Defaults to ``model_info``.\n\n    Returns\n    -------\n    ``dict[str, Descriptor]``\n        A dictionary containing the model information description,\n        compatible with Bluesky configuration representation.\n\n    Notes\n    -----\n    See the `Configurable`_ protocol.\n\n    .. _Configurable: https://blueskyproject.io/bluesky/main/hardware.html#bluesky.protocols.Configurable\n    \"\"\"\n    return {\n        **{\n            key: {\n                \"source\": source,\n                \"dtype\": self.__get_type(value),\n                \"shape\": self.__get_shape(value),  # type: ignore[typeddict-item]\n            }\n            for key, value in asdict(self).items()\n            if key not in [\"plugin_name\", \"plugin_id\"]\n        }\n    }\n</code></pre>"},{"location":"reference/api/config/#sunflare.config.RedSunSessionInfo","title":"<code>RedSunSessionInfo</code>","text":"<p>Redsun session configuration class.</p> <p>This class is used to store the configuration of a running Redsun application; it provides information about the hardware layout and the selected acquisition engine.</p> <p>A minimal configuration must include:</p> <ul> <li>the selected frontend;</li> <li>the selected acquisition engine;</li> </ul> <p>Attributes:</p> Name Type Description <code>session</code> <code>str</code> <p>The name of the current session. Defaults to <code>Redsun</code>. It will be shown as the main window title.</p> <code>frontend</code> <code>FrontendTypes</code> <p>Frontend selected for the current session. Defaults to <code>FrontendTypes.PYQT</code>.</p> <code>controllers</code> <code>dict[str, PPresenterInfo]</code> <p>Presenter informations dictionary. Defaults to an empty dictionary.</p> <code>models</code> <code>dict[str, PModelInfo]</code> <p>Model informations dictionary. Defaults to an empty dictionary.</p> <code>views</code> <code>dict[str, PViewInfo]</code> <p>View informations dictionary. Defaults to an empty dictionary.</p> Source code in <code>src/sunflare/config.py</code> <pre><code>@define(kw_only=True, slots=True)\nclass RedSunSessionInfo:\n    \"\"\"Redsun session configuration class.\n\n    This class is used to store the configuration of a running Redsun application;\n    it provides information about the hardware layout and the selected acquisition engine.\n\n    A minimal configuration must include:\n\n    - the selected frontend;\n    - the selected acquisition engine;\n\n    Attributes\n    ----------\n    session: ``str``\n        The name of the current session. Defaults to ``Redsun``.\n        It will be shown as the main window title.\n    frontend : ``FrontendTypes``\n        Frontend selected for the current session.\n        Defaults to ``FrontendTypes.PYQT``.\n    controllers : ``dict[str, PresenterInfo]``\n        Presenter informations dictionary.\n        Defaults to an empty dictionary.\n    models : ``dict[str, ModelInfo]``\n        Model informations dictionary.\n        Defaults to an empty dictionary.\n    views : ``dict[str, ViewInfo]``\n        View informations dictionary.\n        Defaults to an empty dictionary.\n    \"\"\"\n\n    session: str = field(\n        default=\"Redsun\",\n        validator=validators.instance_of(str),\n        on_setattr=setters.frozen,\n    )\n    frontend: FrontendTypes = field(\n        converter=_convert_frontend_type,\n        validator=validators.in_(FrontendTypes),\n        on_setattr=setters.frozen,\n    )\n    models: dict[str, PModelInfo] = field(factory=dict)\n    controllers: dict[str, PPresenterInfo] = field(factory=dict)\n    views: dict[str, PViewInfo] = field(factory=dict)\n\n    @staticmethod\n    def load_yaml(path: str) -&gt; dict[str, Any]:\n        \"\"\"Load a YAML configuration file.\n\n        This method is invoked before the actual construction of the model. It will do\n        preliminary checks on the YAML file and store the configuration in a dictionary.\n\n        Parameters\n        ----------\n        path : ``str``\n            Path to the YAML file.\n\n        Returns\n        -------\n        ``dict[str, Any]``\n            A dictionary containing the configuration data.\n\n        Raises\n        ------\n        ``FileExistsError``\n            If the file does not exist.\n        ``FileNotFoundError``\n            If the path is not a file.\n        ``ValueError``\n            If the file is not a YAML file.\n        ``yaml.YAMLError``\n            If an error occurs while loading the file.\n        \"\"\"\n        logger = logging.getLogger(\"redsun\")\n\n        path_obj = Path(path)\n\n        data: dict[str, Any] = {}\n\n        if not path_obj.is_absolute():\n            path_obj = path_obj.resolve()\n\n        if not path_obj.exists():\n            logger.error(f\"The file {path} does not exist.\")\n            raise FileExistsError(f\"The file {path} does not exist.\")\n\n        if not path_obj.is_file():\n            logger.error(f\"The path {path} is not a file.\")\n            raise FileNotFoundError(f\"The path {path} is not a file.\")\n\n        if path_obj.suffix not in [\".yaml\", \".yml\"]:\n            logger.error(f\"The file {path} is not a YAML file.\")\n            raise ValueError(f\"The file {path} is not a YAML file.\")\n\n        try:\n            with open(path, \"r\") as file:\n                data = yaml.safe_load(file)\n        except yaml.YAMLError as e:\n            logger.exception(f\"Error loading YAML file {path}: {e}\")\n            raise yaml.YAMLError(f\"Error loading YAML file {path}: {e}\")\n\n        return data\n\n    def store_yaml(self, path: str) -&gt; None:\n        \"\"\"Store the configuration in a YAML file.\n\n        Parameters\n        ----------\n        path : ``str``\n            Path to the desired YAML file.\n        \"\"\"\n\n        def _serializer(inst: Any, field: Any, value: Any) -&gt; Any:\n            if isinstance(value, Enum):\n                return value.value\n            if isinstance(value, tuple):\n                return list(value)\n            return value\n\n        path_obj = Path(path)\n        with open(path_obj, \"w\") as file:\n            yaml.dump(asdict(self, value_serializer=_serializer), file, sort_keys=False)\n</code></pre>"},{"location":"reference/api/config/#sunflare.config.RedSunSessionInfo.load_yaml","title":"<code>load_yaml(path)</code>  <code>staticmethod</code>","text":"<p>Load a YAML configuration file.</p> <p>This method is invoked before the actual construction of the model. It will do preliminary checks on the YAML file and store the configuration in a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>``str``</code> <p>Path to the YAML file.</p> required <p>Returns:</p> Type Description <code>``dict[str, Any]``</code> <p>A dictionary containing the configuration data.</p> <p>Raises:</p> Type Description <code>``FileExistsError``</code> <p>If the file does not exist.</p> <code>``FileNotFoundError``</code> <p>If the path is not a file.</p> <code>``ValueError``</code> <p>If the file is not a YAML file.</p> <code>``yaml.YAMLError``</code> <p>If an error occurs while loading the file.</p> Source code in <code>src/sunflare/config.py</code> <pre><code>@staticmethod\ndef load_yaml(path: str) -&gt; dict[str, Any]:\n    \"\"\"Load a YAML configuration file.\n\n    This method is invoked before the actual construction of the model. It will do\n    preliminary checks on the YAML file and store the configuration in a dictionary.\n\n    Parameters\n    ----------\n    path : ``str``\n        Path to the YAML file.\n\n    Returns\n    -------\n    ``dict[str, Any]``\n        A dictionary containing the configuration data.\n\n    Raises\n    ------\n    ``FileExistsError``\n        If the file does not exist.\n    ``FileNotFoundError``\n        If the path is not a file.\n    ``ValueError``\n        If the file is not a YAML file.\n    ``yaml.YAMLError``\n        If an error occurs while loading the file.\n    \"\"\"\n    logger = logging.getLogger(\"redsun\")\n\n    path_obj = Path(path)\n\n    data: dict[str, Any] = {}\n\n    if not path_obj.is_absolute():\n        path_obj = path_obj.resolve()\n\n    if not path_obj.exists():\n        logger.error(f\"The file {path} does not exist.\")\n        raise FileExistsError(f\"The file {path} does not exist.\")\n\n    if not path_obj.is_file():\n        logger.error(f\"The path {path} is not a file.\")\n        raise FileNotFoundError(f\"The path {path} is not a file.\")\n\n    if path_obj.suffix not in [\".yaml\", \".yml\"]:\n        logger.error(f\"The file {path} is not a YAML file.\")\n        raise ValueError(f\"The file {path} is not a YAML file.\")\n\n    try:\n        with open(path, \"r\") as file:\n            data = yaml.safe_load(file)\n    except yaml.YAMLError as e:\n        logger.exception(f\"Error loading YAML file {path}: {e}\")\n        raise yaml.YAMLError(f\"Error loading YAML file {path}: {e}\")\n\n    return data\n</code></pre>"},{"location":"reference/api/config/#sunflare.config.RedSunSessionInfo.store_yaml","title":"<code>store_yaml(path)</code>","text":"<p>Store the configuration in a YAML file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>``str``</code> <p>Path to the desired YAML file.</p> required Source code in <code>src/sunflare/config.py</code> <pre><code>def store_yaml(self, path: str) -&gt; None:\n    \"\"\"Store the configuration in a YAML file.\n\n    Parameters\n    ----------\n    path : ``str``\n        Path to the desired YAML file.\n    \"\"\"\n\n    def _serializer(inst: Any, field: Any, value: Any) -&gt; Any:\n        if isinstance(value, Enum):\n            return value.value\n        if isinstance(value, tuple):\n            return list(value)\n        return value\n\n    path_obj = Path(path)\n    with open(path_obj, \"w\") as file:\n        yaml.dump(asdict(self, value_serializer=_serializer), file, sort_keys=False)\n</code></pre>"},{"location":"reference/api/config/#classes","title":"Classes","text":""},{"location":"reference/api/config/#sunflare.config.FrontendTypes","title":"<code>FrontendTypes</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Supported frontend types.</p> <p>Frontends are the supported GUI frameworks that are used to interact with the user.</p> <p>Attributes:</p> Name Type Description <code>PYQT</code> <p>PyQt6 frontend.</p> <code>PYSIDE</code> <p>PySide6 frontend.</p> Source code in <code>src/sunflare/config.py</code> <pre><code>@unique\nclass FrontendTypes(str, Enum):\n    \"\"\"Supported frontend types.\n\n    Frontends are the supported GUI frameworks that are used to interact with the user.\n\n    Attributes\n    ----------\n    PYQT\n        PyQt6 frontend.\n    PYSIDE\n        PySide6 frontend.\n    \"\"\"\n\n    PYQT = \"pyqt\"\n    PYSIDE = \"pyside\"\n</code></pre>"},{"location":"reference/api/config/#sunflare.config.PresenterInfo","title":"<code>PresenterInfo</code>","text":"<p>               Bases: <code>PPresenterInfo</code></p> <p>Presenter information model.</p> <p>All controller information models inherit from this class.</p> <p>Attributes:</p> Name Type Description <code>plugin_name</code> <code>str</code> <p>Presenter plugin name. Equivalent to the name of the PyPI/Conda package.</p> <code>plugin_id</code> <code>str</code> <p>Presenter plugin ID. Associated with the exposed entry point in the plugin manifest.</p> Source code in <code>src/sunflare/config.py</code> <pre><code>@define(kw_only=True)\nclass PresenterInfo(PPresenterInfo):\n    \"\"\"Presenter information model.\n\n    All controller information models inherit from this class.\n\n    Attributes\n    ----------\n    plugin_name : ``str``, optional\n        Presenter plugin name.\n        Equivalent to the name of the PyPI/Conda package.\n    plugin_id : ``str``, optional\n        Presenter plugin ID.\n        Associated with the exposed entry point\n        in the plugin manifest.\n    \"\"\"\n\n    plugin_name: str = field(\n        validator=validators.instance_of(str), on_setattr=setters.frozen\n    )\n    plugin_id: str = field(\n        validator=validators.instance_of(str), on_setattr=setters.frozen\n    )\n</code></pre>"},{"location":"reference/api/config/#sunflare.config.ModelInfo","title":"<code>ModelInfo</code>","text":"<p>               Bases: <code>PModelInfo</code></p> <p>Base model for device information.</p> <p>All device information models inherit from this class.</p> <p>Attributes:</p> Name Type Description <code>plugin_name</code> <code>str</code> <p>Model plugin name. Equivalent to the name of the PyPI/Conda package.</p> <code>plugin_id</code> <code>str</code> <p>Model plugin ID. Associated with the exposed entry point in the plugin manifest.</p> <code>vendor</code> <code>str</code> <p>Device vendor. Defaults to <code>N/A</code>.</p> <code>family</code> <code>str</code> <p>Device family (if applicable). Defaults to <code>N/A</code>.</p> <code>serial_number</code> <code>str</code> <p>Device serial number. Defaults to <code>N/A</code>.</p> Source code in <code>src/sunflare/config.py</code> <pre><code>@define(kw_only=True)\nclass ModelInfo(PModelInfo):\n    \"\"\"Base model for device information.\n\n    All device information models inherit from this class.\n\n    Attributes\n    ----------\n    plugin_name : ``str``, optional\n        Model plugin name.\n        Equivalent to the name of the PyPI/Conda package.\n    plugin_id : ``str``, optional\n        Model plugin ID.\n        Associated with the exposed entry point\n        in the plugin manifest.\n    vendor : ``str``, optional\n        Device vendor.\n        Defaults to ``N/A``.\n    family : ``str``, optional\n        Device family (if applicable).\n        Defaults to ``N/A``.\n    serial_number : ``str``, optional\n        Device serial number.\n        Defaults to ``N/A``.\n    \"\"\"\n\n    plugin_name: str = field(\n        validator=validators.instance_of(str), on_setattr=setters.frozen\n    )\n    plugin_id: str = field(\n        validator=validators.instance_of(str), on_setattr=setters.frozen\n    )\n    vendor: str = field(default=\"N/A\", validator=validators.instance_of(str))\n    family: str = field(\n        default=\"N/A\",\n        validator=validators.instance_of(str),\n    )\n    serial_number: str = field(\n        default=\"N/A\",\n        validator=validators.instance_of(str),\n    )\n\n    @cached_property\n    def _type_map(self) -&gt; dict[type, Dtype]:\n        \"\"\"Return the type map for the model information.\"\"\"\n        return {\n            str: \"string\",\n            float: \"number\",\n            int: \"integer\",\n            bool: \"boolean\",\n            list: \"array\",\n            tuple: \"array\",\n            dict: \"array\",\n            np.ndarray: \"array\",\n            Mapping: \"array\",\n        }\n\n    def __get_shape(self, value: Any) -&gt; list[int]:\n        if isinstance(value, Sized) and not isinstance(value, str):\n            if hasattr(value, \"shape\"):\n                return list(getattr(value, \"shape\"))\n            else:\n                return [len(value)]\n        return []\n\n    def __get_type(self, value: T) -&gt; Dtype:\n        return self._type_map[type(value)]\n\n    def read_configuration(self, timestamp: float = 0) -&gt; dict[str, Reading[Any]]:\n        \"\"\"Read the model information as a Bluesky configuration dictionary.\n\n        Parameters\n        ----------\n        timestamp : ``float``, optional\n            Timestamp of the configuration.\n            Use time.time() to get the current timestamp.\n            Defaults to 0.\n\n        Returns\n        -------\n        ``dict[str, Reading[Any]]``\n            A dictionary containing the model information,\n            compatible with Bluesky configuration representation.\n\n        Notes\n        -----\n        See the `Configurable`_ protocol.\n\n        .. _Configurable: https://blueskyproject.io/bluesky/main/hardware.html#bluesky.protocols.Configurable\n        \"\"\"\n        return {\n            **{\n                key: {\"value\": value, \"timestamp\": timestamp}\n                for key, value in asdict(self).items()\n                if key not in [\"plugin_name\", \"plugin_id\"]\n            }\n        }\n\n    def describe_configuration(\n        self, source: str = \"model_info\"\n    ) -&gt; dict[str, Descriptor]:\n        \"\"\"Describe the model information as a Bluesky configuration dictionary.\n\n        Parameters\n        ----------\n        source : ``str``, optional\n            Source of the configuration.\n            Defaults to ``model_info``.\n\n        Returns\n        -------\n        ``dict[str, Descriptor]``\n            A dictionary containing the model information description,\n            compatible with Bluesky configuration representation.\n\n        Notes\n        -----\n        See the `Configurable`_ protocol.\n\n        .. _Configurable: https://blueskyproject.io/bluesky/main/hardware.html#bluesky.protocols.Configurable\n        \"\"\"\n        return {\n            **{\n                key: {\n                    \"source\": source,\n                    \"dtype\": self.__get_type(value),\n                    \"shape\": self.__get_shape(value),  # type: ignore[typeddict-item]\n                }\n                for key, value in asdict(self).items()\n                if key not in [\"plugin_name\", \"plugin_id\"]\n            }\n        }\n</code></pre>"},{"location":"reference/api/config/#sunflare.config.ModelInfo.read_configuration","title":"<code>read_configuration(timestamp=0)</code>","text":"<p>Read the model information as a Bluesky configuration dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>``float``</code> <p>Timestamp of the configuration. Use time.time() to get the current timestamp. Defaults to 0.</p> <code>0</code> <p>Returns:</p> Type Description <code>``dict[str, Reading[Any]]``</code> <p>A dictionary containing the model information, compatible with Bluesky configuration representation.</p> Notes <p>See the <code>Configurable</code>_ protocol.</p> <p>.. _Configurable: https://blueskyproject.io/bluesky/main/hardware.html#bluesky.protocols.Configurable</p> Source code in <code>src/sunflare/config.py</code> <pre><code>def read_configuration(self, timestamp: float = 0) -&gt; dict[str, Reading[Any]]:\n    \"\"\"Read the model information as a Bluesky configuration dictionary.\n\n    Parameters\n    ----------\n    timestamp : ``float``, optional\n        Timestamp of the configuration.\n        Use time.time() to get the current timestamp.\n        Defaults to 0.\n\n    Returns\n    -------\n    ``dict[str, Reading[Any]]``\n        A dictionary containing the model information,\n        compatible with Bluesky configuration representation.\n\n    Notes\n    -----\n    See the `Configurable`_ protocol.\n\n    .. _Configurable: https://blueskyproject.io/bluesky/main/hardware.html#bluesky.protocols.Configurable\n    \"\"\"\n    return {\n        **{\n            key: {\"value\": value, \"timestamp\": timestamp}\n            for key, value in asdict(self).items()\n            if key not in [\"plugin_name\", \"plugin_id\"]\n        }\n    }\n</code></pre>"},{"location":"reference/api/config/#sunflare.config.ModelInfo.describe_configuration","title":"<code>describe_configuration(source='model_info')</code>","text":"<p>Describe the model information as a Bluesky configuration dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>``str``</code> <p>Source of the configuration. Defaults to <code>model_info</code>.</p> <code>'model_info'</code> <p>Returns:</p> Type Description <code>``dict[str, Descriptor]``</code> <p>A dictionary containing the model information description, compatible with Bluesky configuration representation.</p> Notes <p>See the <code>Configurable</code>_ protocol.</p> <p>.. _Configurable: https://blueskyproject.io/bluesky/main/hardware.html#bluesky.protocols.Configurable</p> Source code in <code>src/sunflare/config.py</code> <pre><code>def describe_configuration(\n    self, source: str = \"model_info\"\n) -&gt; dict[str, Descriptor]:\n    \"\"\"Describe the model information as a Bluesky configuration dictionary.\n\n    Parameters\n    ----------\n    source : ``str``, optional\n        Source of the configuration.\n        Defaults to ``model_info``.\n\n    Returns\n    -------\n    ``dict[str, Descriptor]``\n        A dictionary containing the model information description,\n        compatible with Bluesky configuration representation.\n\n    Notes\n    -----\n    See the `Configurable`_ protocol.\n\n    .. _Configurable: https://blueskyproject.io/bluesky/main/hardware.html#bluesky.protocols.Configurable\n    \"\"\"\n    return {\n        **{\n            key: {\n                \"source\": source,\n                \"dtype\": self.__get_type(value),\n                \"shape\": self.__get_shape(value),  # type: ignore[typeddict-item]\n            }\n            for key, value in asdict(self).items()\n            if key not in [\"plugin_name\", \"plugin_id\"]\n        }\n    }\n</code></pre>"},{"location":"reference/api/config/#sunflare.config.RedSunSessionInfo","title":"<code>RedSunSessionInfo</code>","text":"<p>Redsun session configuration class.</p> <p>This class is used to store the configuration of a running Redsun application; it provides information about the hardware layout and the selected acquisition engine.</p> <p>A minimal configuration must include:</p> <ul> <li>the selected frontend;</li> <li>the selected acquisition engine;</li> </ul> <p>Attributes:</p> Name Type Description <code>session</code> <code>str</code> <p>The name of the current session. Defaults to <code>Redsun</code>. It will be shown as the main window title.</p> <code>frontend</code> <code>FrontendTypes</code> <p>Frontend selected for the current session. Defaults to <code>FrontendTypes.PYQT</code>.</p> <code>controllers</code> <code>dict[str, PPresenterInfo]</code> <p>Presenter informations dictionary. Defaults to an empty dictionary.</p> <code>models</code> <code>dict[str, PModelInfo]</code> <p>Model informations dictionary. Defaults to an empty dictionary.</p> <code>views</code> <code>dict[str, PViewInfo]</code> <p>View informations dictionary. Defaults to an empty dictionary.</p> Source code in <code>src/sunflare/config.py</code> <pre><code>@define(kw_only=True, slots=True)\nclass RedSunSessionInfo:\n    \"\"\"Redsun session configuration class.\n\n    This class is used to store the configuration of a running Redsun application;\n    it provides information about the hardware layout and the selected acquisition engine.\n\n    A minimal configuration must include:\n\n    - the selected frontend;\n    - the selected acquisition engine;\n\n    Attributes\n    ----------\n    session: ``str``\n        The name of the current session. Defaults to ``Redsun``.\n        It will be shown as the main window title.\n    frontend : ``FrontendTypes``\n        Frontend selected for the current session.\n        Defaults to ``FrontendTypes.PYQT``.\n    controllers : ``dict[str, PresenterInfo]``\n        Presenter informations dictionary.\n        Defaults to an empty dictionary.\n    models : ``dict[str, ModelInfo]``\n        Model informations dictionary.\n        Defaults to an empty dictionary.\n    views : ``dict[str, ViewInfo]``\n        View informations dictionary.\n        Defaults to an empty dictionary.\n    \"\"\"\n\n    session: str = field(\n        default=\"Redsun\",\n        validator=validators.instance_of(str),\n        on_setattr=setters.frozen,\n    )\n    frontend: FrontendTypes = field(\n        converter=_convert_frontend_type,\n        validator=validators.in_(FrontendTypes),\n        on_setattr=setters.frozen,\n    )\n    models: dict[str, PModelInfo] = field(factory=dict)\n    controllers: dict[str, PPresenterInfo] = field(factory=dict)\n    views: dict[str, PViewInfo] = field(factory=dict)\n\n    @staticmethod\n    def load_yaml(path: str) -&gt; dict[str, Any]:\n        \"\"\"Load a YAML configuration file.\n\n        This method is invoked before the actual construction of the model. It will do\n        preliminary checks on the YAML file and store the configuration in a dictionary.\n\n        Parameters\n        ----------\n        path : ``str``\n            Path to the YAML file.\n\n        Returns\n        -------\n        ``dict[str, Any]``\n            A dictionary containing the configuration data.\n\n        Raises\n        ------\n        ``FileExistsError``\n            If the file does not exist.\n        ``FileNotFoundError``\n            If the path is not a file.\n        ``ValueError``\n            If the file is not a YAML file.\n        ``yaml.YAMLError``\n            If an error occurs while loading the file.\n        \"\"\"\n        logger = logging.getLogger(\"redsun\")\n\n        path_obj = Path(path)\n\n        data: dict[str, Any] = {}\n\n        if not path_obj.is_absolute():\n            path_obj = path_obj.resolve()\n\n        if not path_obj.exists():\n            logger.error(f\"The file {path} does not exist.\")\n            raise FileExistsError(f\"The file {path} does not exist.\")\n\n        if not path_obj.is_file():\n            logger.error(f\"The path {path} is not a file.\")\n            raise FileNotFoundError(f\"The path {path} is not a file.\")\n\n        if path_obj.suffix not in [\".yaml\", \".yml\"]:\n            logger.error(f\"The file {path} is not a YAML file.\")\n            raise ValueError(f\"The file {path} is not a YAML file.\")\n\n        try:\n            with open(path, \"r\") as file:\n                data = yaml.safe_load(file)\n        except yaml.YAMLError as e:\n            logger.exception(f\"Error loading YAML file {path}: {e}\")\n            raise yaml.YAMLError(f\"Error loading YAML file {path}: {e}\")\n\n        return data\n\n    def store_yaml(self, path: str) -&gt; None:\n        \"\"\"Store the configuration in a YAML file.\n\n        Parameters\n        ----------\n        path : ``str``\n            Path to the desired YAML file.\n        \"\"\"\n\n        def _serializer(inst: Any, field: Any, value: Any) -&gt; Any:\n            if isinstance(value, Enum):\n                return value.value\n            if isinstance(value, tuple):\n                return list(value)\n            return value\n\n        path_obj = Path(path)\n        with open(path_obj, \"w\") as file:\n            yaml.dump(asdict(self, value_serializer=_serializer), file, sort_keys=False)\n</code></pre>"},{"location":"reference/api/config/#sunflare.config.RedSunSessionInfo.load_yaml","title":"<code>load_yaml(path)</code>  <code>staticmethod</code>","text":"<p>Load a YAML configuration file.</p> <p>This method is invoked before the actual construction of the model. It will do preliminary checks on the YAML file and store the configuration in a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>``str``</code> <p>Path to the YAML file.</p> required <p>Returns:</p> Type Description <code>``dict[str, Any]``</code> <p>A dictionary containing the configuration data.</p> <p>Raises:</p> Type Description <code>``FileExistsError``</code> <p>If the file does not exist.</p> <code>``FileNotFoundError``</code> <p>If the path is not a file.</p> <code>``ValueError``</code> <p>If the file is not a YAML file.</p> <code>``yaml.YAMLError``</code> <p>If an error occurs while loading the file.</p> Source code in <code>src/sunflare/config.py</code> <pre><code>@staticmethod\ndef load_yaml(path: str) -&gt; dict[str, Any]:\n    \"\"\"Load a YAML configuration file.\n\n    This method is invoked before the actual construction of the model. It will do\n    preliminary checks on the YAML file and store the configuration in a dictionary.\n\n    Parameters\n    ----------\n    path : ``str``\n        Path to the YAML file.\n\n    Returns\n    -------\n    ``dict[str, Any]``\n        A dictionary containing the configuration data.\n\n    Raises\n    ------\n    ``FileExistsError``\n        If the file does not exist.\n    ``FileNotFoundError``\n        If the path is not a file.\n    ``ValueError``\n        If the file is not a YAML file.\n    ``yaml.YAMLError``\n        If an error occurs while loading the file.\n    \"\"\"\n    logger = logging.getLogger(\"redsun\")\n\n    path_obj = Path(path)\n\n    data: dict[str, Any] = {}\n\n    if not path_obj.is_absolute():\n        path_obj = path_obj.resolve()\n\n    if not path_obj.exists():\n        logger.error(f\"The file {path} does not exist.\")\n        raise FileExistsError(f\"The file {path} does not exist.\")\n\n    if not path_obj.is_file():\n        logger.error(f\"The path {path} is not a file.\")\n        raise FileNotFoundError(f\"The path {path} is not a file.\")\n\n    if path_obj.suffix not in [\".yaml\", \".yml\"]:\n        logger.error(f\"The file {path} is not a YAML file.\")\n        raise ValueError(f\"The file {path} is not a YAML file.\")\n\n    try:\n        with open(path, \"r\") as file:\n            data = yaml.safe_load(file)\n    except yaml.YAMLError as e:\n        logger.exception(f\"Error loading YAML file {path}: {e}\")\n        raise yaml.YAMLError(f\"Error loading YAML file {path}: {e}\")\n\n    return data\n</code></pre>"},{"location":"reference/api/config/#sunflare.config.RedSunSessionInfo.store_yaml","title":"<code>store_yaml(path)</code>","text":"<p>Store the configuration in a YAML file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>``str``</code> <p>Path to the desired YAML file.</p> required Source code in <code>src/sunflare/config.py</code> <pre><code>def store_yaml(self, path: str) -&gt; None:\n    \"\"\"Store the configuration in a YAML file.\n\n    Parameters\n    ----------\n    path : ``str``\n        Path to the desired YAML file.\n    \"\"\"\n\n    def _serializer(inst: Any, field: Any, value: Any) -&gt; Any:\n        if isinstance(value, Enum):\n            return value.value\n        if isinstance(value, tuple):\n            return list(value)\n        return value\n\n    path_obj = Path(path)\n    with open(path_obj, \"w\") as file:\n        yaml.dump(asdict(self, value_serializer=_serializer), file, sort_keys=False)\n</code></pre>"},{"location":"reference/api/controller/","title":"sunflare.presenter","text":"<p>Presenters come in two forms:</p>"},{"location":"reference/api/controller/#protocols","title":"Protocols","text":"<p><code>typing.Protocol</code> classes - no inheritance required, allows full customization of the controller:</p> <ul> <li>Users will have to implement each interface on their own in a controller class</li> <li>Available protocols:</li> <li><code>PPresenter</code> (for class initialization)</li> <li><code>HasShutdown</code> (for clearing held resources)</li> <li><code>HasRegistration</code> (for registering signals)</li> <li><code>HasConnection</code> (for connecting signals to local methods)</li> </ul>"},{"location":"reference/api/controller/#mixin-classes","title":"Mixin Classes","text":"<p>Boilerplate mixin classes - minimal, reusable components to provide a specific functionality:</p> <ul> <li>Inheritance is required</li> <li>Available mixins:</li> <li><code>Presenter</code> (minimal base controller)</li> <li><code>Sender</code> (implements <code>HasRegistration</code> protocol)</li> <li><code>Receiver</code> (implements <code>HasConnection</code> protocol)</li> <li><code>SenderReceiver</code> (union of previous two mixins)</li> </ul>"},{"location":"reference/api/controller/#api-reference","title":"API Reference","text":""},{"location":"reference/api/controller/#sunflare.presenter","title":"<code>presenter</code>","text":""},{"location":"reference/api/controller/#sunflare.presenter.Connection","title":"<code>Connection</code>","text":"<p>               Bases: <code>NamedTuple</code></p> <p>Connection tuple.</p> <p>Provides a type-hinted helper for describing a connection between a virtual bus signal and a local slot.</p> <p>Usable with <code>sunflare.presenter.Receiver</code> and <code>sunflare.presenter.SenderReceiver</code> to set the <code>connection_map</code> parameter.</p> <p>Attributes:</p> Name Type Description <code>signal</code> <code>ForwardRef('str')</code> <p>Signal name.</p> <code>slot</code> <code>ForwardRef('Callable[..., None]')</code> <p>Slot to connect to.</p> Source code in <code>src/sunflare/presenter/_base.py</code> <pre><code>class Connection(NamedTuple):\n    \"\"\"Connection tuple.\n\n    Provides a type-hinted helper\n    for describing a connection between\n    a virtual bus signal and a local slot.\n\n    Usable with [`sunflare.presenter.Receiver`]()\n    and [`sunflare.presenter.SenderReceiver`]()\n    to set the `connection_map` parameter.\n\n    Attributes\n    ----------\n    signal : ``str``\n        Signal name.\n    slot : ``Callable[..., None]``\n        Slot to connect to.\n    \"\"\"\n\n    signal: str\n    slot: Callable[..., None]\n</code></pre>"},{"location":"reference/api/controller/#sunflare.presenter.PPresenter","title":"<code>PPresenter</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Presenter protocol class.</p> <p>Provides the interface for a class that Redsun can recognize as a controller by implementing the defined attributes.</p> <p>Attributes:</p> Name Type Description <code>ctrl_info</code> <code>PPresenterInfo</code> <p>Presenter configuration information.</p> <code>models</code> <code>Mapping[str, PModel]</code> <p>Reference to the models used in the controller.</p> <code>virtual_bus</code> <code>VirtualBus</code> <p>Reference to the virtual bus.</p> Source code in <code>src/sunflare/presenter/_base.py</code> <pre><code>@runtime_checkable\nclass PPresenter(Protocol):  # pragma: no cover\n    \"\"\"Presenter protocol class.\n\n    Provides the interface for a class\n    that Redsun can recognize as a controller by\n    implementing the defined attributes.\n\n    Attributes\n    ----------\n    ctrl_info : PPresenterInfo\n        Presenter configuration information.\n    models : Mapping[str, PModel]\n        Reference to the models used in the controller.\n    virtual_bus : VirtualBus\n        Reference to the virtual bus.\n    \"\"\"\n\n    ctrl_info: PPresenterInfo\n    virtual_bus: VirtualBus\n    models: Mapping[str, PModel]\n</code></pre>"},{"location":"reference/api/controller/#sunflare.presenter.Presenter","title":"<code>Presenter</code>","text":"<p>               Bases: <code>PPresenter</code>, <code>Generic[CI]</code></p> <p>A boilerplate base class for quick development.</p> <p>Users may subclass from this controller and provide their custom <code>sunflare.config.PresenterInfo</code> implementation.</p> <p>Example usage:</p> <pre><code>from sunflare.presenter import Presenter\nfrom sunflare.config import PresenterInfo\nfrom attrs import define\n\n\n@define\nclass MyControllerInfo(PresenterInfo):\n    str_param: str\n    bool_param: bool\n    # any other parameters...\n\n\nclass MyController(Presenter[MyControllerInfo]):\n    def __init__(\n        self,\n        ctrl_info: MyControllerInfo,\n        models: Mapping[str, PModel],\n        virtual_bus: VirtualBus,\n    ) -&gt; None:\n        super().__init__(ctrl_info, models, virtual_bus)\n        # any other initialization code...\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>ctrl_info</code> <code>``CI``</code> <p>Instance of <code>sunflare.config.PresenterInfo</code> subclass.</p> required <code>models</code> <code>``Mapping[str, PModel]``</code> <p>Reference to the models used in the controller.</p> required <code>virtual_bus</code> <code>`sunflare.virtual.VirtualBus`</code> <p>Reference to the virtual bus.</p> required Source code in <code>src/sunflare/presenter/_base.py</code> <pre><code>class Presenter(PPresenter, Generic[CI]):\n    \"\"\"A boilerplate base class for quick development.\n\n    Users may subclass from this controller and provide their custom\n    `sunflare.config.PresenterInfo` implementation.\n\n    Example usage:\n\n    ```python\n    from sunflare.presenter import Presenter\n    from sunflare.config import PresenterInfo\n    from attrs import define\n\n\n    @define\n    class MyControllerInfo(PresenterInfo):\n        str_param: str\n        bool_param: bool\n        # any other parameters...\n\n\n    class MyController(Presenter[MyControllerInfo]):\n        def __init__(\n            self,\n            ctrl_info: MyControllerInfo,\n            models: Mapping[str, PModel],\n            virtual_bus: VirtualBus,\n        ) -&gt; None:\n            super().__init__(ctrl_info, models, virtual_bus)\n            # any other initialization code...\n    ```\n\n    Parameters\n    ----------\n    ctrl_info : ``CI``\n        Instance of `sunflare.config.PresenterInfo` subclass.\n    models : ``Mapping[str, PModel]``\n        Reference to the models used in the controller.\n    virtual_bus : `sunflare.virtual.VirtualBus`\n        Reference to the virtual bus.\n    \"\"\"\n\n    def __init__(\n        self,\n        ctrl_info: CI,\n        models: Mapping[str, PModel],\n        virtual_bus: VirtualBus,\n    ) -&gt; None:\n        self.ctrl_info = ctrl_info\n        self.models = models\n        self.virtual_bus = virtual_bus\n</code></pre>"},{"location":"reference/api/controller/#sunflare.presenter.Receiver","title":"<code>Receiver</code>","text":"<p>               Bases: <code>Presenter[CI]</code></p> <p>A controller capable of connecting signals exposed in the virtual bus to local slots.</p> <p>Provides an additional <code>connection_map</code> parameter to the constructor to optionally connect a group of the controller's defined signals to local slots.</p> <p>Users may subclass from this controller and provide their custom :class:<code>~sunflare.config.PresenterInfo</code> implementation.</p> <p>Example usage:</p> <pre><code>from sunflare.presenter import ReceiverController\nfrom sunflare.config import PresenterInfo\nfrom attrs import define\n\n@define\nclass MyControllerInfo(PresenterInfo):\n    str_param: str\n    bool_param: bool\n    # any other parameters...\n\nclass MyController(ReceiverController[MyControllerInfo]):\n    def __init__(\n        self,\n        ctrl_info: MyControllerInfo,\n        models: Mapping[str, PModel],\n        virtual_bus: VirtualBus,\n    ) -&gt; None:\n        connection_map = {\n            \"WidgetEmitter\": [\n                Connection(\"sigWidgetSignal1\", self.widget_slot),\n                Connection(\"sigWidgetSignal2\", self.other_widget_slot)\n            ],\n            \"ControllerEmitter\": [\n                Connection(\"sigControllerSignal\", self.controller_slot),\n            ],\n        }\n        super().__init__(ctrl_info, models, virtual_bus, connection_map)\n        # any other initialization code...\n\n    def widget_slot(self, *args, **kwargs) -&gt; None:\n        # your logic here...\n\n    def other_widget_slot(self, *args, **kwargs) -&gt; None:\n        # your logic here...\n\n    def controller_slot(self, *args, **kwargs) -&gt; None:\n        # your logic here...\n</code></pre> <p>Note</p> <p>The controller slots should respect the signals' signatures in order to correctly receive the emitted signals. Make sure to review any provided documentation about the nature of the signals being connected.</p> <p>See <code>sunflare.presenter.Presenter</code> for parent information.</p> <p>Parameters:</p> Name Type Description Default <code>ctrl_info</code> <code>``CI``</code> <p>Instance of a <code>sunflare.config.PresenterInfo</code> subclass.</p> required <code>models</code> <code>``Mapping[str, PModel]``</code> <p>Reference to the models used in the controller.</p> required <code>virtual_bus</code> <code>`sunflare.virtual.VirtualBus`</code> <p>Reference to the virtual bus.</p> required <code>connection_map</code> <code>``Mapping[str, list[Connection]]``</code> <p>Mapping of emitters to a list of connections. Default is <code>None</code> (no connections).</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>connection_map</code> <code>``Mapping[str, list[Connection]]``, keyword-only, optional</code> <p>Mapping of emitters to a list of connections.</p> Source code in <code>src/sunflare/presenter/_base.py</code> <pre><code>class Receiver(Presenter[CI]):\n    \"\"\"A controller capable of connecting signals exposed in the virtual bus to local slots.\n\n    Provides an additional `connection_map` parameter to the constructor\n    to optionally connect a group of the controller's defined signals to local slots.\n\n    Users may subclass from this controller and provide their custom\n    :class:`~sunflare.config.PresenterInfo` implementation.\n\n    Example usage:\n\n    ```python\n    from sunflare.presenter import ReceiverController\n    from sunflare.config import PresenterInfo\n    from attrs import define\n\n    @define\n    class MyControllerInfo(PresenterInfo):\n        str_param: str\n        bool_param: bool\n        # any other parameters...\n\n    class MyController(ReceiverController[MyControllerInfo]):\n        def __init__(\n            self,\n            ctrl_info: MyControllerInfo,\n            models: Mapping[str, PModel],\n            virtual_bus: VirtualBus,\n        ) -&gt; None:\n            connection_map = {\n                \"WidgetEmitter\": [\n                    Connection(\"sigWidgetSignal1\", self.widget_slot),\n                    Connection(\"sigWidgetSignal2\", self.other_widget_slot)\n                ],\n                \"ControllerEmitter\": [\n                    Connection(\"sigControllerSignal\", self.controller_slot),\n                ],\n            }\n            super().__init__(ctrl_info, models, virtual_bus, connection_map)\n            # any other initialization code...\n\n        def widget_slot(self, *args, **kwargs) -&gt; None:\n            # your logic here...\n\n        def other_widget_slot(self, *args, **kwargs) -&gt; None:\n            # your logic here...\n\n        def controller_slot(self, *args, **kwargs) -&gt; None:\n            # your logic here...\n    ```\n\n    !!! note\n        The controller slots should respect the signals' signatures\n        in order to correctly receive the emitted signals.\n        Make sure to review any provided documentation\n        about the nature of the signals being connected.\n\n    See [`sunflare.presenter.Presenter`]() for parent information.\n\n    Parameters\n    ----------\n    ctrl_info : ``CI``\n        Instance of a `sunflare.config.PresenterInfo` subclass.\n    models : ``Mapping[str, PModel]``\n        Reference to the models used in the controller.\n    virtual_bus : `sunflare.virtual.VirtualBus`\n        Reference to the virtual bus.\n    connection_map : ``Mapping[str, list[Connection]]``, optional\n        Mapping of emitters to a list of connections.\n        Default is ``None`` (no connections).\n\n    Attributes\n    ----------\n    connection_map : ``Mapping[str, list[Connection]]``, keyword-only, optional\n        Mapping of emitters to a list of connections.\n    \"\"\"\n\n    def __init__(\n        self,\n        ctrl_info: CI,\n        models: Mapping[str, PModel],\n        virtual_bus: VirtualBus,\n        *,\n        connection_map: Mapping[str, list[Connection]] | None = None,\n    ) -&gt; None:\n        self.connection_map = connection_map\n        super().__init__(ctrl_info, models, virtual_bus)\n\n    def connection_phase(self) -&gt; None:\n        \"\"\"Connect the signals defined in ``self.connection_map``.\n\n        This method is called from Redsun during\n        application initialization.\n        \"\"\"\n        if self.connection_map is not None:\n            for emitter, connections in self.connection_map.items():\n                for connection in connections:\n                    self.virtual_bus.signals[emitter][connection.signal].connect(\n                        connection.slot\n                    )\n</code></pre>"},{"location":"reference/api/controller/#sunflare.presenter.Receiver.connection_phase","title":"<code>connection_phase()</code>","text":"<p>Connect the signals defined in <code>self.connection_map</code>.</p> <p>This method is called from Redsun during application initialization.</p> Source code in <code>src/sunflare/presenter/_base.py</code> <pre><code>def connection_phase(self) -&gt; None:\n    \"\"\"Connect the signals defined in ``self.connection_map``.\n\n    This method is called from Redsun during\n    application initialization.\n    \"\"\"\n    if self.connection_map is not None:\n        for emitter, connections in self.connection_map.items():\n            for connection in connections:\n                self.virtual_bus.signals[emitter][connection.signal].connect(\n                    connection.slot\n                )\n</code></pre>"},{"location":"reference/api/controller/#sunflare.presenter.Sender","title":"<code>Sender</code>","text":"<p>               Bases: <code>Presenter[CI]</code></p> <p>A controller capable of emitting signals to the virtual bus.</p> <p>Provides an additional <code>signals</code> parameter to the constructor to optionally register a group of the controller's defined signals.</p> <p>Users may subclass from this controller and provide their custom <code>sunflare.config.PresenterInfo</code> implementation.</p> <p>Example usage:</p> <pre><code>from sunflare.presenter import SignalerController\nfrom sunflare.config import PresenterInfo\nfrom attrs import define\n\n\n@define\nclass MyControllerInfo(PresenterInfo):\n    str_param: str\n    bool_param: bool\n    # any other parameters...\n\n\nclass MyController(SignalerController[MyControllerInfo]):\n    sigRegisteredSignal = Signal(str)\n    sigUnregisteredSignal = Signal(int)\n\n    def __init__(\n        self,\n        ctrl_info: MyControllerInfo,\n        models: Mapping[str, PModel],\n        virtual_bus: VirtualBus,\n    ) -&gt; None:\n        signals = [\"sigRegisteredSignal\"]\n        super().__init__(ctrl_info, models, virtual_bus, signals)\n        # any other initialization code...\n</code></pre> <p>See <code>sunflare.presenter.Presenter</code> for parent information.</p> <p>Note</p> <p>Users should carefully document the data transmitted by the signals to ensure other endpoints can easily connect to them.</p> <p>Parameters:</p> Name Type Description Default <code>ctrl_info</code> <code>``CI``</code> <p>Instance of a <code>sunflare.config.PresenterInfo</code> subclass.</p> required <code>models</code> <code>``Mapping[str, PModel]``</code> <p>Reference to the models used in the controller.</p> required <code>virtual_bus</code> <code>`sunflare.virtual.VirtualBus`</code> <p>Reference to the virtual bus.</p> required <code>signals</code> <code>``Sequence[str]``, keyword-only</code> <p>Sequence of signals to register. Default is <code>None</code> (no signals registered).</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>signals</code> <code>``Sequence[str]``, optional</code> <p>Sequence of registered signals.</p> Source code in <code>src/sunflare/presenter/_base.py</code> <pre><code>class Sender(Presenter[CI]):\n    \"\"\"A controller capable of emitting signals to the virtual bus.\n\n    Provides an additional `signals` parameter to the constructor\n    to optionally register a group of the controller's defined\n    signals.\n\n    Users may subclass from this controller and provide their custom\n    `sunflare.config.PresenterInfo` implementation.\n\n    Example usage:\n\n    ```python\n    from sunflare.presenter import SignalerController\n    from sunflare.config import PresenterInfo\n    from attrs import define\n\n\n    @define\n    class MyControllerInfo(PresenterInfo):\n        str_param: str\n        bool_param: bool\n        # any other parameters...\n\n\n    class MyController(SignalerController[MyControllerInfo]):\n        sigRegisteredSignal = Signal(str)\n        sigUnregisteredSignal = Signal(int)\n\n        def __init__(\n            self,\n            ctrl_info: MyControllerInfo,\n            models: Mapping[str, PModel],\n            virtual_bus: VirtualBus,\n        ) -&gt; None:\n            signals = [\"sigRegisteredSignal\"]\n            super().__init__(ctrl_info, models, virtual_bus, signals)\n            # any other initialization code...\n    ```\n\n    See [`sunflare.presenter.Presenter`]() for parent information.\n\n    !!! note\n        Users should carefully document the data transmitted by the signals\n        to ensure other endpoints can easily connect to them.\n\n    Parameters\n    ----------\n    ctrl_info : ``CI``\n        Instance of a `sunflare.config.PresenterInfo` subclass.\n    models : ``Mapping[str, PModel]``\n        Reference to the models used in the controller.\n    virtual_bus : `sunflare.virtual.VirtualBus`\n        Reference to the virtual bus.\n    signals : ``Sequence[str]``, keyword-only, optional\n        Sequence of signals to register.\n        Default is ``None`` (no signals registered).\n\n    Attributes\n    ----------\n    signals : ``Sequence[str]``, optional\n        Sequence of registered signals.\n    \"\"\"\n\n    def __init__(\n        self,\n        ctrl_info: CI,\n        models: Mapping[str, PModel],\n        virtual_bus: VirtualBus,\n        *,\n        signals: Sequence[str] | None = None,\n    ) -&gt; None:\n        self.signals = signals\n        super().__init__(ctrl_info, models, virtual_bus)\n\n    def registration_phase(self) -&gt; None:\n        \"\"\"Register the signals defined in ``self.signals``.\n\n        This method is called from Redsun during\n        application initialization.\n        \"\"\"\n        self.virtual_bus.register_signals(self, self.signals)\n</code></pre>"},{"location":"reference/api/controller/#sunflare.presenter.Sender.registration_phase","title":"<code>registration_phase()</code>","text":"<p>Register the signals defined in <code>self.signals</code>.</p> <p>This method is called from Redsun during application initialization.</p> Source code in <code>src/sunflare/presenter/_base.py</code> <pre><code>def registration_phase(self) -&gt; None:\n    \"\"\"Register the signals defined in ``self.signals``.\n\n    This method is called from Redsun during\n    application initialization.\n    \"\"\"\n    self.virtual_bus.register_signals(self, self.signals)\n</code></pre>"},{"location":"reference/api/controller/#sunflare.presenter.SenderReceiver","title":"<code>SenderReceiver</code>","text":"<p>               Bases: <code>Presenter[CI]</code></p> <p>Combines the functionality of <code>sunflare.presenter.Sender</code> and <code>sunflare.presenter.Receiver</code>.</p> <p>Users may subclass from this controller and provide their custom <code>sunflare.config.PresenterInfo</code> implementation.</p> <p>Example usage:</p> <p>.. code-block:: python</p> <pre><code>from sunflare.presenter import SenderReceiverController\nfrom sunflare.config import PresenterInfo\nfrom attrs import define\n\n@define\nclass MyControllerInfo(PresenterInfo):\n    str_param: str\n    bool_param: bool\n    # any other parameters...\n\nclass MyController(SenderReceiverController[MyControllerInfo]):\n    sigRegisteredSignal = Signal(str)\n    sigUnregisteredSignal = Signal(int)\n\n    def __init__(\n        self,\n        ctrl_info: MyControllerInfo,\n        models: Mapping[str, PModel],\n        virtual_bus: VirtualBus,\n    ) -&gt; None:\n        signals = [\"sigRegisteredSignal\"]\n        connection_map = {\n            \"WidgetEmitter\": [\n                Connection(\"sigWidgetSignal1\", self.widget_slot),\n                # you can recover the slot with \"getattr(self, &lt;slot_name&gt;)\" too\n                Connection(\"sigWidgetSignal2\", getattr(self, \"other_widget_slot\"))\n            ],\n            \"ControllerEmitter\": [\n                Connection(\"sigControllerSignal\", self.controller_slot),\n            ],\n        }\n        super().__init__(ctrl_info, models, virtual_bus, signals, connection_map)\n        # any other initialization code...\n\n    def widget_slot(self, *args, **kwargs) -&gt; None:\n        # your logic here...\n\n    def other_widget_slot(self, *args, **kwargs) -&gt; None:\n        # your logic here...\n\n    def controller_slot(self, *args, **kwargs) -&gt; None:\n        # your logic here...\n\n.. note::\n\n    The controller slots should respect the signals' signatures\n    in order to correctly receive the emitted signals.\n    Make sure to review any provided documentation\n    about the nature of the signals being connected.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>ctrl_info</code> <code>``CI``</code> <p>Instance of a <code>sunflare.config.PresenterInfo</code> subclass.</p> required <code>models</code> <code>``Mapping[str, PModel]``</code> <p>Reference to the models used in the controller.</p> required <code>virtual_bus</code> <code>`sunflare.virtual.VirtualBus`</code> <p>Reference to the virtual bus.</p> required <code>signals</code> <code>``Sequence[str]``</code> <p>Sequence of signals to register. Default is <code>None</code> (no signals registered).</p> <code>None</code> <code>connection_map</code> <code>``Mapping[str, list[Connection]]``</code> <p>Mapping of emitters to a list of connections. Default is <code>None</code> (no connections).</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>signals</code> <code>``Sequence[str]``, optional</code> <p>Sequence of registered signals.</p> <code>connection_map</code> <code>``Mapping[str, list[Connection]]``, optional</code> <p>Mapping of emitters to a list of connections.</p> Source code in <code>src/sunflare/presenter/_base.py</code> <pre><code>class SenderReceiver(Presenter[CI]):\n    \"\"\"Combines the functionality of [`sunflare.presenter.Sender`]() and [`sunflare.presenter.Receiver`]().\n\n    Users may subclass from this controller and provide their custom\n    `sunflare.config.PresenterInfo` implementation.\n\n    Example usage:\n\n    .. code-block:: python\n\n        from sunflare.presenter import SenderReceiverController\n        from sunflare.config import PresenterInfo\n        from attrs import define\n\n        @define\n        class MyControllerInfo(PresenterInfo):\n            str_param: str\n            bool_param: bool\n            # any other parameters...\n\n        class MyController(SenderReceiverController[MyControllerInfo]):\n            sigRegisteredSignal = Signal(str)\n            sigUnregisteredSignal = Signal(int)\n\n            def __init__(\n                self,\n                ctrl_info: MyControllerInfo,\n                models: Mapping[str, PModel],\n                virtual_bus: VirtualBus,\n            ) -&gt; None:\n                signals = [\"sigRegisteredSignal\"]\n                connection_map = {\n                    \"WidgetEmitter\": [\n                        Connection(\"sigWidgetSignal1\", self.widget_slot),\n                        # you can recover the slot with \"getattr(self, &lt;slot_name&gt;)\" too\n                        Connection(\"sigWidgetSignal2\", getattr(self, \"other_widget_slot\"))\n                    ],\n                    \"ControllerEmitter\": [\n                        Connection(\"sigControllerSignal\", self.controller_slot),\n                    ],\n                }\n                super().__init__(ctrl_info, models, virtual_bus, signals, connection_map)\n                # any other initialization code...\n\n            def widget_slot(self, *args, **kwargs) -&gt; None:\n                # your logic here...\n\n            def other_widget_slot(self, *args, **kwargs) -&gt; None:\n                # your logic here...\n\n            def controller_slot(self, *args, **kwargs) -&gt; None:\n                # your logic here...\n\n        .. note::\n\n            The controller slots should respect the signals' signatures\n            in order to correctly receive the emitted signals.\n            Make sure to review any provided documentation\n            about the nature of the signals being connected.\n\n    Parameters\n    ----------\n    ctrl_info : ``CI``\n        Instance of a `sunflare.config.PresenterInfo` subclass.\n    models : ``Mapping[str, PModel]``\n        Reference to the models used in the controller.\n    virtual_bus : `sunflare.virtual.VirtualBus`\n        Reference to the virtual bus.\n    signals : ``Sequence[str]``, optional\n        Sequence of signals to register.\n        Default is ``None`` (no signals registered).\n    connection_map : ``Mapping[str, list[Connection]]``, optional\n        Mapping of emitters to a list of connections.\n        Default is ``None`` (no connections).\n\n    Attributes\n    ----------\n    signals : ``Sequence[str]``, optional\n        Sequence of registered signals.\n    connection_map : ``Mapping[str, list[Connection]]``, optional\n        Mapping of emitters to a list of connections.\n    \"\"\"\n\n    def __init__(\n        self,\n        ctrl_info: CI,\n        models: Mapping[str, PModel],\n        virtual_bus: VirtualBus,\n        *,\n        signals: Sequence[str] | None = None,\n        connection_map: Mapping[str, list[Connection]] | None = None,\n    ) -&gt; None:\n        self.signals = signals\n        self.connection_map = connection_map\n        super().__init__(ctrl_info, models, virtual_bus)\n\n    def registration_phase(self) -&gt; None:\n        \"\"\"Register the signals defined in ``self.signals``.\n\n        This method is called from Redsun during\n        application initialization.\n        \"\"\"\n        self.virtual_bus.register_signals(self, self.signals)\n\n    def connection_phase(self) -&gt; None:\n        \"\"\"Connect the signals defined in ``self.connection_map``.\n\n        This method is called from Redsun during\n        application initialization.\n        \"\"\"\n        if self.connection_map is not None:\n            for emitter, connections in self.connection_map.items():\n                for connection in connections:\n                    self.virtual_bus.signals[emitter][connection.signal].connect(\n                        connection.slot\n                    )\n</code></pre>"},{"location":"reference/api/controller/#sunflare.presenter.SenderReceiver.registration_phase","title":"<code>registration_phase()</code>","text":"<p>Register the signals defined in <code>self.signals</code>.</p> <p>This method is called from Redsun during application initialization.</p> Source code in <code>src/sunflare/presenter/_base.py</code> <pre><code>def registration_phase(self) -&gt; None:\n    \"\"\"Register the signals defined in ``self.signals``.\n\n    This method is called from Redsun during\n    application initialization.\n    \"\"\"\n    self.virtual_bus.register_signals(self, self.signals)\n</code></pre>"},{"location":"reference/api/controller/#sunflare.presenter.SenderReceiver.connection_phase","title":"<code>connection_phase()</code>","text":"<p>Connect the signals defined in <code>self.connection_map</code>.</p> <p>This method is called from Redsun during application initialization.</p> Source code in <code>src/sunflare/presenter/_base.py</code> <pre><code>def connection_phase(self) -&gt; None:\n    \"\"\"Connect the signals defined in ``self.connection_map``.\n\n    This method is called from Redsun during\n    application initialization.\n    \"\"\"\n    if self.connection_map is not None:\n        for emitter, connections in self.connection_map.items():\n            for connection in connections:\n                self.virtual_bus.signals[emitter][connection.signal].connect(\n                    connection.slot\n                )\n</code></pre>"},{"location":"reference/api/engine/","title":"sunflare.engine","text":""},{"location":"reference/api/engine/#sunflare.engine","title":"<code>engine</code>","text":""},{"location":"reference/api/engine/#sunflare.engine.Status","title":"<code>Status</code>","text":"<p>               Bases: <code>Status</code></p> <p>Track the status of a potentially-lengthy action like moving or triggering.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>float | None</code> <p>The amount of time to wait before marking the Status as failed.  If <code>None</code> (default) wait forever. It is strongly encouraged to set a finite timeout.  If settle_time below is set, that time is added to the effective timeout.</p> <code>None</code> <code>settle_time</code> <code>float | None</code> <p>The amount of time to wait between the caller specifying that the status has completed to running callbacks. Default is 0.</p> <code>0</code> Notes <p>Theory of operation:</p> <p>This employs two <code>threading.Event</code> objects, one thread that runs for (timeout + settle_time) seconds, and one thread that runs for settle_time seconds (if settle_time is nonzero).</p> <p>At init time, a timeout and settle_time are specified. A thread is started, on which user callbacks, registered after init time via <code>add_callback</code>, will eventually be run. The thread waits on an Event be set or (timeout + settle_time) seconds to pass, whichever happens first.</p> <p>If (timeout + settle_time) expires and the Event has not been set, an internal Exception is set to <code>StatusTimeoutError</code>, and a second Event is set, marking the Status as done and failed. The callbacks are run.</p> <p>If a callback is registered after the Status is done, it will be run immediately.</p> <p>If the first Event is set before (timeout + settle_time) expires, then the second Event is set and no internal Exception is set, marking the Status as done and successful. The callbacks are run.</p> <p>There are two methods that directly set the first Event. One, <code>set_exception</code>, sets it directly after setting the internal Exception.  The other, <code>set_finished</code>, starts a <code>threading.Timer</code> that will set it after a delay (the settle_time). One of these methods may be called, and at most once. If one is called twice or if both are called, <code>InvalidState</code> is raised. If they are called too late to prevent a <code>StatusTimeoutError</code>, they are ignored but one call is still allowed. Thus, an external callback, e.g. pyepics, may reports success or failure after the Status object has expired, but to no effect because the callbacks have already been called and the program has moved on.</p> Source code in <code>src/sunflare/engine/_status.py</code> <pre><code>class Status(PStatus):\n    \"\"\"\n    Track the status of a potentially-lengthy action like moving or triggering.\n\n    Parameters\n    ----------\n    timeout: float, optional\n        The amount of time to wait before marking the Status as failed.  If\n        ``None`` (default) wait forever. It is strongly encouraged to set a\n        finite timeout.  If settle_time below is set, that time is added to the\n        effective timeout.\n    settle_time: float, optional\n        The amount of time to wait between the caller specifying that the\n        status has completed to running callbacks. Default is 0.\n\n    Notes\n    -----\n    Theory of operation:\n\n    This employs two ``threading.Event`` objects, one thread that runs for\n    (timeout + settle_time) seconds, and one thread that runs for\n    settle_time seconds (if settle_time is nonzero).\n\n    At __init__ time, a *timeout* and *settle_time* are specified. A thread\n    is started, on which user callbacks, registered after __init__ time via\n    [`add_callback`](), will eventually be run. The thread waits on an\n    Event be set or (timeout + settle_time) seconds to pass, whichever\n    happens first.\n\n    If (timeout + settle_time) expires and the Event has not\n    been set, an internal Exception is set to ``StatusTimeoutError``, and a\n    second Event is set, marking the Status as done and failed. The\n    callbacks are run.\n\n    If a callback is registered after the Status is done, it will be run\n    immediately.\n\n    If the first Event is set before (timeout + settle_time) expires,\n    then the second Event is set and no internal Exception is set, marking\n    the Status as done and successful. The callbacks are run.\n\n    There are two methods that directly set the first Event. One,\n    [`set_exception`](), sets it directly after setting the internal\n    Exception.  The other, [`set_finished`](), starts a\n    ``threading.Timer`` that will set it after a delay (the settle_time).\n    One of these methods may be called, and at most once. If one is called\n    twice or if both are called, ``InvalidState`` is raised. If they are\n    called too late to prevent a ``StatusTimeoutError``, they are ignored\n    but one call is still allowed. Thus, an external callback, e.g. pyepics,\n    may reports success or failure after the Status object has expired, but\n    to no effect because the callbacks have already been called and the\n    program has moved on.\n    \"\"\"\n\n    def __init__(self, *, timeout: float | None = None, settle_time: float | None = 0):\n        super().__init__()\n        self._logger = logging.getLogger(\"redsun\")\n        self._tname = None\n        self._lock = threading.RLock()\n        self._event = threading.Event()  # state associated with done-ness\n        self._settled_event = threading.Event()\n        # \"Externally initiated\" means set_finished() or set_exception(exc) was\n        # called, as opposed to completion via an internal timeout.\n        self._externally_initiated_completion_lock = threading.Lock()\n        self._externally_initiated_completion = False\n        self._callbacks: deque[Callable[[Status], None]] = deque()\n        self._exception: BaseException | None = None\n\n        if settle_time is None:\n            settle_time = 0.0\n\n        self._settle_time = float(settle_time)\n\n        if timeout is not None:\n            timeout = float(timeout)\n        self._timeout = timeout\n\n        self._callback_thread = threading.Thread(\n            target=self._run_callbacks, daemon=True, name=self._tname\n        )\n        self._callback_thread.start()\n\n    @property\n    def timeout(self) -&gt; float | None:\n        \"\"\"The timeout for this action.\n\n        This is set when the Status is created, and it cannot be changed.\n        \"\"\"\n        return self._timeout\n\n    @property\n    def settle_time(self) -&gt; float:\n        \"\"\"A delay between when [`set_finished`]() is when the Status is done.\n\n        This is set when the Status is created, and it cannot be changed.\n        \"\"\"\n        return self._settle_time\n\n    @property\n    def done(self) -&gt; bool:\n        \"\"\"Boolean indicating whether associated operation has completed.\n\n        This is set to True at __init__ time or by calling\n        [`set_finished`](), [`set_exception`]().\n        Once True, it can never become False.\n        \"\"\"\n        return self._event.is_set()\n\n    @property\n    def success(self) -&gt; bool:\n        \"\"\"Boolean indicating whether associated operation has completed.\n\n        This is set to True at __init__ time or by calling\n        [`set_finished`](), [`set_exception`]()\n        . Once True, it can never become False.\n        \"\"\"\n        return self.done and self._exception is None\n\n    def _handle_failure(self) -&gt; None:\n        \"\"\"Do something if an exception occurred during the action.\"\"\"\n        # TODO: implement this; maybe ophyd has a good example\n        pass\n\n    def _settled(self) -&gt; None:\n        \"\"\"Connect to this this when status has completed and settled.\"\"\"\n        # TODO: implement this; maybe ophyd has a good example\n        pass\n\n    def _run_callbacks(self) -&gt; None:\n        \"\"\"Set the Event and run the callbacks.\"\"\"\n        if self.timeout is None:\n            timeout = None\n        else:\n            timeout = self.timeout + self.settle_time\n        if not self._settled_event.wait(timeout):\n            # We have timed out. It's possible that set_finished() has already\n            # been called but we got here before the settle_time timer expired.\n            # And it's possible that in this space be between the above\n            # statement timing out grabbing the lock just below,\n            # set_exception(exc) has been called. Both of these possibilties\n            # are accounted for.\n            self._logger.warning(\"%r has timed out\", self)\n            with self._externally_initiated_completion_lock:\n                # Set the exception and mark the Status as done, unless\n                # set_exception(exc) was called externally before we grabbed\n                # the lock.\n                if self._exception is None:\n                    exc = StatusTimeoutError(\n                        f\"Status {self!r} failed to complete in specified timeout.\"\n                    )\n                    self._exception = exc\n        # Mark this as \"settled\".\n        try:\n            self._settled()\n        except Exception:\n            # No alternative but to log this. We can't supersede set_exception,\n            # and we have to continue and run the callbacks.\n            self._logger.exception(\"%r encountered error during _settled()\", self)\n        # Now we know whether or not we have succeed or failed, either by\n        # timeout above or by set_exception(exc), so we can set the Event that\n        # will mark this Status as done.\n        with self._lock:\n            self._event.set()\n        if self._exception is not None:\n            try:\n                self._handle_failure()\n            except Exception:\n                self._logger.exception(\n                    \"%r encountered an error during _handle_failure()\", self\n                )\n        # The callbacks have access to self, from which they can distinguish\n        # success or failure.\n        for cb in self._callbacks:\n            try:\n                cb(self)\n            except Exception:\n                self._logger.exception(\n                    \"An error was raised on a background thread while \"\n                    \"running the callback %r(%r).\",\n                    cb,\n                    self,\n                )\n        self._callbacks.clear()\n\n    def set_exception(self, exc: BaseException) -&gt; None:\n        \"\"\"Mark as finished but failed with the given Exception.\n\n        This method should generally not be called by the *recipient* of this\n        Status object, but only by the object that created and returned it.\n\n        Parameters\n        ----------\n        exc: BaseException\n            The exception that caused the failure.\n        \"\"\"\n        # Since we rely on this being raise-able later, check proactively to\n        # avoid potentially very confusing failures.\n        if not (isinstance(exc, BaseException)):\n            # Note that Python allows `raise Exception` or raise Exception()`\n            # so we allow a class or an instance here too.\n            raise ValueError(f\"Expected an Exception, got {exc!r}\")\n\n        # Ban certain Timeout subclasses that have special significance. This\n        # would probably never come up except due to some rare user error, but\n        # if it did it could be very confusing indeed!\n        for exc_class in (StatusTimeoutError, WaitTimeoutError):\n            if isinstance(exc, exc_class):\n                raise ValueError(\n                    f\"{exc_class} has special significance and cannot be set \"\n                    \"as the exception. Use a plain TimeoutError or some other \"\n                    \"subclass thereof.\"\n                )\n\n        with self._externally_initiated_completion_lock:\n            if self._externally_initiated_completion:\n                raise InvalidState(\n                    \"Either set_finished() or set_exception() has \"\n                    f\"already been called on {self!r}\"\n                )\n            self._externally_initiated_completion = True\n            if isinstance(self._exception, StatusTimeoutError):\n                # We have already timed out.\n                return\n            self._exception = exc\n            self._settled_event.set()\n\n    def set_finished(self) -&gt; None:\n        \"\"\"Mark as finished successfully.\n\n        This method should generally not be called by the *recipient* of this\n        Status object, but only by the object that created and returned it.\n        \"\"\"\n        with self._externally_initiated_completion_lock:\n            if self._externally_initiated_completion:\n                raise InvalidState(\n                    \"Either set_finished() or set_exception() has \"\n                    f\"already been called on {self!r}\"\n                )\n            self._externally_initiated_completion = True\n        # Note that in either case, the callbacks themselves are run from the\n        # same thread. This just sets an Event, either from this thread (the\n        # one calling set_finished) or the thread created below.\n        if self.settle_time &gt; 0:\n            threading.Timer(self.settle_time, self._settled_event.set).start()\n        else:\n            self._settled_event.set()\n\n    def exception(self, timeout: float | None = None) -&gt; BaseException | None:\n        \"\"\"Return the exception raised by the action.\n\n        If the action has completed successfully, return ``None``. If it has\n        finished in error, return the exception.\n\n        Parameters\n        ----------\n        timeout: float | None, optional\n            If None (default) wait indefinitely until the status finishes.\n\n        Returns\n        -------\n        Exception:\n            The exception raised by the action. If the action has completed\n            successfully, return ``None``.\n\n        Raises\n        ------\n        WaitTimeoutError\n            If the status has not completed within ``timeout`` (starting from\n            when this method was called, not from the beginning of the action).\n        \"\"\"\n        if not self._event.wait(timeout=timeout):\n            raise WaitTimeoutError(\"Status has not completed yet.\")\n        return self._exception\n\n    def wait(self, timeout: float | None = None) -&gt; None:\n        \"\"\"Block until the action completes.\n\n        When the action has finished succesfully, return ``None``. If the\n        action has failed, raise the exception.\n\n        Parameters\n        ----------\n        timeout: ``float``, optional\n            If ``None`` (default) wait indefinitely until the status finishes.\n\n        Raises\n        ------\n        WaitTimeoutError\n            If the status has not completed within ``timeout`` (starting from\n            when this method was called, not from the beginning of the action).\n        StatusTimeoutError\n            If the status has failed because the *timeout* that it was\n            initialized with has expired.\n        Exception\n            This is ``status.exception()``, raised if the status has finished\n            with an error.  This may include ``TimeoutError``, which\n            indicates that the action itself raised ``TimeoutError``, distinct\n            from ``WaitTimeoutError`` above.\n        \"\"\"\n        if not self._event.wait(timeout=timeout):\n            raise WaitTimeoutError(\"Status has not completed yet.\")\n        if self._exception is not None:\n            raise self._exception\n\n    @property\n    def callbacks(self) -&gt; deque[Callable[[Status], None]]:\n        \"\"\"Callbacks to be run when the status is marked as finished.\"\"\"\n        return self._callbacks\n\n    def add_callback(self, callback: Callable[[Status], None]) -&gt; None:\n        \"\"\"Register a callback to be called once when the Status finishes.\n\n        The callback will be called exactly once. If the Status is finished\n        before a callback is added, it will be called immediately. This is\n        threadsafe.\n        The callback will be called regardless of success of failure. The\n        callback has access to this status object, so it can distinguish success\n        or failure by inspecting the object.\n\n        Parameters\n        ----------\n        callback: ``Callable[[Status], None]``\n            The callback to be called when the status is marked as finished.\n\n            ```python\n            def callback(status: Status) -&gt; None:\n                # Do something with the status object\n                ...\n            ```\n        \"\"\"\n        with self._lock:\n            if self.done:\n                # Call it once and do not hold a reference to it.\n                callback(self)\n            else:\n                # Hold a strong reference to this. In other contexts we tend to\n                # hold weak references to callbacks, but this is a single-shot\n                # callback, so we will hold a strong reference until we call it,\n                # and then clear this cache to drop the reference(s).\n                self._callbacks.append(callback)\n</code></pre>"},{"location":"reference/api/engine/#sunflare.engine.Status.timeout","title":"<code>timeout</code>  <code>property</code>","text":"<p>The timeout for this action.</p> <p>This is set when the Status is created, and it cannot be changed.</p>"},{"location":"reference/api/engine/#sunflare.engine.Status.settle_time","title":"<code>settle_time</code>  <code>property</code>","text":"<p>A delay between when <code>set_finished</code> is when the Status is done.</p> <p>This is set when the Status is created, and it cannot be changed.</p>"},{"location":"reference/api/engine/#sunflare.engine.Status.done","title":"<code>done</code>  <code>property</code>","text":"<p>Boolean indicating whether associated operation has completed.</p> <p>This is set to True at init time or by calling <code>set_finished</code>, <code>set_exception</code>. Once True, it can never become False.</p>"},{"location":"reference/api/engine/#sunflare.engine.Status.success","title":"<code>success</code>  <code>property</code>","text":"<p>Boolean indicating whether associated operation has completed.</p> <p>This is set to True at init time or by calling <code>set_finished</code>, <code>set_exception</code> . Once True, it can never become False.</p>"},{"location":"reference/api/engine/#sunflare.engine.Status.callbacks","title":"<code>callbacks</code>  <code>property</code>","text":"<p>Callbacks to be run when the status is marked as finished.</p>"},{"location":"reference/api/engine/#sunflare.engine.Status.set_exception","title":"<code>set_exception(exc)</code>","text":"<p>Mark as finished but failed with the given Exception.</p> <p>This method should generally not be called by the recipient of this Status object, but only by the object that created and returned it.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>BaseException</code> <p>The exception that caused the failure.</p> required Source code in <code>src/sunflare/engine/_status.py</code> <pre><code>def set_exception(self, exc: BaseException) -&gt; None:\n    \"\"\"Mark as finished but failed with the given Exception.\n\n    This method should generally not be called by the *recipient* of this\n    Status object, but only by the object that created and returned it.\n\n    Parameters\n    ----------\n    exc: BaseException\n        The exception that caused the failure.\n    \"\"\"\n    # Since we rely on this being raise-able later, check proactively to\n    # avoid potentially very confusing failures.\n    if not (isinstance(exc, BaseException)):\n        # Note that Python allows `raise Exception` or raise Exception()`\n        # so we allow a class or an instance here too.\n        raise ValueError(f\"Expected an Exception, got {exc!r}\")\n\n    # Ban certain Timeout subclasses that have special significance. This\n    # would probably never come up except due to some rare user error, but\n    # if it did it could be very confusing indeed!\n    for exc_class in (StatusTimeoutError, WaitTimeoutError):\n        if isinstance(exc, exc_class):\n            raise ValueError(\n                f\"{exc_class} has special significance and cannot be set \"\n                \"as the exception. Use a plain TimeoutError or some other \"\n                \"subclass thereof.\"\n            )\n\n    with self._externally_initiated_completion_lock:\n        if self._externally_initiated_completion:\n            raise InvalidState(\n                \"Either set_finished() or set_exception() has \"\n                f\"already been called on {self!r}\"\n            )\n        self._externally_initiated_completion = True\n        if isinstance(self._exception, StatusTimeoutError):\n            # We have already timed out.\n            return\n        self._exception = exc\n        self._settled_event.set()\n</code></pre>"},{"location":"reference/api/engine/#sunflare.engine.Status.set_finished","title":"<code>set_finished()</code>","text":"<p>Mark as finished successfully.</p> <p>This method should generally not be called by the recipient of this Status object, but only by the object that created and returned it.</p> Source code in <code>src/sunflare/engine/_status.py</code> <pre><code>def set_finished(self) -&gt; None:\n    \"\"\"Mark as finished successfully.\n\n    This method should generally not be called by the *recipient* of this\n    Status object, but only by the object that created and returned it.\n    \"\"\"\n    with self._externally_initiated_completion_lock:\n        if self._externally_initiated_completion:\n            raise InvalidState(\n                \"Either set_finished() or set_exception() has \"\n                f\"already been called on {self!r}\"\n            )\n        self._externally_initiated_completion = True\n    # Note that in either case, the callbacks themselves are run from the\n    # same thread. This just sets an Event, either from this thread (the\n    # one calling set_finished) or the thread created below.\n    if self.settle_time &gt; 0:\n        threading.Timer(self.settle_time, self._settled_event.set).start()\n    else:\n        self._settled_event.set()\n</code></pre>"},{"location":"reference/api/engine/#sunflare.engine.Status.exception","title":"<code>exception(timeout=None)</code>","text":"<p>Return the exception raised by the action.</p> <p>If the action has completed successfully, return <code>None</code>. If it has finished in error, return the exception.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>float | None</code> <p>If None (default) wait indefinitely until the status finishes.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Exception</code> <code>BaseException | None</code> <p>The exception raised by the action. If the action has completed successfully, return <code>None</code>.</p> <p>Raises:</p> Type Description <code>WaitTimeoutError</code> <p>If the status has not completed within <code>timeout</code> (starting from when this method was called, not from the beginning of the action).</p> Source code in <code>src/sunflare/engine/_status.py</code> <pre><code>def exception(self, timeout: float | None = None) -&gt; BaseException | None:\n    \"\"\"Return the exception raised by the action.\n\n    If the action has completed successfully, return ``None``. If it has\n    finished in error, return the exception.\n\n    Parameters\n    ----------\n    timeout: float | None, optional\n        If None (default) wait indefinitely until the status finishes.\n\n    Returns\n    -------\n    Exception:\n        The exception raised by the action. If the action has completed\n        successfully, return ``None``.\n\n    Raises\n    ------\n    WaitTimeoutError\n        If the status has not completed within ``timeout`` (starting from\n        when this method was called, not from the beginning of the action).\n    \"\"\"\n    if not self._event.wait(timeout=timeout):\n        raise WaitTimeoutError(\"Status has not completed yet.\")\n    return self._exception\n</code></pre>"},{"location":"reference/api/engine/#sunflare.engine.Status.wait","title":"<code>wait(timeout=None)</code>","text":"<p>Block until the action completes.</p> <p>When the action has finished succesfully, return <code>None</code>. If the action has failed, raise the exception.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>float | None</code> <p>If <code>None</code> (default) wait indefinitely until the status finishes.</p> <code>None</code> <p>Raises:</p> Type Description <code>WaitTimeoutError</code> <p>If the status has not completed within <code>timeout</code> (starting from when this method was called, not from the beginning of the action).</p> <code>StatusTimeoutError</code> <p>If the status has failed because the timeout that it was initialized with has expired.</p> <code>Exception</code> <p>This is <code>status.exception()</code>, raised if the status has finished with an error.  This may include <code>TimeoutError</code>, which indicates that the action itself raised <code>TimeoutError</code>, distinct from <code>WaitTimeoutError</code> above.</p> Source code in <code>src/sunflare/engine/_status.py</code> <pre><code>def wait(self, timeout: float | None = None) -&gt; None:\n    \"\"\"Block until the action completes.\n\n    When the action has finished succesfully, return ``None``. If the\n    action has failed, raise the exception.\n\n    Parameters\n    ----------\n    timeout: ``float``, optional\n        If ``None`` (default) wait indefinitely until the status finishes.\n\n    Raises\n    ------\n    WaitTimeoutError\n        If the status has not completed within ``timeout`` (starting from\n        when this method was called, not from the beginning of the action).\n    StatusTimeoutError\n        If the status has failed because the *timeout* that it was\n        initialized with has expired.\n    Exception\n        This is ``status.exception()``, raised if the status has finished\n        with an error.  This may include ``TimeoutError``, which\n        indicates that the action itself raised ``TimeoutError``, distinct\n        from ``WaitTimeoutError`` above.\n    \"\"\"\n    if not self._event.wait(timeout=timeout):\n        raise WaitTimeoutError(\"Status has not completed yet.\")\n    if self._exception is not None:\n        raise self._exception\n</code></pre>"},{"location":"reference/api/engine/#sunflare.engine.Status.add_callback","title":"<code>add_callback(callback)</code>","text":"<p>Register a callback to be called once when the Status finishes.</p> <p>The callback will be called exactly once. If the Status is finished before a callback is added, it will be called immediately. This is threadsafe. The callback will be called regardless of success of failure. The callback has access to this status object, so it can distinguish success or failure by inspecting the object.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[Status], None]</code> <p>The callback to be called when the status is marked as finished.</p> <pre><code>def callback(status: Status) -&gt; None:\n    # Do something with the status object\n    ...\n</code></pre> required Source code in <code>src/sunflare/engine/_status.py</code> <pre><code>def add_callback(self, callback: Callable[[Status], None]) -&gt; None:\n    \"\"\"Register a callback to be called once when the Status finishes.\n\n    The callback will be called exactly once. If the Status is finished\n    before a callback is added, it will be called immediately. This is\n    threadsafe.\n    The callback will be called regardless of success of failure. The\n    callback has access to this status object, so it can distinguish success\n    or failure by inspecting the object.\n\n    Parameters\n    ----------\n    callback: ``Callable[[Status], None]``\n        The callback to be called when the status is marked as finished.\n\n        ```python\n        def callback(status: Status) -&gt; None:\n            # Do something with the status object\n            ...\n        ```\n    \"\"\"\n    with self._lock:\n        if self.done:\n            # Call it once and do not hold a reference to it.\n            callback(self)\n        else:\n            # Hold a strong reference to this. In other contexts we tend to\n            # hold weak references to callbacks, but this is a single-shot\n            # callback, so we will hold a strong reference until we call it,\n            # and then clear this cache to drop the reference(s).\n            self._callbacks.append(callback)\n</code></pre>"},{"location":"reference/api/engine/#sunflare.engine.RunEngine","title":"<code>RunEngine</code>","text":"<p>               Bases: <code>RunEngine</code></p> <p>Subclass of <code>bluesky.run_engine.RunEngine</code> to allow execution in a separate thread.</p> <p>Suppressed features:</p> <ul> <li><code>context_managers</code>: The context managers are forced to be an empty list to   avoid the use of the built-in <code>SignalHandler</code> context manager.</li> </ul> <p>The rationale is that the original implementation is meant for interactive usage (e.g., Jupyter notebooks, scripts) and not for applications relying on an event loop.</p> <ul> <li><code>pause_msg</code>: Overridden to be an empty string.</li> <li><code>during_task</code>: Overridden to <code>DuringTask</code>, so the <code>RunEngine</code>   does not interact with any possible event loop in the main thread.</li> </ul> <p>For the original class initializer signature, refer to the <code>bluesky.run_engine.RunEngine</code> documentation.</p> Source code in <code>src/sunflare/engine/_wrapper.py</code> <pre><code>class RunEngine(BlueskyRunEngine):\n    \"\"\"Subclass of ``bluesky.run_engine.RunEngine`` to allow execution in a separate thread.\n\n    Suppressed features:\n\n    - ``context_managers``: The context managers are forced to be an empty list to\n      avoid the use of the built-in ``SignalHandler`` context manager.\n\n    The rationale is that the original implementation is meant for\n    interactive usage (e.g., Jupyter notebooks, scripts) and not\n    for applications relying on an event loop.\n\n    - ``pause_msg``: Overridden to be an empty string.\n    - ``during_task``: Overridden to ``DuringTask``, so the ``RunEngine``\n      does not interact with any possible event loop in the main thread.\n\n    For the original class initializer signature, refer to the [`bluesky.run_engine.RunEngine`]() documentation.\n    \"\"\"\n\n    def __init__(self, *args: Any, **kwargs: Any) -&gt; None:\n        # force the context_managers to be empty,\n        # otherwise the RunEngine will try to use the\n        # SignalHandler context manager\n        kwargs[\"context_managers\"] = []\n        kwargs[\"during_task\"] = DuringTask()\n        self._executor = ThreadPoolExecutor(max_workers=1)\n        self._result: REResultType\n        super().__init__(*args, **kwargs)\n\n        # override pause message to be an empty string\n        self.pause_msg = \"\"\n\n    def __call__(  # type: ignore[override]\n        self,\n        plan: Iterable[Msg],\n        subs: Subscribers | None = None,\n        /,\n        **metadata_kw: Any,\n    ) -&gt; Future[RunEngineResult | tuple[str, ...]]:\n        self._fut = self._executor.submit(\n            super().__call__,\n            plan,\n            subs,\n            **metadata_kw,\n        )\n        self._fut.add_done_callback(self._set_result)\n        return self._fut\n\n    def resume(self) -&gt; Future[RunEngineResult | tuple[str, ...]]:\n        \"\"\"Resume the paused plan in a separate thread.\n\n        If the plan has been paused, the initial\n        future returned by ``__call__`` will be set as completed.\n\n        With this method, the plan is resumed in a separate thread,\n        and a new future is returned.\n\n        Returns\n        -------\n        ``Future[RunEngineResult | tuple[str, ...]]``\n            Future object representing the result of the resumed plan.\n        \"\"\"\n        self._fut = self._executor.submit(super().resume)\n        self._fut.add_done_callback(self._set_result)\n        return self._fut\n\n    def _set_result(self, fut: Future[RunEngineResult | tuple[str, ...]]) -&gt; None:\n        try:\n            self._result = fut.result()\n        except Exception as exc:\n            self._result = exc\n\n    @property\n    def result(self) -&gt; REResultType:\n        return self._result\n</code></pre>"},{"location":"reference/api/engine/#sunflare.engine.RunEngine.resume","title":"<code>resume()</code>","text":"<p>Resume the paused plan in a separate thread.</p> <p>If the plan has been paused, the initial future returned by <code>__call__</code> will be set as completed.</p> <p>With this method, the plan is resumed in a separate thread, and a new future is returned.</p> <p>Returns:</p> Type Description <code>``Future[RunEngineResult | tuple[str, ...]]``</code> <p>Future object representing the result of the resumed plan.</p> Source code in <code>src/sunflare/engine/_wrapper.py</code> <pre><code>def resume(self) -&gt; Future[RunEngineResult | tuple[str, ...]]:\n    \"\"\"Resume the paused plan in a separate thread.\n\n    If the plan has been paused, the initial\n    future returned by ``__call__`` will be set as completed.\n\n    With this method, the plan is resumed in a separate thread,\n    and a new future is returned.\n\n    Returns\n    -------\n    ``Future[RunEngineResult | tuple[str, ...]]``\n        Future object representing the result of the resumed plan.\n    \"\"\"\n    self._fut = self._executor.submit(super().resume)\n    self._fut.add_done_callback(self._set_result)\n    return self._fut\n</code></pre>"},{"location":"reference/api/log/","title":"sunflare.log","text":""},{"location":"reference/api/log/#sunflare.log","title":"<code>log</code>","text":""},{"location":"reference/api/log/#sunflare.log.GlobalFormatter","title":"<code>GlobalFormatter</code>","text":"<p>               Bases: <code>Formatter</code></p> <p>Custom formatter for log messages.</p> Source code in <code>src/sunflare/log.py</code> <pre><code>class GlobalFormatter(logging.Formatter):\n    \"\"\"Custom formatter for log messages.\"\"\"\n\n    _format = \"[%(asctime)s][%(levelname)s]\"\n\n    def __init__(self, datefmt: str) -&gt; None:\n        super().__init__(datefmt=datefmt)\n\n    def format(self, record: logging.LogRecord) -&gt; str:\n        fmt = self._format\n        message = []\n        message.append(record.getMessage())\n        record.message = \" \".join(message)\n        record.asctime = self.formatTime(record, self.datefmt)\n        clsname = getattr(record, \"clsname\", None)\n        if clsname:\n            fmt += \"[%(clsname)s\"\n        uid = getattr(record, \"uid\", None)\n        if uid:\n            fmt += \" -&gt; %(uid)s\"\n        if clsname:\n            fmt += \"]\"\n        fmt += \": %(message)s\"\n        if record.levelno != logging.INFO:\n            fmt += \" (%(filename)s:%(lineno)d)\"\n        formatted = fmt % record.__dict__\n        return formatted\n</code></pre>"},{"location":"reference/api/log/#sunflare.log.ContextualAdapter","title":"<code>ContextualAdapter</code>","text":"<p>               Bases: <code>_LoggerAdapter</code></p> <p>Adapter that adds class and object context to log messages.</p> <p>It expands the <code>kwargs</code> to inject the object's class name and name into the log record.</p> <p>Parameters:</p> Name Type Description Default <code>logger</code> <code>Logger</code> <p>Logger instance to wrap.</p> required <code>obj</code> <code>Any</code> <p>The object to add context to.</p> required Source code in <code>src/sunflare/log.py</code> <pre><code>class ContextualAdapter(_LoggerAdapter):\n    \"\"\"Adapter that adds class and object context to log messages.\n\n    It expands the ``kwargs`` to inject the object's class name and name into the log record.\n\n    Parameters\n    ----------\n    logger: ``logging.Logger``\n        Logger instance to wrap.\n    obj: ``Any``\n        The object to add context to.\n    \"\"\"\n\n    logger: logging.Logger\n\n    def __init__(self, logger: logging.Logger, obj: Any) -&gt; None:\n        super().__init__(logger, {\"obj\": obj})\n        self.obj = obj\n\n    def process(\n        self, msg: str, kwargs: MutableMapping[str, Any]\n    ) -&gt; tuple[str, MutableMapping[str, Any]]:\n        \"\"\"Add object context to the log message.\"\"\"\n        clsname = self.obj.__class__.__name__\n        extra: dict[str, Any] = kwargs.get(\"extra\", {})\n        extra[\"clsname\"] = clsname\n        extra[\"uid\"] = getattr(self.obj, \"name\", None)\n        kwargs[\"extra\"] = extra\n        return msg, kwargs\n</code></pre>"},{"location":"reference/api/log/#sunflare.log.ContextualAdapter.process","title":"<code>process(msg, kwargs)</code>","text":"<p>Add object context to the log message.</p> Source code in <code>src/sunflare/log.py</code> <pre><code>def process(\n    self, msg: str, kwargs: MutableMapping[str, Any]\n) -&gt; tuple[str, MutableMapping[str, Any]]:\n    \"\"\"Add object context to the log message.\"\"\"\n    clsname = self.obj.__class__.__name__\n    extra: dict[str, Any] = kwargs.get(\"extra\", {})\n    extra[\"clsname\"] = clsname\n    extra[\"uid\"] = getattr(self.obj, \"name\", None)\n    kwargs[\"extra\"] = extra\n    return msg, kwargs\n</code></pre>"},{"location":"reference/api/log/#sunflare.log.Loggable","title":"<code>Loggable</code>","text":"<p>Mixin class that adds a logger to a class instance with extra contextual information.</p> Source code in <code>src/sunflare/log.py</code> <pre><code>class Loggable:\n    \"\"\"Mixin class that adds a logger to a class instance with extra contextual information.\"\"\"\n\n    @cached_property\n    def logger(self) -&gt; _LoggerAdapter:\n        \"\"\"Logger instance with contextual information.\"\"\"\n        return ContextualAdapter(logging.getLogger(\"redsun\"), self)\n</code></pre>"},{"location":"reference/api/log/#sunflare.log.Loggable.logger","title":"<code>logger</code>  <code>cached</code> <code>property</code>","text":"<p>Logger instance with contextual information.</p>"},{"location":"reference/api/model/","title":"sunflare.model","text":""},{"location":"reference/api/model/#sunflare.model","title":"<code>model</code>","text":""},{"location":"reference/api/model/#sunflare.model.Model","title":"<code>Model</code>","text":"<p>               Bases: <code>PModel</code>, <code>Generic[MI]</code></p> <p>A boilerplate base class for quick model development.</p> <p>Users may subclass from this model and provide their custom <code>sunflare.config.ModelInfo</code> implementation.</p> <p>Example usage:</p> <pre><code>from sunflare.model import Model\nfrom sunflare.config import ModelInfo\nfrom attrs import define\n\n\n@define\nclass MyModelInfo(ModelInfo):\n    str_param: str\n    bool_param: bool\n    # any other parameters...\n\n\nclass MyModel(Model[MyModelInfo]):\n    def __init__(self, name: str, model_info: MyModelInfo) -&gt; None:\n        super().__init__(name, model_info)\n        # any other initialization code...\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>``str``</code> <p>Name of the model. Serves as a unique identifier for the object created from it.</p> required <code>model_info</code> <code>``MI``</code> <p>Instance of <code>sunflare.config.ModelInfo</code> subclass.</p> required Source code in <code>src/sunflare/model/_base.py</code> <pre><code>class Model(PModel, Generic[MI]):\n    \"\"\"A boilerplate base class for quick model development.\n\n    Users may subclass from this model and provide their custom\n    `sunflare.config.ModelInfo` implementation.\n\n    Example usage:\n\n    ```python\n    from sunflare.model import Model\n    from sunflare.config import ModelInfo\n    from attrs import define\n\n\n    @define\n    class MyModelInfo(ModelInfo):\n        str_param: str\n        bool_param: bool\n        # any other parameters...\n\n\n    class MyModel(Model[MyModelInfo]):\n        def __init__(self, name: str, model_info: MyModelInfo) -&gt; None:\n            super().__init__(name, model_info)\n            # any other initialization code...\n    ```\n\n    Parameters\n    ----------\n    name : ``str``\n        Name of the model. Serves as a unique identifier for the object created from it.\n    model_info : ``MI``\n        Instance of `sunflare.config.ModelInfo` subclass.\n    \"\"\"\n\n    def __init__(self, name: str, model_info: MI) -&gt; None:\n        self._name = name\n        self._model_info = model_info\n\n    def describe_configuration(self) -&gt; SyncOrAsync[dict[str, Descriptor]]:\n        \"\"\"Provide a description of the model configuration.\n\n        Inspects the local ``model_info`` object and\n        returns a descriptor dictionary compatible\n        with the Bluesky event model.\n\n        Returns\n        -------\n        dict[``str``, `event_model.DataKey`]\n            A dictionary with the description of each field of the model configuration.\n        \"\"\"\n        return self._model_info.describe_configuration()\n\n    def read_configuration(self) -&gt; SyncOrAsync[dict[str, Reading[Any]]]:\n        \"\"\"Provide a description of the model configuration.\n\n        Inspects the local ``model_info`` object and\n        returns a reading dictionary compatible\n        with the Bluesky event model.\n\n        Returns\n        -------\n        dict[``str``, `bluesky.protocols.Descriptor`]\n            A dictionary with the description of each field of the model configuration.\n        \"\"\"\n        return self._model_info.read_configuration()\n\n    @property\n    def name(self) -&gt; str:\n        return self._name\n\n    @property\n    def model_info(self) -&gt; MI:\n        return self._model_info\n\n    @property\n    def parent(self) -&gt; None:\n        return None\n</code></pre>"},{"location":"reference/api/model/#sunflare.model.Model.describe_configuration","title":"<code>describe_configuration()</code>","text":"<p>Provide a description of the model configuration.</p> <p>Inspects the local <code>model_info</code> object and returns a descriptor dictionary compatible with the Bluesky event model.</p> <p>Returns:</p> Type Description <code>dict[``str``, `event_model.DataKey`]</code> <p>A dictionary with the description of each field of the model configuration.</p> Source code in <code>src/sunflare/model/_base.py</code> <pre><code>def describe_configuration(self) -&gt; SyncOrAsync[dict[str, Descriptor]]:\n    \"\"\"Provide a description of the model configuration.\n\n    Inspects the local ``model_info`` object and\n    returns a descriptor dictionary compatible\n    with the Bluesky event model.\n\n    Returns\n    -------\n    dict[``str``, `event_model.DataKey`]\n        A dictionary with the description of each field of the model configuration.\n    \"\"\"\n    return self._model_info.describe_configuration()\n</code></pre>"},{"location":"reference/api/model/#sunflare.model.Model.read_configuration","title":"<code>read_configuration()</code>","text":"<p>Provide a description of the model configuration.</p> <p>Inspects the local <code>model_info</code> object and returns a reading dictionary compatible with the Bluesky event model.</p> <p>Returns:</p> Type Description <code>dict[``str``, `bluesky.protocols.Descriptor`]</code> <p>A dictionary with the description of each field of the model configuration.</p> Source code in <code>src/sunflare/model/_base.py</code> <pre><code>def read_configuration(self) -&gt; SyncOrAsync[dict[str, Reading[Any]]]:\n    \"\"\"Provide a description of the model configuration.\n\n    Inspects the local ``model_info`` object and\n    returns a reading dictionary compatible\n    with the Bluesky event model.\n\n    Returns\n    -------\n    dict[``str``, `bluesky.protocols.Descriptor`]\n        A dictionary with the description of each field of the model configuration.\n    \"\"\"\n    return self._model_info.read_configuration()\n</code></pre>"},{"location":"reference/api/model/#sunflare.model.PModel","title":"<code>PModel</code>","text":"<p>               Bases: <code>HasName</code>, <code>HasParent</code>, <code>Configurable[Any]</code>, <code>Protocol</code></p> <p>Minimal required protocol for a recognizable device in Redsun.</p> <p>Exposes the following Bluesky protocols:</p> <ul> <li><code>bluesky.protocols.HasName</code></li> <li><code>bluesky.protocols.HasParent</code></li> <li><code>bluesky.protocols.Configurable</code></li> </ul> Source code in <code>src/sunflare/model/_protocols.py</code> <pre><code>@runtime_checkable\nclass PModel(HasName, HasParent, Configurable[Any], Protocol):  # pragma: no cover\n    \"\"\"Minimal required protocol for a recognizable device in Redsun.\n\n    Exposes the following Bluesky protocols:\n\n    - [`bluesky.protocols.HasName`]()\n    - [`bluesky.protocols.HasParent`]()\n    - [`bluesky.protocols.Configurable`]()\n    \"\"\"\n\n    @property\n    @abstractmethod\n    def model_info(self) -&gt; PModelInfo:\n        \"\"\"The associated model information.\n\n        It can return a subclass of `sunflare.config.ModelInfo`.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"reference/api/model/#sunflare.model.PModel.model_info","title":"<code>model_info</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>The associated model information.</p> <p>It can return a subclass of <code>sunflare.config.ModelInfo</code>.</p>"},{"location":"reference/api/model/#related-types","title":"Related Types","text":""},{"location":"reference/api/model/#from-bluesky","title":"From Bluesky","text":"<ul> <li><code>Reading</code> - Bluesky reading protocol</li> </ul>"},{"location":"reference/api/model/#from-event-model","title":"From Event Model","text":"<ul> <li><code>DataKey</code> - Event model data key</li> </ul>"},{"location":"reference/api/virtual/","title":"sunflare.virtual","text":""},{"location":"reference/api/virtual/#sunflare.virtual","title":"<code>virtual</code>","text":""},{"location":"reference/api/virtual/#sunflare.virtual.VirtualBus","title":"<code>VirtualBus</code>","text":"<p>               Bases: <code>Loggable</code></p> <p><code>VirtualBus</code>: router object for data exchange.</p> <p>The <code>VirtualBus</code> is a mechanism to exchange data between different parts of the system. Communication can happen between plugins on the same layer as well as between different layers of the system.</p> <p>It can be used to emit notifications and carry information to other plugins, or to register document callbacks that process documents generated during data acquisition.</p> Source code in <code>src/sunflare/virtual/_bus.py</code> <pre><code>class VirtualBus(Loggable):\n    \"\"\"``VirtualBus``: router object for data exchange.\n\n    The ``VirtualBus`` is a mechanism to exchange\n    data between different parts of the system. Communication\n    can happen between plugins on the same layer as\n    well as between different layers of the system.\n\n    It can be used to emit notifications and carry information\n    to other plugins, or to register document callbacks\n    that process documents generated during data acquisition.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        self._signals: dict[str, SignalCache] = {}\n        self._callbacks: dict[str, CallbackType] = {}\n\n    def register_signals(\n        self, owner: object, only: Iterable[str] | None = None\n    ) -&gt; None:\n        \"\"\"\n        Register the signals of an object in the virtual bus.\n\n        Parameters\n        ----------\n        owner : ``object``\n            The instance whose class's signals are to be cached.\n        only : ``Iterable[str]``, optional\n            A list of signal names to cache. If not provided, all\n            signals in the class will be cached automatically by inspecting\n            the class attributes.\n\n        Notes\n        -----\n        This method inspects the attributes of the owner's class to find\n        ``psygnal.Signal`` descriptors. For each such descriptor, it retrieves\n        the ``SignalInstance`` from the owner using the descriptor protocol and\n        stores it in the registry.\n        \"\"\"\n        owner_class = type(owner)  # Get the class of the object\n        class_name = owner_class.__name__  # Name of the class\n\n        if only is None:\n            # Automatically detect all attributes of the class that are psygnal.Signal descriptors\n            only = [\n                name\n                for name in dir(owner_class)\n                if isinstance(getattr(owner_class, name, None), Signal)\n            ]\n\n        # Initialize the registry for this class if not already present\n        if class_name not in self._signals:\n            self._signals[class_name] = SignalCache()\n\n        # Iterate over the specified signal names and cache their instances\n        for name in only:\n            signal_descriptor = getattr(owner_class, name, None)\n            if isinstance(signal_descriptor, Signal):\n                # Retrieve the SignalInstance using the descriptor protocol\n                signal_instance = getattr(owner, name)\n                self._signals[class_name][name] = signal_instance\n\n    def register_callbacks(self, callback: CallbackType) -&gt; None:\n        \"\"\"Register a document callback in the virtual bus.\n\n        Allows other components of the system access to\n        specific document routers through the `callbacks` property.\n\n        Parameters\n        ----------\n        callback : ``CallbackType``\n            The document callback to register.\n\n        Raises\n        ------\n        TypeError\n            If the provided callback is not callable or does not\n            accept the correct parameters.\n        \"\"\"\n        if isinstance(callback, DocumentRouter):\n            self._callbacks[callback.__class__.__name__] = callback\n        else:\n            if not callable(callback):\n                raise TypeError(f\"{callback} is not callable.\")\n            # validate that the callback accepts only two parameters\n            try:\n                inspect.signature(callback).bind(None, None)\n            except TypeError as e:\n                raise TypeError(\n                    \"The callback function must accept exactly two parameters: \"\n                    \"'name' (str) and 'document' (Document).\"\n                ) from e\n\n            # determine the key based on the type of callback\n            if inspect.ismethod(callback):\n                # bound method: if it's __call__, use the class name; otherwise use the method name\n                if callback.__name__ == \"__call__\":\n                    key = callback.__self__.__class__.__name__\n                else:\n                    key = callback.__name__\n            elif inspect.isfunction(callback):\n                # regular function: use the function name\n                key = callback.__name__\n            elif hasattr(callback, \"__call__\"):\n                # callable object (instance with __call__ method): use the class name\n                key = callback.__class__.__name__\n            else:\n                # fallback (should not reach here due to earlier callable check)\n                key = callback.__name__\n\n            self._callbacks[key] = callback\n\n    @property\n    def callbacks(self) -&gt; dict[str, CallbackType]:\n        \"\"\"The currently registered document callbacks in the virtual bus.\"\"\"\n        return self._callbacks\n\n    @property\n    def signals(self) -&gt; dict[str, SignalCache]:\n        \"\"\"The currently registered signals in the virtual bus.\"\"\"\n        return self._signals\n</code></pre>"},{"location":"reference/api/virtual/#sunflare.virtual.VirtualBus.callbacks","title":"<code>callbacks</code>  <code>property</code>","text":"<p>The currently registered document callbacks in the virtual bus.</p>"},{"location":"reference/api/virtual/#sunflare.virtual.VirtualBus.signals","title":"<code>signals</code>  <code>property</code>","text":"<p>The currently registered signals in the virtual bus.</p>"},{"location":"reference/api/virtual/#sunflare.virtual.VirtualBus.register_signals","title":"<code>register_signals(owner, only=None)</code>","text":"<p>Register the signals of an object in the virtual bus.</p> <p>Parameters:</p> Name Type Description Default <code>owner</code> <code>``object``</code> <p>The instance whose class's signals are to be cached.</p> required <code>only</code> <code>``Iterable[str]``</code> <p>A list of signal names to cache. If not provided, all signals in the class will be cached automatically by inspecting the class attributes.</p> <code>None</code> Notes <p>This method inspects the attributes of the owner's class to find <code>psygnal.Signal</code> descriptors. For each such descriptor, it retrieves the <code>SignalInstance</code> from the owner using the descriptor protocol and stores it in the registry.</p> Source code in <code>src/sunflare/virtual/_bus.py</code> <pre><code>def register_signals(\n    self, owner: object, only: Iterable[str] | None = None\n) -&gt; None:\n    \"\"\"\n    Register the signals of an object in the virtual bus.\n\n    Parameters\n    ----------\n    owner : ``object``\n        The instance whose class's signals are to be cached.\n    only : ``Iterable[str]``, optional\n        A list of signal names to cache. If not provided, all\n        signals in the class will be cached automatically by inspecting\n        the class attributes.\n\n    Notes\n    -----\n    This method inspects the attributes of the owner's class to find\n    ``psygnal.Signal`` descriptors. For each such descriptor, it retrieves\n    the ``SignalInstance`` from the owner using the descriptor protocol and\n    stores it in the registry.\n    \"\"\"\n    owner_class = type(owner)  # Get the class of the object\n    class_name = owner_class.__name__  # Name of the class\n\n    if only is None:\n        # Automatically detect all attributes of the class that are psygnal.Signal descriptors\n        only = [\n            name\n            for name in dir(owner_class)\n            if isinstance(getattr(owner_class, name, None), Signal)\n        ]\n\n    # Initialize the registry for this class if not already present\n    if class_name not in self._signals:\n        self._signals[class_name] = SignalCache()\n\n    # Iterate over the specified signal names and cache their instances\n    for name in only:\n        signal_descriptor = getattr(owner_class, name, None)\n        if isinstance(signal_descriptor, Signal):\n            # Retrieve the SignalInstance using the descriptor protocol\n            signal_instance = getattr(owner, name)\n            self._signals[class_name][name] = signal_instance\n</code></pre>"},{"location":"reference/api/virtual/#sunflare.virtual.VirtualBus.register_callbacks","title":"<code>register_callbacks(callback)</code>","text":"<p>Register a document callback in the virtual bus.</p> <p>Allows other components of the system access to specific document routers through the <code>callbacks</code> property.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>``CallbackType``</code> <p>The document callback to register.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>If the provided callback is not callable or does not accept the correct parameters.</p> Source code in <code>src/sunflare/virtual/_bus.py</code> <pre><code>def register_callbacks(self, callback: CallbackType) -&gt; None:\n    \"\"\"Register a document callback in the virtual bus.\n\n    Allows other components of the system access to\n    specific document routers through the `callbacks` property.\n\n    Parameters\n    ----------\n    callback : ``CallbackType``\n        The document callback to register.\n\n    Raises\n    ------\n    TypeError\n        If the provided callback is not callable or does not\n        accept the correct parameters.\n    \"\"\"\n    if isinstance(callback, DocumentRouter):\n        self._callbacks[callback.__class__.__name__] = callback\n    else:\n        if not callable(callback):\n            raise TypeError(f\"{callback} is not callable.\")\n        # validate that the callback accepts only two parameters\n        try:\n            inspect.signature(callback).bind(None, None)\n        except TypeError as e:\n            raise TypeError(\n                \"The callback function must accept exactly two parameters: \"\n                \"'name' (str) and 'document' (Document).\"\n            ) from e\n\n        # determine the key based on the type of callback\n        if inspect.ismethod(callback):\n            # bound method: if it's __call__, use the class name; otherwise use the method name\n            if callback.__name__ == \"__call__\":\n                key = callback.__self__.__class__.__name__\n            else:\n                key = callback.__name__\n        elif inspect.isfunction(callback):\n            # regular function: use the function name\n            key = callback.__name__\n        elif hasattr(callback, \"__call__\"):\n            # callable object (instance with __call__ method): use the class name\n            key = callback.__class__.__name__\n        else:\n            # fallback (should not reach here due to earlier callable check)\n            key = callback.__name__\n\n        self._callbacks[key] = callback\n</code></pre>"},{"location":"reference/api/virtual/#sunflare.virtual.HasConnection","title":"<code>HasConnection</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol marking your class as requesting connection to other signals.</p> <p>Tip</p> <p>This protocol is optional and only usable with <code>Presenters</code> and <code>Views</code>. <code>Models</code> will not be affected by this protocol.</p> Source code in <code>src/sunflare/virtual/_protocols.py</code> <pre><code>@runtime_checkable\nclass HasConnection(Protocol):  # pragma: no cover\n    \"\"\"Protocol marking your class as requesting connection to other signals.\n\n    !!! tip\n        This protocol is optional and only usable with\n        ``Presenters`` and ``Views``. ``Models``\n        will not be affected by this protocol.\n    \"\"\"\n\n    @abstractmethod\n    def connection_phase(self) -&gt; None:\n        \"\"\"Connect to other objects via the virtual bus.\n\n        At application start-up, objects within Redsun can't know what signals are available from other parts of the session.\n        This method is invoked after the object's construction and after `registration_phase` as well, allowing to\n        connect to all available registered signals in the virtual bus.\n        Objects may be able to connect to other signals even after this phase (provided those signals\n        were registered before).\n\n        An implementation example:\n\n        ```python\n        def connection_phase(self) -&gt; None:\n            # you can connect signals from another controller to your local slots...\n            self.virtual_bus[\"OtherController\"][\"signal\"].connect(self._my_slot)\n\n            # ... or to other signals ...\n            self.virtual_bus[\"OtherController\"][\"signal\"].connect(self.sigMySignal)\n\n            # ... or connect to a view component\n            self.virtual_bus[\"OtherWidget\"][\"sigWidget\"].connect(self._my_slot)\n        ```\n        \"\"\"\n        ...\n</code></pre>"},{"location":"reference/api/virtual/#sunflare.virtual.HasConnection.connection_phase","title":"<code>connection_phase()</code>  <code>abstractmethod</code>","text":"<p>Connect to other objects via the virtual bus.</p> <p>At application start-up, objects within Redsun can't know what signals are available from other parts of the session. This method is invoked after the object's construction and after <code>registration_phase</code> as well, allowing to connect to all available registered signals in the virtual bus. Objects may be able to connect to other signals even after this phase (provided those signals were registered before).</p> <p>An implementation example:</p> <pre><code>def connection_phase(self) -&gt; None:\n    # you can connect signals from another controller to your local slots...\n    self.virtual_bus[\"OtherController\"][\"signal\"].connect(self._my_slot)\n\n    # ... or to other signals ...\n    self.virtual_bus[\"OtherController\"][\"signal\"].connect(self.sigMySignal)\n\n    # ... or connect to a view component\n    self.virtual_bus[\"OtherWidget\"][\"sigWidget\"].connect(self._my_slot)\n</code></pre> Source code in <code>src/sunflare/virtual/_protocols.py</code> <pre><code>@abstractmethod\ndef connection_phase(self) -&gt; None:\n    \"\"\"Connect to other objects via the virtual bus.\n\n    At application start-up, objects within Redsun can't know what signals are available from other parts of the session.\n    This method is invoked after the object's construction and after `registration_phase` as well, allowing to\n    connect to all available registered signals in the virtual bus.\n    Objects may be able to connect to other signals even after this phase (provided those signals\n    were registered before).\n\n    An implementation example:\n\n    ```python\n    def connection_phase(self) -&gt; None:\n        # you can connect signals from another controller to your local slots...\n        self.virtual_bus[\"OtherController\"][\"signal\"].connect(self._my_slot)\n\n        # ... or to other signals ...\n        self.virtual_bus[\"OtherController\"][\"signal\"].connect(self.sigMySignal)\n\n        # ... or connect to a view component\n        self.virtual_bus[\"OtherWidget\"][\"sigWidget\"].connect(self._my_slot)\n    ```\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/api/virtual/#sunflare.virtual.HasRegistration","title":"<code>HasRegistration</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol marking your class as capable of emitting signals.</p> <p>Tip</p> <p>This protocol is optional and only available for <code>Presenters</code> and <code>Widgets</code>. <code>Models</code> will not be affected by this protocol.</p> Source code in <code>src/sunflare/virtual/_protocols.py</code> <pre><code>@runtime_checkable\nclass HasRegistration(Protocol):  # pragma: no cover\n    \"\"\"Protocol marking your class as capable of emitting signals.\n\n    !!! tip\n        This protocol is optional and only available for\n        ``Presenters`` and ``Widgets``. ``Models``\n        will not be affected by this protocol.\n    \"\"\"\n\n    @abstractmethod\n    def registration_phase(self) -&gt; None:\n        r\"\"\"Register the signals listed in this method to expose them to the virtual bus.\n\n        At application start-up, controllers can't know what signals are available from other controllers. \\\n        This method is called after all controllers are initialized to allow them to register their signals. \\\n        Presenters may be able to register further signals even after this phase (but not before the `connection_phase` ended). \\\n\n        Only signals defined in your object can be registered.\n\n        An implementation example:\n\n        ```python\n        def registration_phase(self) -&gt; None:\n            # you can register all signals...\n            self.virtual_bus.register_signals(self)\n\n            # ... or only a selection of them\n            self.virtual_bus.register_signals(self, only=[\"signal\"])\n        ```\n        \"\"\"\n        ...\n</code></pre>"},{"location":"reference/api/virtual/#sunflare.virtual.HasRegistration.registration_phase","title":"<code>registration_phase()</code>  <code>abstractmethod</code>","text":"<p>Register the signals listed in this method to expose them to the virtual bus.</p> <p>At application start-up, controllers can't know what signals are available from other controllers. \\ This method is called after all controllers are initialized to allow them to register their signals. \\ Presenters may be able to register further signals even after this phase (but not before the <code>connection_phase</code> ended). \\</p> <p>Only signals defined in your object can be registered.</p> <p>An implementation example:</p> <pre><code>def registration_phase(self) -&gt; None:\n    # you can register all signals...\n    self.virtual_bus.register_signals(self)\n\n    # ... or only a selection of them\n    self.virtual_bus.register_signals(self, only=[\"signal\"])\n</code></pre> Source code in <code>src/sunflare/virtual/_protocols.py</code> <pre><code>@abstractmethod\ndef registration_phase(self) -&gt; None:\n    r\"\"\"Register the signals listed in this method to expose them to the virtual bus.\n\n    At application start-up, controllers can't know what signals are available from other controllers. \\\n    This method is called after all controllers are initialized to allow them to register their signals. \\\n    Presenters may be able to register further signals even after this phase (but not before the `connection_phase` ended). \\\n\n    Only signals defined in your object can be registered.\n\n    An implementation example:\n\n    ```python\n    def registration_phase(self) -&gt; None:\n        # you can register all signals...\n        self.virtual_bus.register_signals(self)\n\n        # ... or only a selection of them\n        self.virtual_bus.register_signals(self, only=[\"signal\"])\n    ```\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/api/virtual/#sunflare.virtual.HasShutdown","title":"<code>HasShutdown</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol marking your class as capable of shutting down.</p> <p>Tip</p> <p>This protocol is optional and only available for <code>Presenters</code>. <code>Widgets</code> and <code>Models</code> will not be affected by this protocol.</p> Source code in <code>src/sunflare/virtual/_protocols.py</code> <pre><code>class HasShutdown(Protocol):  # pragma: no cover\n    \"\"\"Protocol marking your class as capable of shutting down.\n\n    !!! tip\n        This protocol is optional and only available for\n        ``Presenters``. ``Widgets`` and ``Models`` will not\n        be affected by this protocol.\n    \"\"\"\n\n    @abstractmethod\n    def shutdown(self) -&gt; None:\n        \"\"\"Shutdown an object. Performs cleanup operations.\n\n        If the object holds any kind of resources,\n        this method should invoke any equivalent shutdown method for each resource.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"reference/api/virtual/#sunflare.virtual.HasShutdown.shutdown","title":"<code>shutdown()</code>  <code>abstractmethod</code>","text":"<p>Shutdown an object. Performs cleanup operations.</p> <p>If the object holds any kind of resources, this method should invoke any equivalent shutdown method for each resource.</p> Source code in <code>src/sunflare/virtual/_protocols.py</code> <pre><code>@abstractmethod\ndef shutdown(self) -&gt; None:\n    \"\"\"Shutdown an object. Performs cleanup operations.\n\n    If the object holds any kind of resources,\n    this method should invoke any equivalent shutdown method for each resource.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"tutorials/","title":"Tutorials","text":"<p>Welcome to the Sunflare tutorials! These learning-oriented guides will help you understand the core concepts and patterns used in the Redsun ecosystem.</p>"},{"location":"tutorials/#what-youll-learn","title":"What you'll learn","text":"<p>Tutorials are learning-oriented lessons that take you through a series of steps to complete a project or understand a concept. They are designed for beginners and those new to Sunflare.</p>"},{"location":"tutorials/#available-tutorials","title":"Available Tutorials","text":"<ul> <li>OOP Crash Course - Learn the object-oriented programming patterns used throughout Sunflare and the Redsun ecosystem.</li> </ul>"},{"location":"tutorials/#next-steps","title":"Next Steps","text":"<p>Once you've completed the tutorials:</p> <ul> <li>Check out the How-to Guides for practical solutions to specific problems</li> <li>Read the Explanation section to deepen your understanding of Sunflare's architecture</li> <li>Refer to the API Reference for detailed technical information</li> </ul>"},{"location":"tutorials/oop-crash-course/","title":"O.O.P. crash course","text":"<p>This sections offers a very quick crash course in commonly used programming patterns in the object-oriented programming paradigm.</p> <p>Python is a multi-paradigm language (meaning that it leverages OOP but also other paradigms), but the Redsun ecosystem mostly focuses on this paradigm.</p> <p>We will use Unified Modeling Language (UML) diagrams made with mermaid for visual representation of these patterns.</p>"},{"location":"tutorials/oop-crash-course/inheritance/","title":"Inheritance","text":"<p>Inheritance is a mechanism of basing a class on the implementation of another class. The original class is often referred to as a parent, the class that implements the original is often referred to as a child class.</p> <p>In Python, parent classes can provide abstract methods, functions without actual executable code but instead serving as a customizable template.</p> <pre><code>:config: { \"theme\": \"neutral\", \"fontFamily\": \"Courier New\" }\n:align: center\n\n    classDiagram\n        class Animal{\n            +int paws\n            fly()*void\n            talk()*void\n            how_many_paws() int\n        }\n        class Duck {\n            fly() void\n            talk() void\n        }\n\n        Animal &lt;|-- Duck : inherits from\n        note for Animal \"Duck inherits from Animal\"</code></pre> <p>The diagram shows an example this: <code>Animal</code> provides an interface with both abstract and normal methods, while <code>Duck</code> provides an implementation for the abstract methods. In Python, this would be equivalent to:</p> <pre><code>from abc import ABC, abstractmethod\n\nclass Animal(ABC):\n    paws: int\n\n    @abstractmethod\n    def fly(self):\n        ...\n    @abstractmethod\n    def talk(self):\n        ...\n\n    def how_many_paws(self):\n        print(\"I have\", self.paws, \"paws\")\n\nclass Duck(Animal):\n    def __init__():\n        self.paws = 2\n\n    def fly(self):\n        print(\"Flying!\")\n    def talk(self):\n        print(\"Quack!\")\n\nanimal = Duck(2)\nduck.fly() # prints \"Flying!\"\nduck.talk() # prints \"Quack!\"\nduck.how_many_paws() # prints \"I have 2 paws\"\n</code></pre> <p>It's an effective pattern which allows to reuse the same code and extend it depending on the need.</p> <p>But sometimes it may become an hinderance. If we want to create a <code>Cat</code> class instead ...</p> <pre><code>class Cat(Animal):\n    def __init__(self):\n        self.paws = 4\n\n    # cats can't fly,\n    # they can only talk\n    def talk(self):\n        print(\"Meow!\")\n\ncat = Cat()\n# the line above causes an exception:\n# TypeError: Can't instantiate abstract class Cat with abstract method fly\n</code></pre> <p>... we get an error! Of course, we could just implement <code>fly()</code> and simply print <code>I can't fly</code>, but a real situation that method may be doing a computation or performing another action which is inconsistent with the defined base class <code>Animal</code>.</p>"}]}